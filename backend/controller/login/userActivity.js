const userActivity = require('../../model/login/userActivity');
const userActivityScreenshot = require('../../model/login/userActivityScreenshot');
const userActivityLiveScreen = require('../../model/login/userActivityLiveScreen');
const ErrorHandler = require('../../utils/errorhandler');
const catchAsyncErrors = require("../../middleware/catchAsyncError");
const User = require("../../model/login/auth");
const moment = require("moment");
const path = require('path');
const fs = require('fs');

exports.createUserActivity = catchAsyncErrors(async (req, res, next) => {
    const activityArray = req.body.activity;

    // Ensure req.body.activity is an array
    if (!Array.isArray(activityArray)) {
        return res.status(400).json({
            message: 'Invalid data format. Expected an array of activity objects.',
            success: false
        });
    }

    // Collect all usernames to query the User collection in one go
    const usernamesSet = new Set();
    activityArray.forEach(event => {
        usernamesSet.add(event.username.trim());
    });

    // Find all users in one query
    const usernames = Array.from(usernamesSet);
    let users = await User.find({ username: { $in: usernames } }, 'username company branch unit team department companyname empcode').lean();

    // Create a map of users for quick lookup
    let usersMap = {};
    users.forEach(user => {
        usersMap[user.username] = user;
    });

    // Process activityArray and enrich it with user details or mark as Mismatched
    let enrichedActivityArray = activityArray.map(event => {
        const username = event.username.trim();
        const foundData = usersMap[username] || {};  // Find user in usersMap or return an empty object

        return {
            ...event,  // Include original event data
            company: foundData.company || "",  // Fill user data if found, else empty string
            branch: foundData.branch || "",
            team: foundData.team || "",
            unit: foundData.unit || "",
            employeename: foundData.companyname || "",
            department: foundData.department || "",
            employeeid: String(foundData?._id) || "",
            employeecode: foundData.empcode || "",
            date: moment(event.timestamp).format('YYYY-MM-DD'),
            time: moment(event.timestamp).format('HH:mm:ss'),
            status: foundData.username ? "Matched" : "Mismatched"  // Determine status based on whether user was found
        };
    });
    try {
        // Insert all enriched activity logs in one go
        await userActivity.insertMany(enrichedActivityArray);

        return res.status(200).json({
            message: 'Successfully added all activity logs!',
            success: true
        });
    } catch (error) {
        // Handle any errors during the save process
        return res.status(500).json({
            message: 'Error saving activity logs.',
            error: error.message,
            success: false
        });
    }
});


exports.createUserActivityScreenshot = catchAsyncErrors(async (req, res, next) => {
    const { macaddress, username, localip, devicename, timestamp } = req.body;

    // File data from multer (screenshot)
    const file = req.file;

    if (!file) {
        return res.status(400).json({
            message: 'No screenshot file uploaded.',
            success: false
        });
    }

    // Ensure req.body has the necessary fields
    if (!macaddress || !username || !localip || !devicename || !timestamp) {
        return res.status(400).json({
            message: 'Missing required fields.',
            success: false
        });
    }

    // Find user based on the username provided
    let user = await User.findOne({ username: username.trim() }, 'username company branch unit team department companyname empcode').lean();

    let enrichedActivity = {
        macaddress: macaddress,
        username: username.trim(),
        localip: localip,
        devicename: devicename,
        timestamp: new Date(timestamp),
        date: moment(timestamp).format('YYYY-MM-DD'),
        time: moment(timestamp).format('HH:mm:ss'),
        company: user?.company || "",  // Fill user data if found, else empty string
        branch: user?.branch || "",
        team: user?.team || "",
        unit: user?.unit || "",
        employeename: user?.companyname || "",
        department: user?.department || "",
        employeeid: String(user?._id) || "",
        employeecode: user?.empcode || "",
        status: user?.username ? "Matched" : "Mismatched",  // Determine status based on whether user was found

        // File metadata
        filename: file.filename,  // File name generated by multer
        filepath: file.path,      // File path generated by multer
        filesize: file.size       // File size in bytes
    };

    try {
        // Insert the activity log into the database
        await userActivityScreenshot.create(enrichedActivity);

        return res.status(200).json({
            message: 'Screenshot and activity log saved successfully!',
            success: true
        });
    } catch (error) {
        return res.status(500).json({
            message: 'Error saving activity log.',
            error: error.message,
            success: false
        });
    }
});
exports.createUserActivityLiveScreen = catchAsyncErrors(async (req, res, next) => {
    const { macaddress, username, localip, devicename, timestamp } = req.body;



    // Ensure req.body has the necessary fields
    if (!macaddress || !username || !localip || !devicename || !timestamp) {
        return res.status(400).json({
            message: 'Missing required fields.',
            success: false
        });
    }

    // Find user based on the username provided
    let user = await User.findOne({ username: username.trim() }, 'username company branch unit team department companyname empcode').lean();

    let enrichedActivity = {
        macaddress: macaddress,
        username: username.trim(),
        localip: localip,
        devicename: devicename,
        timestamp: new Date(timestamp),
        date: moment(timestamp).format('YYYY-MM-DD'),
        time: moment(timestamp).format('HH:mm:ss'),
        company: user?.company || "",  // Fill user data if found, else empty string
        branch: user?.branch || "",
        team: user?.team || "",
        unit: user?.unit || "",
        employeename: user?.companyname || "",
        department: user?.department || "",
        employeecode: user?.empcode || "",
        status: user?.username ? "Matched" : "Mismatched",
        live: false, // Determine status based on whether user was found

    };

    try {
        // Check if a record with the same macaddress already exists
        const existingRecord = await userActivityLiveScreen.findOne({ macaddress });

        if (existingRecord) {
            // If a record is found, update the live field to false and update other fields
            await userActivityLiveScreen.findOneAndUpdate(
                { macaddress: macaddress },
                {
                    $set: {
                        ...enrichedActivity,  // Update all fields
                        live: false           // Specifically update the live field
                    }
                },
                { new: true }  // Return the updated document
            );

            return res.status(200).json({
                message: 'Updated existing record successfully!',
                success: true
            });
        } else {
            // If no record is found, create a new document
            await userActivityLiveScreen.create(enrichedActivity);

            return res.status(200).json({
                message: 'Created new record successfully!',
                success: true
            });
        }
    } catch (error) {
        return res.status(500).json({
            message: 'Error saving activity log.',
            error: error.message,
            success: false
        });
    }
});
// controller to delete previous day datas

// exports.deleteUserActivityScreenshot = catchAsyncErrors(async (req, res, next) => {
//     try {
//         // Get the timestamp 24 hours ago from the current time
//         const twentyFourHoursAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
//         // Find all records in MongoDB that are older than 24 hours
//         const oldRecords = await userActivityScreenshot.find({ createdAt: { $lt: twentyFourHoursAgo } });
//         // If there are records to delete
//         if (oldRecords.length > 0) {
//             // Get an array of file paths
//             const filePaths = oldRecords.map(record => path.join('useractivity/', record.filename));
//             // Delete all files that exist
//             filePaths.forEach(filePath => {
//                 if (fs.existsSync(filePath)) {
//                     fs.unlinkSync(filePath);
//                 } else {
//                 }
//             });

//             // Delete all records in MongoDB at once
//             const deleteResult = await userActivityScreenshot.deleteMany({ createdAt: { $lt: twentyFourHoursAgo } });

//             return `${deleteResult.deletedCount} old records and associated files deleted successfully.`
//         } else {
//             return "No old records found."
//         }
//     } catch (error) {
//         return res.status(500).json({
//             success: false,
//             message: `Error deleting old files and records: ${error.message}`
//         });
//     }
// });
// exports.deleteUserActivityLog = catchAsyncErrors(async (req, res, next) => {
//     try {
//         // Get the timestamp 24 hours ago from the current time
//         const twentyFourHoursAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
//         // Find and delete records older than 24 hours
//         const deleteResult = await userActivity.deleteMany({ createdAt: { $lt: twentyFourHoursAgo } });

//         if (deleteResult.deletedCount > 0) {
//             return `${deleteResult.deletedCount} old records  deleted successfully.`;
//         } else {
//             return `No old records found.`;
//         }
//     } catch (error) {
//         return `Error deleting old files and records:, ${error}`;
//     }
// });

//controller to delete datas other than recent 10000 datas
exports.deleteUserActivityScreenshot = catchAsyncErrors(async (req, res, next) => {
    try {
        // Count the total number of records in the collection
        const totalRecords = await userActivityScreenshot.countDocuments();

        // Check if there are more than 10,000 records
        if (totalRecords > 100000) {
            // Calculate the number of records to delete
            const recordsToDelete = totalRecords - 10000;

            // Find the oldest records to delete
            const oldRecords = await userActivityScreenshot
                .find({})
                .sort({ createdAt: 1 }) // Sort by createdAt in ascending order (oldest first)
                .limit(recordsToDelete); // Limit to the number of records to delete

            // If there are records to delete
            if (oldRecords.length > 0) {
                // Get an array of file paths
                const filePaths = oldRecords.map(record => path.join('useractivity/', record.filename));

                // Delete all files that exist
                filePaths.forEach(filePath => {
                    if (fs.existsSync(filePath)) {
                        fs.unlinkSync(filePath);
                    } else {
                    }
                });

                // Delete the records from MongoDB
                const deleteResult = await userActivityScreenshot.deleteMany({
                    _id: { $in: oldRecords.map(record => record._id) },
                });

                return `${deleteResult.deletedCount} old records and associated files deleted successfully.`
            }
        } else {
            return "No records need to be deleted. Total records are within the limit."
        }
    } catch (error) {
        return `Error deleting old files and records: ${error.message}`
    }
});

exports.deleteUserActivityLog = catchAsyncErrors(async (req, res, next) => {
    try {
        const BATCH_SIZE = 100000; // Define batch size
        const MAX_RECORDS = 100000; // Max records to keep
        let totalRecords = await userActivity.countDocuments();
        // Check if we need to delete records
        while (totalRecords > MAX_RECORDS) {
            // Calculate the number of records to delete
            const recordsToDelete = Math.min(totalRecords - MAX_RECORDS, BATCH_SIZE);

            // Fetch oldest records
            const oldRecords = await userActivity
                .find({}, '_id')
                .sort({ createdAt: 1 })
                .limit(recordsToDelete);

            // Extract IDs to delete
            const idsToDelete = oldRecords.map(record => String(record._id));

            // Delete the records
            const deleteResult = await userActivity.deleteMany({ _id: { $in: idsToDelete } });

            // Update total record count
            totalRecords = await userActivity.countDocuments();
        }

        return "Old records deleted successfully, total records are now within the limit.";
    } catch (error) {
        return `Error deleting old records: ${error.message}`
    }
});




exports.dynamicQueryUserActivityController = catchAsyncErrors(async (req, res, next) => {
    try {
        const { aggregationPipeline } = req.body;

        const users = await userActivity.aggregate(aggregationPipeline);
        return res.status(200).json({
            users,
        });
    } catch (err) {
        return res.status(500).json({ error: "Internal server error" });
    }
});


exports.getAllUserActivityStorage = catchAsyncErrors(async (req, res, next) => {
    try {
        // Define a helper function to reduce code duplication
        const aggregateUserActivity = async (collection) => {
            return await collection.aggregate([
                {
                    $group: {
                        _id: null,
                        usernames: { $addToSet: "$username" },
                        systems: { $addToSet: "$devicename" }
                    }
                },
                {
                    $project: {
                        _id: 0,
                        usernames: {
                            $filter: {
                                input: "$usernames",
                                as: "username",
                                cond: { $ne: ["$$username", ""] } // Exclude empty strings
                            }
                        },
                        systems: {
                            $filter: {
                                input: "$systems",
                                as: "devicename",
                                cond: { $ne: ["$$devicename", ""] } // Exclude empty strings
                            }
                        }
                    }
                }
            ]).exec(); // Ensure execution
        };

        // Use Promise.all to fetch data concurrently
        const [eventstorage, useractivityscreenshot, useractivitylivescreen] = await Promise.all([
            aggregateUserActivity(userActivity),
            aggregateUserActivity(userActivityScreenshot),
            aggregateUserActivity(userActivityLiveScreen)
        ]);



        return res.status(200).json({ eventstorage, useractivityscreenshot, useractivitylivescreen });
    } catch (err) {
        return next(new ErrorHandler("Error fetching records!", 500));
    }
});


exports.dynamicQueryUserActivityScreenshotController = catchAsyncErrors(async (req, res, next) => {
    try {
        const { aggregationPipeline } = req.body;
        const users = await userActivityScreenshot.aggregate(aggregationPipeline);
        return res.status(200).json({
            users,
        });
    } catch (err) {
        return res.status(500).json({ error: "Internal server error" });
    }
});
exports.dynamicQueryUserActivityLiveScreenController = catchAsyncErrors(async (req, res, next) => {
    try {
        const { aggregationPipeline } = req.body;

        const users = await userActivityLiveScreen.aggregate(aggregationPipeline);
        return res.status(200).json({
            users,
        });
    } catch (err) {
        return res.status(500).json({ error: "Internal server error" });
    }
});


exports.hiTrackerNotInstalledUsers = catchAsyncErrors(async (req, res, next) => {
    try {
        const { company, branch, unit, team, department } = req.body;

        // Step 1: Get unique employeename with status: "Matched"
        const matchedEmployees = await userActivityLiveScreen.aggregate([
            { $match: { status: "Matched" } }, // Filter documents with status: "Matched"
            { $group: { _id: null, uniqueEmployees: { $addToSet: "$employeename" } } }, // Get unique employeename
            { $project: { _id: 0, uniqueEmployees: 1 } }, // Exclude _id from the result
        ]);



        const employeenames = matchedEmployees[0]?.uniqueEmployees || []; // Extract unique employeename array

        // Step 2: Filter users based on conditions
        const filteredUsers = await User.aggregate([
            {
                $match: {
                    resonablestatus: {
                        $nin: [
                            "Not Joined",
                            "Postponed",
                            "Rejected",
                            "Closed",
                            "Releave Employee",
                            "Absconded",
                            "Hold",
                            "Terminate",
                        ],
                    },
                    companyname: { $nin: employeenames },

                    // Conditional company filter
                    ...(company.length && { company: { $in: company } }),
                    // Conditional branch filter
                    ...(branch.length && { branch: { $in: branch } }),
                    // Conditional unit filter
                    ...(unit.length && { unit: { $in: unit } }),
                    // Conditional team filter
                    ...(team.length && { team: { $in: team } }),
                    // Conditional department filter
                    ...(department.length && { department: { $in: department } }),
                },
            },
            {
                $project: {
                    company: 1,
                    branch: 1,
                    unit: 1,
                    team: 1,
                    department: 1,
                    designation: 1,
                    username: 1,
                    companyname: 1,
                    boardingLog: 1,
                    loginUserStatus: 1,
                }, // Include only required fields
            },
        ]);
        return res.status(200).json({
            filteredUsers,
        });
    } catch (err) {
        return res.status(500).json({ error: "Internal server error" });
    }
});
