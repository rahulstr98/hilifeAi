const Salaryslab = require("../../model/modules/setup/SalarySlabModel")
const { format } = require('date-fns');
const User = require("../../model/login/auth");
const ErrorHandler = require("../../utils/errorhandler");
const catchAsyncErrors = require("../../middleware/catchAsyncError");
const BiometricDeviceManagement = require('../../model/modules/BiometricDeviceManagementModel');
const bcrypt = require("bcryptjs");
const pLimit = require('p-limit');
const { decryptPassword } = require("./decryptPassword");
const sendToken = require("../../utils/jwttokentocookie");
const checksendToken = require("../../utils/checkjson");
const sendEmail = require("../../utils/pwdresetmail");
const ProcessTeam = require("../../model/modules/production/ProcessTeamModel");
const Targetpoints = require("../../model/modules/production/targetpoints");
const Noticeperiod = require("../../model/modules/recruitment/noticeperiodapply");
const AssignBranch = require("../../model/modules/assignbranch");
const HolidayWeekOffRestriction = require("../../model/modules/settings/HolidayWeekoffRestriction");
const AutoLogout = require("../../model/modules/settings/autologout");
const EventLog = require('../../model/modules/settings/eventstorage');
const { ObjectId } = require("mongodb");
const crypto = require("crypto");
const qrcode = require("qrcode");
const mongoose = require('mongoose');
const moment = require("moment");
const { authenticator } = require("otplib");
const Token = require("../../model/login/token");
const sendVerificationEmail = require("./sendEmail");
const AdminOverAllSettings = require("../../model/modules/settings/AdminOverAllSettingsModel");
const IndividualSettings = require("../../model/modules/settings/IndividualSettingsModel");
const ClockinIP = require("../../model/modules/settings/clockinipModel");
const ControlCriteria = require("../../model/modules/settings/Attendancecontrolcriteria");
const Shift = require('../../model/modules/shift');
const Attendance = require("../../model/modules/attendance/attendance");
const DepartmentMonth = require("../../model/modules/departmentmonthset");
const ApplyLeave = require('../../model/modules/leave/applyleave');
const Holiday = require('../../model/modules/setup/holidayModel');
const Hirerarchi = require('../../model/modules/setup/hierarchy');
const Designation = require("../../model/modules/designation");
const Department = require("../../model/modules/department");
const Leavetype = require('../../model/modules/leave/leavetype');
const Permission = require('../../model/modules/permission/permission');
const EmployeeDocuments = require('../../model/login/employeedocuments');
const MyCheckList = require("../../model/modules/interview/Myinterviewchecklist");
const Company = require("../../model/modules/setup/company");
const workStation = require("../../model/modules/workstationmodel");
const Branch = require("../../model/modules/branch");
const ChatConfiguration = require('../../model/modules/settings/ChatConfiguration');
const Unit = require("../../model/modules/unit");
const currentDateAttStatus = new Date();
const faceapi = require("face-api.js");
const AttendanceControlCriteria = require("../../model/modules/settings/Attendancecontrolcriteria");
const axios = require('axios');
const rocketChatLogin = require('../modules/rocketchat/rocketChatLogin');
const rocketChatTeamChannelGrouping = require('../../model/modules/rocketchat/rocketChatTeamChannelGrouping');
const { updateRocketChatUserDetails, getSingleUserData } = require('../../controller/modules/rocketchat/rocketChatUsers');
const ClientUserID = require("../../model/modules/production/ClientUserIDModel");
const ClientUserid = require('../../model/modules/production/ClientUserIDModel');
const RemoteWorkMode = require("../../model/login/remoteworkmode");
const DayPointsUpload = require("../../model/modules/production/dayPointsUpload");
const DayPointsUploadTemp = require('../../model/modules/production/daypointsuploadtemp');
const RevenueAmount = require("../../model/modules/production/RevenueAmountModel");
const AcPointVal = require('../../model/modules/production/acpointscalculation');
const ShortageMaster = require("../../model/modules/production/Shortagemaster");
const PenaltyClientError = require('../../model/modules/penalty/penaltyclienterror');
const Achievedaccuracyindividualuploaddatas = require('../../model/modules/accuracy/achievedaccuracyindividualuploaddata');
const WorkStationShortNameGeneration = require('../../utils/workstationShortName');
const { Hierarchyfilter } = require('../../utils/taskManagerCondition');
const Leavecriteria = require("../../model/modules/leave/leavecriteria");
const ProductionUpload = require("../../model/modules/production/productionupload");
const ProducionIndividual = require("../../model/modules/production/productionindividual")
const Biometricattlog = require('../../model/modules/biometric/biometricattalog');

const formatDateRemove = (inputDate) => {
    if (!inputDate) {
        return ""
    }
    // Assuming inputDate is in the format "dd-mm-yyyy"
    const [day, month, year] = inputDate?.split('-');

    return `${day}/${month}/${year}`;
};

// Compare manual date with with formattedDate
const formatDate = (inputDate) => {
    if (!inputDate) {
        return ""
    }
    // Assuming inputDate is in the format "dd-mm-yyyy"
    const [day, month, year] = inputDate?.split('/');

    // Use padStart to add leading zeros
    const formattedDay = String(day)?.padStart(2, '0');
    const formattedMonth = String(month)?.padStart(2, '0');

    return `${formattedDay}/${formattedMonth}/${year}`;
};

// Att Month Status
const formatDateLeaveDate = (inputDate) => {
    if (!inputDate) {
        return '';
    }
    // Assuming inputDate is in the format "dd-mm-yyyy"
    const [year, month, day] = inputDate?.split('-');
    return `${day}-${month}-${year}`;
};

// Compare manual date with with formattedDate
const formatDateForShiftDate = (inputDate) => {
    if (!inputDate) {
        return ""
    }
    // Assuming inputDate is in the format "dd-mm-yyyy"
    const [day, month, year] = inputDate?.split('/');
    // Use padStart to add leading zeros
    const formattedDay = String(day)?.padStart(2, '0');
    const formattedMonth = String(month)?.padStart(2, '0');
    return `${formattedDay}-${formattedMonth}-${year}`;
};

// Compare approved adjdate with formattedDate
const formatAdjDate = (inputDate) => {
    if (!inputDate) {
        return "";
    }
    // Assuming inputDate is in the format "dd-mm-yyyy"
    const [day, month, year] = inputDate?.split('/');
    return `${day}-${month}-${year}`;
};

//const parseTime = (timeString) => {
// if (!timeString) {
//    return '';
//}

// // Check if the timeString contains a space
// const hasSpace = timeString?.includes(' ');

//  // Split based on whether there's a space or not
//  const [time, period] = hasSpace ? timeString?.split(' ') : [timeString?.slice(0, -2), timeString?.slice(-2)];

// const [hours, minutes, seconds] = time?.split(':');

//  let parsedHours = parseInt(hours, 10);

//  //if ((period === 'PM' && parsedHours !== 12) && (period === 'pm' && parsedHours !== 12)) {
//  //  parsedHours += 12;
// // } else if ((period === 'AM' && parsedHours === 12) && (period === 'am' && parsedHours === 12)) {
//   //  parsedHours = 0;
// // }

//if ((period === 'PM' && parsedHours !== 12) || (period === 'pm' && parsedHours !== 12)) {
//  parsedHours += 12;
// }
//else if ((period === 'AM' && parsedHours === 12) || (period === 'am' && parsedHours === 12)) {
//parsedHours = 0;
//  }
// // if ((period === 'PM' || period === 'pm') && parsedHours !== 12) {
//  //  parsedHours += 12;
// // }
//  //else if ((period === 'AM' || period === 'am') && parsedHours === 12) {
// //  parsedHours = 0;
// //}


//  return new Date(2000, 0, 1, parsedHours, parseInt(minutes, 10), parseInt(seconds || 0, 10));
//};

// const parseTime = (timeString) => {
//     if (!timeString) {
//         return '';
//     }

//     // Check if the timeString contains a space
//     const hasSpace = timeString?.includes(' ');

//     // Split based on whether there's a space or not
//     const [time, period] = hasSpace ? timeString?.split(' ') : [timeString.slice(0, -2), timeString.slice(-2)];

//     const [hours, minutes, seconds] = time?.split(':');

//     let parsedHours = parseInt(hours, 10);
//     if ((period === 'PM' && parsedHours !== 12) && (period === 'pm' && parsedHours !== 12)) {
//         parsedHours += 12;
//     } else if ((period === 'AM' && parsedHours === 12) && (period === 'am' && parsedHours === 12)) {
//         parsedHours = 0;
//     }

//     return new Date(2000, 0, 1, parsedHours, parseInt(minutes, 10), parseInt(seconds || 0, 10));
// };

const parseTime = (timeString) => {
    if (!timeString) {
        return '';
    }

    // Check if the timeString contains a space
    const hasSpace = timeString?.includes(' ');

    // Split based on whether there's a space or not
    const [time, period] = hasSpace ? timeString?.split(' ') : [timeString?.slice(0, -2), timeString?.slice(-2)];

    const [hours, minutes, seconds] = time?.split(':');

    let parsedHours = parseInt(hours, 10);

    if ((period === 'PM' && parsedHours !== 12) && (period === 'pm' && parsedHours !== 12)) {
        parsedHours += 12;
    } else if ((period === 'AM' && parsedHours === 12) && (period === 'am' && parsedHours === 12)) {
        parsedHours = 0;
    }

    // if ((period === 'PM' && parsedHours !== 12) || (period === 'pm' && parsedHours !== 12)) {
    //     parsedHours += 12;
    // }
    // else if ((period === 'AM' && parsedHours === 12) || (period === 'am' && parsedHours === 12)) {
    //     parsedHours = 0;
    // }

    if ((period === 'PM' || period === 'pm') && parsedHours !== 12) {
        parsedHours += 12;
    }
    else if ((period === 'AM' || period === 'am') && parsedHours === 12) {
        parsedHours = 0;
    }

    return new Date(2000, 0, 1, parsedHours, parseInt(minutes, 10), parseInt(seconds || 0, 10));
};

exports.getAllUserProduction = catchAsyncErrors(async (req, res, next) => {
    let usersstatus;

    try {
        usersstatus = await User.find(
            {

                resonablestatus: {
                    $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
            },
            {

                resonablestatus: 1,


                company: 1,
                empcode: 1,
                companyname: 1,
                addremoteworkmode: 1,
                team: 1,
                username: 1,

                unit: 1,
                branch: 1,

                team: 1,
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!usersstatus) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ usersstatus });
});


exports.getAllEnquieryUsers = catchAsyncErrors(async (req, res, next) => {
    let users;

    try {
        users = await User.find(
            {
                enquirystatus: "Enquiry Purpose",
            },
            {
                status: 1,
                resonablestatus: 1,
                reasonname: 1,
                lastworkday: 1,
                rejoin: 1,
                reasonablestatusremarks: 1,
                department: 1,
                dob: 1,
                contactpersonal: 1,
                designationlog: 1,
                processlog: 1,
                boardingLog: 1,
                attendancemode: 1,
                company: 1,
                reasondate: 1,
                empreason: 1,
                percentage: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                username: 1,
                usernameautogenerate: 1,
                workmode: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,

                unit: 1,
                branch: 1,
                designation: 1,
                floor: 1,
                shift: 1,
                reportingto: 1,
                experience: 1,
                doj: 1,
                dot: 1,
                bankname: 1,
                bankdetails: 1,
                bankbranchname: 1,
                accountholdername: 1,
                accountnumber: 1,
                ifsccode: 1,
                shifttiming: 1,
                shiftgrouping: 1,
                legalname: 1,
                callingname: 1,
                pdoorno: 1,
                pstreet: 1,
                parea: 1,
                plandmark: 1,
                ptaluk: 1,
                ppost: 1,
                ppincode: 1,
                pcountry: 1,
                pstate: 1,
                pcity: 1,
                cdoorno: 1,
                cstreet: 1,
                carea: 1,
                role: 1,
                clandmark: 1,
                ctaluk: 1,
                cpost: 1,
                cpincode: 1,
                ccountry: 1,
                cstate: 1,
                ccity: 1,
                reasondate: 1,
                process: 1,
                workstation: 1,
                weekoff: 1,
                originalpassword: 1,
                enquirystatus: 1,
                area: 1,
                enableworkstation: 1,
                wordcheck: 1,
                shiftallot: 1,
                firstname: 1,
                lastname: 1,
                employeecount: 1,
                emergencyno: 1,
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: users.length, users });
});

// get All user => /api/users
exports.getAllUsers = catchAsyncErrors(async (req, res, next) => {
    let users;

    try {
        users = await User.find(
            {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
                resonablestatus: {
                    $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
            },
            {
                wfhstatus: 1,
                wfhcount: 1,
                status: 1,
                resonablestatus: 1,
                reasonname: 1,
                rejoin: 1,
                reasonablestatusremarks: 1,
                department: 1,
                departmentlog: 1,
                dob: 1,
                gender: 1,
                maritalstatus: 1,
                bloodgroup: 1,
                loginUserStatus: 1,
                location: 1,
                contactpersonal: 1,
                panno: 1,
                aadhar: 1,
                designationlog: 1,
                contactfamily: 1,
                approvedremotestatus: 1,
                ctaluk: 1,
                dom: 1,
                processlog: 1,
                boardingLog: 1,
                attendancemode: 1,
                company: 1,
                reasondate: 1,
                empreason: 1,
                percentage: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                username: 1,
                usernameautogenerate: 1,
                workmode: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,
                departmentlog: 1,
                unit: 1,
                branch: 1,
                designation: 1,
                floor: 1,
                shift: 1,
                reportingto: 1,
                experience: 1,
                doj: 1,
                dot: 1,
                bankname: 1,
                bankdetails: 1,
                bankbranchname: 1,
                accountholdername: 1,
                accountnumber: 1,
                ifsccode: 1,
                shifttiming: 1,
                shiftgrouping: 1,
                legalname: 1,
                callingname: 1,
                pdoorno: 1,
                pstreet: 1,
                candidateid: 1,
                parea: 1,
                plandmark: 1,
                ptaluk: 1,
                ppost: 1,
                ppincode: 1,
                pcountry: 1,
                pstate: 1,
                pcity: 1,
                cdoorno: 1,
                cstreet: 1,
                carea: 1,
                role: 1,
                clandmark: 1,
                ctaluk: 1,
                cpost: 1,
                cpincode: 1,
                ccountry: 1,
                cstate: 1,
                ccity: 1,
                reasondate: 1,
                process: 1,
                workstation: 1,
                weekoff: 1,
                originalpassword: 1,
                enquirystatus: 1,
                area: 1,
                enableworkstation: 1,
                wordcheck: 1,
                shiftallot: 1,
                firstname: 1,
                lastname: 1,
                employeecount: 1,
                emergencyno: 1,
                name: 1,
                salarysetup: 1,
                mode: 1,
                salarycode: 1,
                basic: 1,
                hra: 1,
                conveyance: 1,
                medicalallowance: 1,
                productionallowance: 1,
                otherallowance: 1,
                productionallowancetwo: 1,
                pffromdate: 1,
                pfenddate: 1,
                esifromdate: 1,
                esienddate: 1,
                pfesistatus: 1,
                resonablestatus: 1,
                reasonname: 1,
                department: 1,
                dob: 1,
                location: 1,
                bloodgroup: 1,
                gender: 1,
                maritalstatus: 1,
                lastname: 1,
                contactpersonal: 1,
                processlog: 1,
                boardingLog: 1,
                attendancemode: 1,
                designationlog: 1,
                company: 1,
                reasondate: 1,
                empreason: 1,
                percentage: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                floor: 1,
                username: 1,
                usernameautogenerate: 1,
                workmode: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,

                unit: 1,
                branch: 1,
                designation: 1,
                team: 1,
                bankdetails: 1,
                shift: 1,
                reportingto: 1,
                experience: 1,
                doj: 1,
                role: 1,
                bankname: 1,
                bankdetails: 1,
                bankbranchname: 1,
                accountholdername: 1,
                accountnumber: 1,
                ifsccode: 1,
                shifttiming: 1,
                shiftgrouping: 1,
                legalname: 1,
                callingname: 1,
                pdoorno: 1,
                pstreet: 1,
                parea: 1,
                plandmark: 1,
                ptaluk: 1,
                ppost: 1,
                ppincode: 1,
                pcountry: 1,
                pstate: 1,
                pcity: 1,
                cdoorno: 1,
                cstreet: 1,
                carea: 1,
                clandmark: 1,
                ctaluk: 1,
                cpost: 1,
                cpincode: 1,
                ccountry: 1,
                cstate: 1,
                ccity: 1,
                reasondate: 1,
                process: 1,
                workstation: 1,
                weekoff: 1,
                originalpassword: 1,
                enquirystatus: 1,
                area: 1,
                enableworkstation: 1,
                wordcheck: 1,
                shiftallot: 1,
                twofaenabled: 1,
                fathername: 1,
                mothername: 1,
                firstname: 1,
                workstationinput: 1,
                emergencyno: 1,
                referencetodo: 1,
                contactno: 1,
                details: 1,
                assignExpLog: 1,
                grosssalary: 1,
                timemins: 1,
                modeexperience: 1,
                targetexperience: 1,
                targetpts: 1,
                expval: 1,
                expmode: 1,
                process: 1,
                processtype: 1,
                processduration: 1,
                duration: 1,
                workstationofficestatus: 1,
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: users.length, users });
});

exports.getAllUserAaccessibleBranch = catchAsyncErrors(async (req, res, next) => {
    let users;
    const { assignbranch } = req.body;

    // Create a query array for company and branch
    const query = {
        $or: assignbranch.map(item => ({
            company: item.company,
            branch: item.branch,
            unit: item.unit
        })),
        enquirystatus: { $nin: ["Enquiry Purpose"] },
        resonablestatus: { $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"] }
    };

    try {
        users = await User.find(
            query,
            {
                status: 1,
                resonablestatus: 1,
                reasonname: 1,
                lastworkday: 1,
                rejoin: 1,
                reasonablestatusremarks: 1,
                department: 1,
                dob: 1,
                gender: 1,
                maritalstatus: 1,
                bloodgroup: 1,
                loginUserStatus: 1,
                location: 1,
                contactpersonal: 1,
                panno: 1,
                aadhar: 1,
                designationlog: 1,
                contactfamily: 1,
                ctaluk: 1,
                dom: 1,
                processlog: 1,
                boardingLog: 1,
                attendancemode: 1,
                company: 1,
                addremoteworkmode: 1,
                reasondate: 1,
                empreason: 1,
                percentage: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                username: 1,
                usernameautogenerate: 1,
                workmode: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,

                unit: 1,
                branch: 1,
                designation: 1,
                floor: 1,
                shift: 1,
                reportingto: 1,
                experience: 1,
                doj: 1,
                dot: 1,
                bankname: 1,
                bankdetails: 1,
                bankbranchname: 1,
                accountholdername: 1,
                accountnumber: 1,
                ifsccode: 1,
                shifttiming: 1,
                shiftgrouping: 1,
                legalname: 1,
                callingname: 1,
                pdoorno: 1,
                pstreet: 1,
                candidateid: 1,
                parea: 1,
                plandmark: 1,
                ptaluk: 1,
                ppost: 1,
                ppincode: 1,
                pcountry: 1,
                pstate: 1,
                pcity: 1,
                cdoorno: 1,
                cstreet: 1,
                carea: 1,
                role: 1,
                clandmark: 1,
                ctaluk: 1,
                cpost: 1,
                cpincode: 1,
                ccountry: 1,
                cstate: 1,
                ccity: 1,
                reasondate: 1,
                process: 1,
                workstation: 1,
                weekoff: 1,
                originalpassword: 1,
                enquirystatus: 1,
                area: 1,
                enableworkstation: 1,
                wordcheck: 1,
                shiftallot: 1,
                firstname: 1,
                lastname: 1,
                employeecount: 1,
                emergencyno: 1,
                name: 1,
                salarysetup: 1,
                mode: 1,
                salarycode: 1,
                basic: 1,
                hra: 1,
                conveyance: 1,
                medicalallowance: 1,
                productionallowance: 1,
                otherallowance: 1,
                productionallowancetwo: 1,
                pffromdate: 1,
                pfenddate: 1,
                esifromdate: 1,
                esienddate: 1,
                pfesistatus: 1,
                resonablestatus: 1,
                department: 1,
                dob: 1,
                location: 1,
                bloodgroup: 1,
                gender: 1,
                maritalstatus: 1,
                lastname: 1,
                contactpersonal: 1,
                processlog: 1,
                boardingLog: 1,
                attendancemode: 1,
                designationlog: 1,
                company: 1,
                addremoteworkmode: 1,
                reasondate: 1,
                empreason: 1,
                percentage: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                floor: 1,
                username: 1,
                usernameautogenerate: 1,
                workmode: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,

                unit: 1,
                branch: 1,
                designation: 1,
                team: 1,
                bankdetails: 1,
                shift: 1,
                reportingto: 1,
                experience: 1,
                doj: 1,
                role: 1,
                bankname: 1,
                bankdetails: 1,
                bankbranchname: 1,
                accountholdername: 1,
                accountnumber: 1,
                ifsccode: 1,
                shifttiming: 1,
                shiftgrouping: 1,
                legalname: 1,
                callingname: 1,
                pdoorno: 1,
                pstreet: 1,
                parea: 1,
                plandmark: 1,
                ptaluk: 1,
                ppost: 1,
                ppincode: 1,
                pcountry: 1,
                pstate: 1,
                pcity: 1,
                cdoorno: 1,
                cstreet: 1,
                carea: 1,
                clandmark: 1,
                ctaluk: 1,
                cpost: 1,
                cpincode: 1,
                ccountry: 1,
                cstate: 1,
                ccity: 1,
                reasondate: 1,
                process: 1,
                workstation: 1,
                weekoff: 1,
                originalpassword: 1,
                enquirystatus: 1,
                area: 1,
                enableworkstation: 1,
                wordcheck: 1,
                shiftallot: 1,
                twofaenabled: 1,
                fathername: 1,
                mothername: 1,
                firstname: 1,
                workstationinput: 1,
                emergencyno: 1,
                referencetodo: 1,
                contactno: 1,
                details: 1,
                assignExpLog: 1,
                grosssalary: 1,
                timemins: 1,
                modeexperience: 1,
                targetexperience: 1,
                targetpts: 1,
                expval: 1,
                expmode: 1,
                process: 1,
                processtype: 1,
                processduration: 1,
                duration: 1,
                workstationofficestatus: 1,
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: users.length, users });
});

exports.userscheckBranch = catchAsyncErrors(async (req, res, next) => {
    let users;

    try {
        users = await User.find(
            {},

            {
                empcode: 1,
                branch: 1,

            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: users.length, users });
});

// get All user => /api/allusers

exports.getAllTheUsers = catchAsyncErrors(async (req, res, next) => {
    let allusers;

    try {
        allusers = await User.find(
            {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
                workmode: {
                    $ne: "Internship",
                },
                resonablestatus: {
                    $nin: [
                        "Not Joined",
                        "Postponed",
                        "Rejected",
                        "Closed",
                        "Releave Employee",
                        "Absconded",
                        "Hold",
                        "Terminate",
                    ],
                },
            },
            {
                status: 1,
                empcode: 1,
                nexttime: 1,
                companyname: 1,
                addremoteworkmode: 1,
                username: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,
                approvedremotestatus: 1,
                branch: 1,
                unit: 1,
                team: 1,
                company: 1,
                shift: 1,
                experience: 1,
                doj: 1,
                dot: 1,
                workmode: 1,
                internstatus: 1,
                resonablestatus: 1,
                reasonname: 1,
                lastworkday: 1,
                rejoin: 1,
                reasonablestatusremarks: 1,
                department: 1,
                dob: 1,
                company: 1,
                reasondate: 1,
                empreason: 1,
                percentage: 1,
                doj: 1,
                dot: 1,
                role: 1,
                assignExpLog: 1,
                resonablestatus: 1,
                rejoin: 1,
                reasonablestatusremarks: 1,
                department: 1,
                dob: 1,
                gender: 1,
                maritalstatus: 1,
                bloodgroup: 1,
                location: 1,
                aadhar: 1,
                panno: 1,
                panstatus: 1,
                panrefno: 1,

                fathername: 1,
                mothername: 1,
                contactfamily: 1,
                contactno: 1,
                prefix: 1,
                assignExpMode: 1,
                assignExpvalue: 1,
                processtype: 1,
                processduration: 1,
                date: 1,
                time: 1,
                grosssalary: 1,
                timemins: 1,
                modeexperience: 1,
                targetexperience: 1,
                targetpts: 1,
                dom: 1,

                contactpersonal: 1,
                designationlog: 1,
                processlog: 1,
                boardingLog: 1,
                attendancemode: 1,
                company: 1,
                reasondate: 1,
                empreason: 1,
                percentage: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                username: 1,
                usernameautogenerate: 1,
                workmode: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,

                unit: 1,
                branch: 1,
                designation: 1,
                floor: 1,
                shift: 1,
                reportingto: 1,
                experience: 1,
                doj: 1,
                dot: 1,
                bankdetails: 1,
                shifttiming: 1,
                shiftgrouping: 1,
                shifttype: 1,
                legalname: 1,
                callingname: 1,
                pdoorno: 1,
                pstreet: 1,
                parea: 1,
                plandmark: 1,
                ptaluk: 1,
                ppost: 1,
                ppincode: 1,
                pcountry: 1,
                pstate: 1,
                pcity: 1,
                cdoorno: 1,
                cstreet: 1,
                carea: 1,
                role: 1,
                clandmark: 1,
                ctaluk: 1,
                cpost: 1,
                cpincode: 1,
                ccountry: 1,
                cstate: 1,
                ccity: 1,
                reasondate: 1,
                process: 1,
                workstation: 1,
                workstationinput: 1,
                workstationofficestatus: 1,
                weekoff: 1,
                originalpassword: 1,
                enquirystatus: 1,
                area: 1,
                enableworkstation: 1,
                wordcheck: 1,
                shiftallot: 1,
                firstname: 1,
                lastname: 1,
                employeecount: 1,
                emergencyno: 1,
                name: 1,
                salarysetup: 1,
                mode: 1,
                salarycode: 1,
                basic: 1,
                hra: 1,
                conveyance: 1,
                medicalallowance: 1,
                productionallowance: 1,
                otherallowance: 1,
                productionallowancetwo: 1,
                pffromdate: 1,
                pfenddate: 1,
                esifromdate: 1,
                esienddate: 1,
                pfesistatus: 1,
                remoteworkmodestatus: 1,
                addremoteworkmode: 1,
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!allusers) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: allusers.length, allusers });
});
exports.getAllTheLogUsers = catchAsyncErrors(async (req, res, next) => {
    let allusers;

    try {
        allusers = await User.find(
            {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
                workmode: {
                    $ne: "Internship",
                },
                resonablestatus: {
                    $nin: [
                        "Not Joined",
                        "Postponed",
                        "Rejected",
                        "Closed",
                        "Releave Employee",
                        "Absconded",
                        "Hold",
                        "Terminate",
                    ],
                },
            },
            {
                empcode: 1,
                companyname: 1,
                username: 1,
                branch: 1,
                unit: 1, team: 1, company: 1, shift: 1, doj: 1, department: 1,
                designationlog: 1, departmentlog: 1,
                processlog: 1, boardingLog: 1, attendancemode: 1, designation: 1, floor: 1,
                reportingto: 1, shifttiming: 1, shiftgrouping: 1, shifttype: 1,
                weekoff: 1,
                area: 1,
                shiftallot: 1,
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!allusers) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: allusers.length, allusers });
});


// get All user => /api/allinterns
exports.getAllIntern = catchAsyncErrors(async (req, res, next) => {
    let allinterns;

    try {
        allinterns = await User.find(
            {
                workmode: {
                    $in: "Internship",
                },
                resonablestatus: {
                    $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
            },
            {
                status: 1,
                percentage: 1,
                empcode: 1,
                nexttime: 1,
                companyname: 1,
                username: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,

                branch: 1,
                unit: 1,
                team: 1,
                company: 1,
                shift: 1,
                experience: 1,
                doj: 1,
                dot: 1,
                workmode: 1,
                internstatus: 1,
                resonablestatus: 1,
                department: 1,
                reasondate: 1,
                reportingto: 1,
                reasonname: 1,
                lastworkday: 1,
                rejoin: 1,
                reasonablestatusremarks: 1,
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!allinterns) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: allinterns.length, allinterns });
});

// get All user => /api/allinterns
exports.getAllDactiveIntern = catchAsyncErrors(async (req, res, next) => {
    let allinterns;

    try {
        allinterns = await User.find(
            {
                workmode: {
                    $in: "Internship",
                },
                resonablestatus: {
                    $in: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
            },
            {
                status: 1,
                percentage: 1,
                empcode: 1,
                nexttime: 1,
                companyname: 1,
                username: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,

                branch: 1,
                unit: 1,
                team: 1,
                company: 1,
                shift: 1,
                experience: 1,
                doj: 1,
                dot: 1,
                workmode: 1,
                internstatus: 1,
                resonablestatus: 1,
                department: 1,
                reasondate: 1,
                reportingto: 1,
                reasonname: 1,
                lastworkday: 1,
                rejoin: 1,
                reasonablestatusremarks: 1,
                originalpassword: 1,
                aadhar: 1,
                panno: 1,
                panstatus: 1,
                panrefno: 1,
                firstname: 1,
                lastname: 1,
                pdoorno: 1,
                pstreet: 1,
                parea: 1,
                plandmark: 1,
                ptaluk: 1,
                ppost: 1,
                ppincode: 1,
                pcity: 1,
                pstate: 1,
                pcountry: 1,
                dob: 1,
                contactpersonal: 1,
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!allinterns) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: allinterns.length, allinterns });
});

const getShiftForDateAttMonthStatus = (column, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, boardingLog, isWeekOff, matchingDoubleShiftItem, department, overAllDepartment, matchingRemovedItem, matchingAssignShiftItem) => {

    //if (matchingItem && matchingItem?._doc?.adjstatus === 'Adjustment') {
    // return 'Pending...'
    // }
    // else
    if (matchingDoubleShiftItem && matchingDoubleShiftItem?._doc?.adjstatus === 'Approved' && matchingDoubleShiftItem && matchingDoubleShiftItem?._doc?.adjustmenttype === 'Shift Weekoff Swap') {
        return matchingDoubleShiftItem?._doc?.todateshiftmode;
    }
    else if (matchingDoubleShiftItem && matchingDoubleShiftItem?._doc?.adjstatus === 'Approved' && matchingDoubleShiftItem && matchingDoubleShiftItem?._doc?.adjustmenttype === 'WeekOff Adjustment') {
        return matchingDoubleShiftItem?._doc?.todateshiftmode;
    }
    else if (matchingDoubleShiftItem && matchingDoubleShiftItem?._doc?.adjstatus === 'Approved' && matchingDoubleShiftItem && matchingDoubleShiftItem?._doc?.adjustmenttype === 'Shift Adjustment') {
        if (matchingAssignShiftItem && matchingDoubleShiftItem?._doc?.todate === matchingAssignShiftItem?._doc?.adjdate) {
            return `${matchingDoubleShiftItem?._doc?.adjchangeshiftime.split(' - ')[0]}to${matchingDoubleShiftItem?._doc?.adjchangeshiftime.split(' - ')[1]}`;
        } else {
            return 'Not Allotted';
        }
    }
    else if (matchingRemovedItem && matchingRemovedItem?._doc?.adjstatus === 'Not Allotted') {
        return 'Not Allotted';
    }
    else if (matchingItem && matchingItem?._doc?.adjstatus === 'Approved') {

        if (matchingItem?._doc?.adjustmenttype === "Add On Shift" || matchingItem?._doc?.adjustmenttype === 'Shift Adjustment' || matchingItem?._doc?.adjustmenttype === 'Shift Weekoff Swap') {
            if (column.shiftMode === 'Main Shift') {
                return `${matchingItem?._doc?.adjchangeshiftime.split(' - ')[0]}to${matchingItem?._doc?.adjchangeshiftime.split(' - ')[1]}`
            } else if (column.shiftMode === 'Second Shift') {
                return `${matchingItem?._doc?.pluseshift.split(' - ')[0]}to${matchingItem?._doc?.pluseshift.split(' - ')[1]}`
            }
        }
        else {
            return (isWeekOffWithAdjustment ? (`${matchingItem?._doc?.adjchangeshiftime.split(' - ')[0]}to${matchingItem?._doc?.adjchangeshiftime.split(' - ')[1]}`) : (`${matchingItem?._doc?.adjchangeshiftime.split(' - ')[0]}to${matchingItem?._doc?.adjchangeshiftime.split(' - ')[1]}`));
        }
    }
    else if (matchingItemAllot && matchingItemAllot?._doc?.status === "Manual") {
        return isWeekOffWithManual ? (`${matchingItemAllot._doc?.firstshift.split(' - ')[0]}to${matchingItemAllot?._doc?.firstshift.split(' - ')[1]} `) :
            (`${matchingItemAllot?._doc?.firstshift.split(' - ')[0]}to${matchingItemAllot?._doc?.firstshift.split(' - ')[1]} `);
    }
    else if (matchingItemAllot && matchingItemAllot?._doc?.status === "Week Off") {
        return 'Week Off';
    }
    else if (matchingItem && matchingItem?._doc?.adjstatus === 'Reject' && isWeekOff) {
        // If the adjustment status is 'Reject' and it's a week off, return 'Week Off'
        return 'Week Off';
    }
    // else if (boardingLog?.length > 0) {
    //     if (!recentShiftTimingDate) {
    //         return ""
    //     }
    //     // const [year, month, day] = recentShiftTimingDate?.split('-');
    //     // // Map through each column and compare dates
    //     // const shifts = tempResultDates?.map((currentColumn) => {
    //     //     const [day1, month1, year1] = currentColumn.formattedDate?.split('-');
    //     //     if (year >= year1 && month >= month1 && day >= day1) {
    //     //         return isWeekOffWithAdjustment ? actualShiftTiming : (!isWeekOff ? actualShiftTiming : "Week Off");
    //     //     }
    //     //     else {
    //     //         return isWeekOffWithAdjustment ? recentShiftTiming : (!isWeekOff ? recentShiftTiming : "Week Off");
    //     //     }
    //     // });
    //     const shifts = tempResultDates?.map((currentColumn) => {
    //         if (!recentShiftTimingDate) {
    //             return ""
    //         }
    //         const [columnDay, columnMonth, columnYear] = currentColumn.formattedDate?.split('/');
    //         const columnFormattedDate = new Date(`${columnMonth}/${columnDay}/${columnYear}`) + 1;
    //         const [shiftYear, shiftMonth, shiftDay] = recentShiftTimingDate?.split('-');
    //         const shiftFormattedDate = new Date(`${shiftMonth}/${shiftDay}/${shiftYear}`) + 1;

    //         if (shiftFormattedDate >= columnFormattedDate) {
    //             return isWeekOffWithAdjustment ? actualShiftTiming : (!isWeekOff ? actualShiftTiming : "Week Off");
    //         } else {
    //             return isWeekOffWithAdjustment ? recentShiftTiming : (!isWeekOff ? recentShiftTiming : "Week Off");
    //         }
    //     });

    //     // Return the shift value for the current column
    //     return shifts[dayCount - 1];

    // }
    // else if (boardingLog?.length > 0) {
    //     const [columnDay, columnMonth, columnYear] = column.formattedDate?.split('/');
    //     const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

    //     // Filter boardingLog entries for the same start date
    //     const entriesForDate = boardingLog.filter(log => log.startdate === finalDate);

    //     // If there are entries for the date, return the shift timing of the second entry
    //     if (entriesForDate.length > 1) {
    //         return entriesForDate[1].shifttiming;
    //     }

    //     // Find the most recent boarding log entry that is less than or equal to the selected date
    //     const recentLogEntry = boardingLog
    //         .filter(log => log.startdate <= finalDate)
    //         .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

    //     // If a recent log entry is found, return its shift timing
    //     if (recentLogEntry) {
    //         return !isWeekOff ? recentLogEntry.shifttiming : "Week Off";
    //     } else {
    //         // If no relevant boarding log entry is found, return the previous shift timing or 'Week Off' if it's a week off
    //         return !isWeekOff ? actualShiftTiming : "Week Off";
    //     }
    // }
    else if (boardingLog.length > 0) {

        // Remove duplicate entries with recent entry
        const uniqueEntries = {};
        boardingLog.forEach(entry => {
            const key = entry.startdate;
            if (!(key in uniqueEntries) || uniqueEntries[key].time <= entry.time) {
                uniqueEntries[key] = entry;
            }
        });
        const uniqueBoardingLog = Object.values(uniqueEntries);

        const [columnDay, columnMonth, columnYear] = column.formattedDate?.split('/');
        const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

        // Find the relevant log entry for the given date     
        const relevantLogEntry = uniqueBoardingLog
            .filter(log => log.startdate <= finalDate)
            .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

        const logWeekOff = relevantLogEntry && relevantLogEntry.weekoff.includes(column.dayName);

        if (relevantLogEntry) {

            // Daily
            if (relevantLogEntry.shifttype === 'Standard' || relevantLogEntry.shifttype === undefined) {
                // If shift type is 'Daily', return the same shift timing for each day
                //    return !isWeekOff ? relevantLogEntry.shifttiming : 'Week Off';
                return !logWeekOff ? relevantLogEntry.shifttiming : 'Week Off';
            }

            // 1 Week Rotation 2nd try working code
            if (relevantLogEntry.shifttype === 'Daily') {
                for (const data of relevantLogEntry.todo) {
                    const columnWeek = (column.weekNumberInMonth === '2nd Week' ? '1st Week' : column.weekNumberInMonth === '3rd Week' ? '1st Week' : column.weekNumberInMonth === '4th Week' ? '1st Week' : column.weekNumberInMonth === '5th Week' ? '1st Week' : '1st Week');
                    if (data.week === columnWeek && data.day === column.dayName) {
                        return data.shiftmode === 'Shift' ? data.shifttiming : 'Week Off';
                    }
                }
            }

            // 2 Week Rotation 2nd try working code  
            if (relevantLogEntry.shifttype === '1 Week Rotation') {
                const startDate = new Date(relevantLogEntry.startdate); // Get the start date

                // Get the day name of the start date
                const startDayName = startDate.toLocaleDateString('en-US', { weekday: 'long' });

                // Calculate the day count until the next Sunday
                let dayCount = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'].indexOf(startDayName);

                // Calculate the week number based on the day count
                let weekNumber = Math.ceil((7 - dayCount) / 7);

                // Adjust the week number considering the two-week rotation
                const logStartDate = new Date(relevantLogEntry.startdate);
                const currentDate = new Date(finalDate);

                const diffTime = Math.abs(currentDate - logStartDate);
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

                weekNumber += Math.floor((diffDays - (7 - dayCount)) / 7); // Adjust for complete 2-week cycles passed

                // Determine the final week based on the calculated week number                    
                const finalWeek = (weekNumber % 2 === 0) ? '1st Week' : '2nd Week';

                for (const data of relevantLogEntry.todo) {
                    // Check if the adjusted week matches the column week and day
                    if (data.week === finalWeek && data.day === column.dayName) {
                        return data.shiftmode === 'Shift' ? data.shifttiming : 'Week Off';
                    }
                }
            }

            //just 2wk rotation
            if (relevantLogEntry.shifttype === '2 Week Rotation') {

                const matchingDepartment = overAllDepartment.find(
                    (dep) =>
                        dep.department === department &&
                        new Date(dep.fromdate) <= new Date(relevantLogEntry.startdate) &&
                        new Date(relevantLogEntry.startdate) <= new Date(dep.todate)
                );

                // Use the fromdate of the matching department as the startDate
                let startDate = matchingDepartment
                    ? new Date(matchingDepartment.fromdate)
                    : new Date(relevantLogEntry.startdate);

                // Calculate month lengths
                const monthLengths = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

                // Function to determine if a year is a leap year
                const isLeapYear = (year) => {
                    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
                };

                const currentDate = new Date(finalDate);

                // Determine the effective month for the start date
                let effectiveMonth = startDate.getMonth();
                if (startDate.getDate() > 15) {
                    // Consider the next month if the start date is after the 15th
                    effectiveMonth = (effectiveMonth + 1) % 12;
                }

                // Calculate total days for 1-month rotation based on the effective month
                let totalDays = monthLengths[effectiveMonth];

                // Set the initial endDate by adding totalDays to the startDate
                let endDate = new Date(startDate);
                endDate.setDate(endDate.getDate() + totalDays - 1); // Subtract 1 to account for zero-indexing

                // Adjust February for leap years
                if (isLeapYear(endDate.getFullYear())) {
                    monthLengths[1] = 29;
                }

                // Adjust startDate and endDate if the currentDate is beyond the initial endDate
                while (currentDate > endDate) {
                    // Set startDate to the next matchingDepartment.fromdate for each cycle
                    startDate = new Date(endDate);
                    startDate.setDate(startDate.getDate() + 1); // Move to the next day

                    // Determine the new effective month for the next cycle
                    effectiveMonth = startDate.getMonth();
                    if (startDate.getDate() > 15) {
                        effectiveMonth = (effectiveMonth + 1) % 12;
                    }

                    totalDays = monthLengths[effectiveMonth];

                    // Set the new endDate by adding totalDays to the new startDate
                    endDate = new Date(startDate);
                    endDate.setDate(endDate.getDate() + totalDays - 1); // Include entire period

                    // Adjust February for leap years
                    if (isLeapYear(endDate.getFullYear())) {
                        monthLengths[1] = 29;
                    }
                }

                // Calculate the difference in days correctly
                const diffTime = Math.abs(currentDate.getTime() - startDate.getTime());
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1; // Add 1 to include start date

                // Determine the start day of the first week
                let startDayOfWeek = startDate.getDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday

                // Adjust the start day so that Monday is considered the start of the week
                let startDayOffset = startDayOfWeek === 0 ? 6 : startDayOfWeek - 1;

                // Calculate the week number based on Monday to Sunday cycle
                let adjustedDiffDays = diffDays + startDayOffset; // Adjust diffDays to account for start day                                      

                // Calculate the week number within the rotation month based on 7-day intervals from start date
                // const weekNumber = Math.ceil(diffDays / 7);
                let weekNumber = Math.floor((adjustedDiffDays - 1) / 7) + 1; // Divide by 7 to get the week count

                const weekNames = [
                    "1st Week",
                    "2nd Week",
                    "3rd Week",
                    "4th Week",
                    "5th Week",
                    "6th Week",
                    "7th Week",
                    "8th Week",
                    "9th Week",
                ];
                const finalWeek = weekNames[(weekNumber - 1) % weekNames.length];
                for (const data of relevantLogEntry.todo) {
                    if (data.week === finalWeek && data.day === column.dayName) {
                        return data.shiftmode === "Shift" ? data.shifttiming : "Week Off";
                    }
                }
            }

            //just 1mont rota updated            
            if (relevantLogEntry.shifttype === '1 Month Rotation') {

                const matchingDepartment = overAllDepartment.find(
                    (dep) =>
                        dep.department === department &&
                        new Date(dep.fromdate) <= new Date(relevantLogEntry.startdate) &&
                        new Date(relevantLogEntry.startdate) <= new Date(dep.todate)
                );

                // Use the fromdate of the matching department as the startDate
                let startDate = matchingDepartment
                    ? new Date(matchingDepartment.fromdate)
                    : new Date(relevantLogEntry.startdate);

                const currentDate = new Date(finalDate);

                // Function to determine if a year is a leap year
                const isLeapYear = (year) => {
                    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
                };

                // Calculate month lengths with leap year check for a given year
                const calculateMonthLengths = (year) => {
                    return [31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
                };

                // Determine the effective month and year for the start date
                let effectiveMonth = startDate.getMonth();
                let effectiveYear = startDate.getFullYear();
                if (startDate.getDate() > 15) {
                    // Consider the next month if the start date is after the 15th
                    effectiveMonth = (effectiveMonth + 1) % 12;
                    if (effectiveMonth === 0) {
                        effectiveYear += 1; // Move to the next year if month resets
                    }
                }

                // Calculate total days for the current two-month cycle
                let totalDays = 0;
                for (let i = 0; i < 2; i++) {
                    const monthIndex = (effectiveMonth + i) % 12;
                    const yearAdjustment = Math.floor((effectiveMonth + i) / 12);
                    const currentYear = effectiveYear + yearAdjustment;
                    const monthLengthsForYear = calculateMonthLengths(currentYear);
                    totalDays += monthLengthsForYear[monthIndex];
                }

                // Set the endDate by adding totalDays to the startDate
                let endDate = new Date(startDate);
                endDate.setDate(endDate.getDate() + totalDays - 1); // Include entire period

                // Recalculate if currentDate is beyond the initial endDate
                while (currentDate > endDate) {
                    startDate = new Date(endDate);
                    startDate.setDate(startDate.getDate() + 1); // Move to the next day

                    // Determine the new effective month and year for the next cycle
                    effectiveMonth = startDate.getMonth();
                    effectiveYear = startDate.getFullYear();
                    if (startDate.getDate() > 15) {
                        effectiveMonth = (effectiveMonth + 1) % 12;
                        if (effectiveMonth === 0) {
                            effectiveYear += 1;
                        }
                    }

                    totalDays = 0;
                    for (let i = 0; i < 2; i++) {
                        const monthIndex = (effectiveMonth + i) % 12;
                        const yearAdjustment = Math.floor((effectiveMonth + i) / 12);
                        const currentYear = effectiveYear + yearAdjustment;
                        const monthLengthsForYear = calculateMonthLengths(currentYear);
                        totalDays += monthLengthsForYear[monthIndex];
                    }

                    // Set the new endDate by adding totalDays to the new startDate
                    endDate = new Date(startDate);
                    endDate.setDate(endDate.getDate() + totalDays - 1); // Include entire period
                }
                // Calculate the difference in days including the start date
                const diffTime = Math.abs(currentDate.getTime() - startDate.getTime());
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1; // Add 1 to include the start date

                // Determine the start day of the first week
                let startDayOfWeek = startDate.getDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday

                // Adjust the start day so that Monday is considered the start of the week
                let startDayOffset = startDayOfWeek === 0 ? 6 : startDayOfWeek - 1;

                // Calculate the week number based on Monday to Sunday cycle
                let adjustedDiffDays = diffDays - 1 + startDayOffset; // Adjust diffDays to account for start day
                let weekNumber = Math.floor(adjustedDiffDays / 7) + 1; // Divide by 7 to get the week count

                // Define week names for first and second month of the cycle
                const weekNamesFirstMonth = [
                    "1st Week",
                    "2nd Week",
                    "3rd Week",
                    "4th Week",
                    "5th Week",
                    "6th Week"
                ];

                const weekNamesSecondMonth = [
                    "7th Week",
                    "8th Week",
                    "9th Week",
                    "10th Week",
                    "11th Week",
                    "12th Week"
                ];

                // Determine which month we are in
                const daysInFirstMonth = calculateMonthLengths(startDate.getFullYear())[effectiveMonth];
                let finalWeek;

                if (diffDays <= daysInFirstMonth) {
                    // We're in the first month of the cycle
                    weekNumber = (weekNumber - 1) % weekNamesFirstMonth.length + 1;
                    finalWeek = weekNamesFirstMonth[weekNumber - 1];
                } else {
                    // We're in the second month of the cycle
                    const secondMonthDay = diffDays - daysInFirstMonth;

                    // Calculate week number based on Monday-Sunday for the second month
                    const secondMonthStartDayOffset = new Date(startDate.getTime() + daysInFirstMonth * 24 * 60 * 60 * 1000).getDay();
                    const secondMonthStartOffset = secondMonthStartDayOffset === 0 ? 6 : secondMonthStartDayOffset - 1;
                    const secondMonthAdjustedDays = secondMonthDay - 1 + secondMonthStartOffset;
                    const secondMonthWeekNumber = Math.floor(secondMonthAdjustedDays / 7) + 1;

                    finalWeek = weekNamesSecondMonth[secondMonthWeekNumber - 1];
                }
                for (const data of relevantLogEntry.todo) {
                    if (data.week === finalWeek && data.day === column.dayName) {
                        return data.shiftmode === "Shift" ? data.shifttiming : "Week Off";
                    }
                }
            }
        }
    }
};

const getWeekOffDay = (column, boardingLog, department, overAllDepartment) => {
    if (boardingLog.length > 0) {

        // Remove duplicate entries with recent entry
        const uniqueEntries = {};
        boardingLog.forEach(entry => {
            const key = entry.startdate;
            if (!(key in uniqueEntries) || uniqueEntries[key].time <= entry.time) {
                uniqueEntries[key] = entry;
            }
        });
        const uniqueBoardingLog = Object.values(uniqueEntries);

        const [columnDay, columnMonth, columnYear] = column.formattedDate?.split('/');
        const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

        // Find the relevant log entry for the given date     
        const relevantLogEntry = uniqueBoardingLog
            .filter(log => log.startdate <= finalDate)
            .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

        const logWeekOff = relevantLogEntry && relevantLogEntry.weekoff.includes(column.dayName)

        if (relevantLogEntry) {

            // Daily
            if (relevantLogEntry.shifttype === 'Standard' || relevantLogEntry.shifttype === undefined) {
                // If shift type is 'Daily', return the same shift timing for each day
                //    return !isWeekOff ? relevantLogEntry.shifttiming : 'Week Off';
                return !logWeekOff ? relevantLogEntry.shifttiming : 'Week Off';
            }

            // 1 Week Rotation 2nd try working code
            if (relevantLogEntry.shifttype === 'Daily') {
                for (const data of relevantLogEntry.todo) {
                    const columnWeek = (column.weekNumberInMonth === '2nd Week' ? '1st Week' : column.weekNumberInMonth === '3rd Week' ? '1st Week' : column.weekNumberInMonth === '4th Week' ? '1st Week' : column.weekNumberInMonth === '5th Week' ? '1st Week' : '1st Week');
                    if (data.week === columnWeek && data.day === column.dayName) {
                        return data.shiftmode === 'Shift' ? data.shifttiming : 'Week Off';
                    }
                }
            }

            // 2 Week Rotation 2nd try working code  
            if (relevantLogEntry.shifttype === '1 Week Rotation') {
                const startDate = new Date(relevantLogEntry.startdate); // Get the start date

                // Get the day name of the start date
                const startDayName = startDate.toLocaleDateString('en-US', { weekday: 'long' });

                // Calculate the day count until the next Sunday
                let dayCount = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'].indexOf(startDayName);

                // Calculate the week number based on the day count
                let weekNumber = Math.ceil((7 - dayCount) / 7);

                // Adjust the week number considering the two-week rotation
                const logStartDate = new Date(relevantLogEntry.startdate);
                const currentDate = new Date(finalDate);

                const diffTime = Math.abs(currentDate - logStartDate);
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

                weekNumber += Math.floor((diffDays - (7 - dayCount)) / 7); // Adjust for complete 2-week cycles passed

                // Determine the final week based on the calculated week number                    
                const finalWeek = (weekNumber % 2 === 0) ? '1st Week' : '2nd Week';

                for (const data of relevantLogEntry.todo) {
                    // Check if the adjusted week matches the column week and day
                    if (data.week === finalWeek && data.day === column.dayName) {
                        return data.shiftmode === 'Shift' ? data.shifttiming : 'Week Off';
                    }
                }
            }

            //just 2wk rotation
            if (relevantLogEntry.shifttype === '2 Week Rotation') {

                const matchingDepartment = overAllDepartment.find(
                    (dep) =>
                        dep.department === department &&
                        new Date(dep.fromdate) <= new Date(relevantLogEntry.startdate) &&
                        new Date(relevantLogEntry.startdate) <= new Date(dep.todate)
                );

                // Use the fromdate of the matching department as the startDate
                let startDate = matchingDepartment
                    ? new Date(matchingDepartment.fromdate)
                    : new Date(relevantLogEntry.startdate);

                // Calculate month lengths
                const monthLengths = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

                // Function to determine if a year is a leap year
                const isLeapYear = (year) => {
                    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
                };

                const currentDate = new Date(finalDate);

                // Determine the effective month for the start date
                let effectiveMonth = startDate.getMonth();
                if (startDate.getDate() > 15) {
                    // Consider the next month if the start date is after the 15th
                    effectiveMonth = (effectiveMonth + 1) % 12;
                }

                // Calculate total days for 1-month rotation based on the effective month
                let totalDays = monthLengths[effectiveMonth];

                // Set the initial endDate by adding totalDays to the startDate
                let endDate = new Date(startDate);
                endDate.setDate(endDate.getDate() + totalDays - 1); // Subtract 1 to account for zero-indexing

                // Adjust February for leap years
                if (isLeapYear(endDate.getFullYear())) {
                    monthLengths[1] = 29;
                }

                // Adjust startDate and endDate if the currentDate is beyond the initial endDate
                while (currentDate > endDate) {
                    // Set startDate to the next matchingDepartment.fromdate for each cycle
                    startDate = new Date(endDate);
                    startDate.setDate(startDate.getDate() + 1); // Move to the next day

                    // Determine the new effective month for the next cycle
                    effectiveMonth = startDate.getMonth();
                    if (startDate.getDate() > 15) {
                        effectiveMonth = (effectiveMonth + 1) % 12;
                    }

                    totalDays = monthLengths[effectiveMonth];

                    // Set the new endDate by adding totalDays to the new startDate
                    endDate = new Date(startDate);
                    endDate.setDate(endDate.getDate() + totalDays - 1); // Include entire period

                    // Adjust February for leap years
                    if (isLeapYear(endDate.getFullYear())) {
                        monthLengths[1] = 29;
                    }
                }

                // Calculate the difference in days correctly
                const diffTime = Math.abs(currentDate.getTime() - startDate.getTime());
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1; // Add 1 to include start date

                // Determine the start day of the first week
                let startDayOfWeek = startDate.getDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday

                // Adjust the start day so that Monday is considered the start of the week
                let startDayOffset = startDayOfWeek === 0 ? 6 : startDayOfWeek - 1;

                // Calculate the week number based on Monday to Sunday cycle
                let adjustedDiffDays = diffDays + startDayOffset; // Adjust diffDays to account for start day                                      

                // Calculate the week number within the rotation month based on 7-day intervals from start date
                // const weekNumber = Math.ceil(diffDays / 7);
                let weekNumber = Math.floor((adjustedDiffDays - 1) / 7) + 1; // Divide by 7 to get the week count

                const weekNames = [
                    "1st Week",
                    "2nd Week",
                    "3rd Week",
                    "4th Week",
                    "5th Week",
                    "6th Week",
                    "7th Week",
                    "8th Week",
                    "9th Week",
                ];
                const finalWeek = weekNames[(weekNumber - 1) % weekNames.length];
                for (const data of relevantLogEntry.todo) {
                    if (data.week === finalWeek && data.day === column.dayName) {
                        return data.shiftmode === "Shift" ? data.shifttiming : "Week Off";
                    }
                }
            }

            //just 1mont rota updated            
            if (relevantLogEntry.shifttype === '1 Month Rotation') {

                const matchingDepartment = overAllDepartment.find(
                    (dep) =>
                        dep.department === department &&
                        new Date(dep.fromdate) <= new Date(relevantLogEntry.startdate) &&
                        new Date(relevantLogEntry.startdate) <= new Date(dep.todate)
                );

                // Use the fromdate of the matching department as the startDate
                let startDate = matchingDepartment
                    ? new Date(matchingDepartment.fromdate)
                    : new Date(relevantLogEntry.startdate);

                const currentDate = new Date(finalDate);

                // Function to determine if a year is a leap year
                const isLeapYear = (year) => {
                    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
                };

                // Calculate month lengths with leap year check for a given year
                const calculateMonthLengths = (year) => {
                    return [31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
                };

                // Determine the effective month and year for the start date
                let effectiveMonth = startDate.getMonth();
                let effectiveYear = startDate.getFullYear();
                if (startDate.getDate() > 15) {
                    // Consider the next month if the start date is after the 15th
                    effectiveMonth = (effectiveMonth + 1) % 12;
                    if (effectiveMonth === 0) {
                        effectiveYear += 1; // Move to the next year if month resets
                    }
                }

                // Calculate total days for the current two-month cycle
                let totalDays = 0;
                for (let i = 0; i < 2; i++) {
                    const monthIndex = (effectiveMonth + i) % 12;
                    const yearAdjustment = Math.floor((effectiveMonth + i) / 12);
                    const currentYear = effectiveYear + yearAdjustment;
                    const monthLengthsForYear = calculateMonthLengths(currentYear);
                    totalDays += monthLengthsForYear[monthIndex];
                }

                // Set the endDate by adding totalDays to the startDate
                let endDate = new Date(startDate);
                endDate.setDate(endDate.getDate() + totalDays - 1); // Include entire period

                // Recalculate if currentDate is beyond the initial endDate
                while (currentDate > endDate) {
                    startDate = new Date(endDate);
                    startDate.setDate(startDate.getDate() + 1); // Move to the next day

                    // Determine the new effective month and year for the next cycle
                    effectiveMonth = startDate.getMonth();
                    effectiveYear = startDate.getFullYear();
                    if (startDate.getDate() > 15) {
                        effectiveMonth = (effectiveMonth + 1) % 12;
                        if (effectiveMonth === 0) {
                            effectiveYear += 1;
                        }
                    }

                    totalDays = 0;
                    for (let i = 0; i < 2; i++) {
                        const monthIndex = (effectiveMonth + i) % 12;
                        const yearAdjustment = Math.floor((effectiveMonth + i) / 12);
                        const currentYear = effectiveYear + yearAdjustment;
                        const monthLengthsForYear = calculateMonthLengths(currentYear);
                        totalDays += monthLengthsForYear[monthIndex];
                    }

                    // Set the new endDate by adding totalDays to the new startDate
                    endDate = new Date(startDate);
                    endDate.setDate(endDate.getDate() + totalDays - 1); // Include entire period
                }
                // Calculate the difference in days including the start date
                const diffTime = Math.abs(currentDate.getTime() - startDate.getTime());
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1; // Add 1 to include the start date

                // Determine the start day of the first week
                let startDayOfWeek = startDate.getDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday

                // Adjust the start day so that Monday is considered the start of the week
                let startDayOffset = startDayOfWeek === 0 ? 6 : startDayOfWeek - 1;

                // Calculate the week number based on Monday to Sunday cycle
                let adjustedDiffDays = diffDays - 1 + startDayOffset; // Adjust diffDays to account for start day
                let weekNumber = Math.floor(adjustedDiffDays / 7) + 1; // Divide by 7 to get the week count

                // Define week names for first and second month of the cycle
                const weekNamesFirstMonth = [
                    "1st Week",
                    "2nd Week",
                    "3rd Week",
                    "4th Week",
                    "5th Week",
                    "6th Week"
                ];

                const weekNamesSecondMonth = [
                    "7th Week",
                    "8th Week",
                    "9th Week",
                    "10th Week",
                    "11th Week",
                    "12th Week"
                ];

                // Determine which month we are in
                const daysInFirstMonth = calculateMonthLengths(startDate.getFullYear())[effectiveMonth];
                let finalWeek;

                if (diffDays <= daysInFirstMonth) {
                    // We're in the first month of the cycle
                    weekNumber = (weekNumber - 1) % weekNamesFirstMonth.length + 1;
                    finalWeek = weekNamesFirstMonth[weekNumber - 1];
                } else {
                    // We're in the second month of the cycle
                    const secondMonthDay = diffDays - daysInFirstMonth;

                    // Calculate week number based on Monday-Sunday for the second month
                    const secondMonthStartDayOffset = new Date(startDate.getTime() + daysInFirstMonth * 24 * 60 * 60 * 1000).getDay();
                    const secondMonthStartOffset = secondMonthStartDayOffset === 0 ? 6 : secondMonthStartDayOffset - 1;
                    const secondMonthAdjustedDays = secondMonthDay - 1 + secondMonthStartOffset;
                    const secondMonthWeekNumber = Math.floor(secondMonthAdjustedDays / 7) + 1;

                    finalWeek = weekNamesSecondMonth[secondMonthWeekNumber - 1];
                }

                for (const data of relevantLogEntry.todo) {
                    if (data.week === finalWeek && data.day === column.dayName) {
                        return data.shiftmode === "Shift" ? data.shifttiming : "Week Off";
                    }
                }
            }
        }
    }
}

// get total days of current month
const getTotalMonthDays = (rowdepartment, depMonthSet, ismonth, isyear) => {
    const monthNames = ["January", "February", "March", "April", "May", "June",
        "July", "August", "September", "October", "November", "December"
    ];
    const totalDaysInMonth = new Date(isyear, ismonth, 0).getDate();
    // const depdays = depMonthSet && depMonthSet?.find((d) => d.department === rowdepartment && Number(d.month) === ismonth && Number(d.year) === isyear);
    const depdays = depMonthSet && depMonthSet?.find((d) => d.department === rowdepartment && d.monthname === monthNames[ismonth - 1] && Number(d.year) === isyear);
    if (depdays) {
        return depdays.totaldays;
    }
    return totalDaysInMonth;
};

// get total week off count
const getTotalWeekOff = (rowempcode, usershift) => {
    let totalWeekOffDaysCount = 0;
    const totalWeekOffDays = usershift && usershift?.filter((d) => d.empCode === rowempcode && d.shiftlabel === "Week Off");
    if (totalWeekOffDays) {
        totalWeekOffDays.forEach((wkoff) => {
            totalWeekOffDaysCount++;
        });
    }
    return totalWeekOffDaysCount;
};

// get total holidays count based on the matched branch
const getTotalHolidays = (rowcompany, rowbranch, rowunit, rowteam, rowcompanyname, tempResultDates, holidays) => {
    let totalHolidayCount = 0;
    const totalHoliDays = holidays?.filter((d) =>
        d.company?.includes(rowcompany) &&
        d.applicablefor?.includes(rowbranch) &&
        d.unit?.includes(rowunit) &&
        d.team?.includes(rowteam) &&
        d.employee?.includes(rowcompanyname)
    );
    if (totalHoliDays) {
        tempResultDates && tempResultDates?.forEach((date) => {
            totalHoliDays.forEach((holi) => {
                if (formatDateLeaveDate(holi.date) === date.formattedDate) {
                    totalHolidayCount += Number(holi.noofdays);
                }
            });
        });
    }
    return totalHolidayCount;
};


//payrun master
exports.getAllUserAttMonthCountFilterPayRunMaster = catchAsyncErrors(async (req, res, next) => {
    let resultshiftallot = [];
    let finaluserattmonth = [];
    const { ismonth, isyear, } = req.body;

    try {
        const [users, depMonthSet, holidays] = await Promise.all([
            User.find(
                {

                    resonablestatus: {
                        $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                    },
                }, {
                company: 1,
                branch: 1,
                unit: 1,
                team: 1,
                department: 1,
                doj: 1,
                dot: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                floor: 1,
                username: 1,
                designation: 1,
                weekoff: 1,
                shiftallot: 1,
                shifttiming: 1,
                boardingLog: 1, attendancemode: 1,
                departmentlog: 1,
            }
            ),
            DepartmentMonth.find({}, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 }),
            Holiday.find({}, { date: 1, company: 1, applicablefor: 1, unit: 1, team: 1, employee: 1, noofdays: 1 })
        ])
        const userCds = users.map(user => user.companyname);
        const userIds = users.map(user => user._id);
        const [allLeaveStatus, allAttandanceList] = await Promise.all([
            ApplyLeave.find({ employeename: { $in: userCds } }),
            Attendance.find({ userid: { $in: userIds } })
        ])
        const monthNames = ["January", "February", "March", "April", "May", "June",
            "July", "August", "September", "October", "November", "December"
        ];

        finaluserattmonth = users?.map((item, index) => {
            let tempResultDates = [];

            item.shiftallot && item.shiftallot?.map(allot => {
                resultshiftallot.push({ ...allot })
            })

            // Define an array to store the resulting dates
            // const comparedDate = depMonthSet?.filter((d) => d.department === item.department && Number(d.year) === isyear && Number(d.month) === ismonth);

            // Remove duplicate entries with the most recent entry
            const uniqueEntriesDep = {};
            item.departmentlog?.forEach(entry => {
                const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                const key = entry.startdate;
                if (!(key in uniqueEntriesDep)) {
                    uniqueEntriesDep[key] = entry;
                }
            });
            const foundDepartment = depMonthSet?.find((d) => Number(d.year) === isyear && d.monthname === monthNames[ismonth - 1]);
            const uniqueDepLog = Object.values(uniqueEntriesDep);
            const relevantDepLogEntry = uniqueDepLog
                .filter(log => new Date(log.startdate) <= new Date(foundDepartment && foundDepartment.fromdate))
                .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

            const comparedDate = depMonthSet?.filter((d) => d.department === (relevantDepLogEntry && relevantDepLogEntry.department) && Number(d.year) === isyear && d.monthname === monthNames[ismonth - 1]);
            const dojDate = item?._doc?.boardingLog.length > 0 ?
                item?._doc?.boardingLog[0].startdate
                : item?._doc?.doj;

            if (comparedDate && comparedDate.length > 0) {
                comparedDate?.forEach((dep) => {
                    if (!dep.fromdate && !dep.todate) {
                        return '';
                    }

                    if (!item?._doc?.doj) {
                        return "";
                    }

                    const [year2, month2, day2] = dojDate?.split('-').map(Number);
                    const joiningDate = new Date(year2, month2 - 1, day2);
                    const [year1, month1, day1] = dep.fromdate?.split('-').map(Number);
                    const [year, month, day] = dep.todate?.split('-').map(Number);
                    const lastDate = new Date(year, month - 1, day);
                    const firstDate = new Date(year1, month1 - 1, day1);

                    if (joiningDate < firstDate) {
                        // Check if the shift date is before or equal to the current date
                        if (lastDate >= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(firstDate);
                            // Loop through the dates in the range
                            while (startDate <= currentDateAttStatus) {
                                tempResultDates.push({
                                    formattedDate: format(startDate, 'dd-MM-yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        } else if (lastDate <= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(firstDate);
                            // Loop through the dates in the range
                            while (startDate <= lastDate) {
                                tempResultDates.push({
                                    formattedDate: format(startDate, 'dd-MM-yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        }
                    } else {
                        // Check if the shift date is before or equal to the current date
                        if (lastDate >= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(joiningDate);
                            // Loop through the dates in the range
                            while (startDate <= currentDateAttStatus) {
                                tempResultDates.push({
                                    formattedDate: format(startDate, 'dd-MM-yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        }
                        else if (lastDate <= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(joiningDate);
                            // Loop through the dates in the range
                            while (startDate <= lastDate) {
                                tempResultDates.push({
                                    formattedDate: format(startDate, 'dd-MM-yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        }
                    }
                });
            }
            else {
                const [year2, month2, day2] = dojDate?.split('-').map(Number);
                const joiningDate = new Date(year2, month2 - 1, day2);
                // Calculate the start date of the month based on the selected month
                const startDate = new Date(isyear, ismonth - 1, 1);

                const endDate = new Date(startDate);
                endDate.setMonth(endDate.getMonth() + 1);
                endDate.setDate(endDate.getDate() - 1);

                if (joiningDate < startDate) {
                    // Check if the shift date is before or equal to the current date
                    if (endDate >= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            tempResultDates.push({
                                formattedDate: format(currentDate1, 'dd-MM-yyyy'),
                                dayName: format(currentDate1, 'EEEE'),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    } else if (endDate <= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            tempResultDates.push({
                                formattedDate: format(currentDate1, 'dd-MM-yyyy'),
                                dayName: format(currentDate1, 'EEEE'),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    }
                } else {
                    // Check if the shift date is before or equal to the current date
                    if (endDate >= currentDateAttStatus) {
                        // If matched, push the range from 'fromdate' to 'todate'
                        const startDate = new Date(joiningDate);
                        // Loop through the dates in the range
                        while (startDate <= currentDateAttStatus) {
                            tempResultDates.push({
                                formattedDate: format(startDate, 'dd-MM-yyyy'),
                                dayName: format(startDate, 'EEEE'),
                                dayCount: startDate.getDate(),
                            });
                            startDate.setDate(startDate.getDate() + 1);
                        }
                    } else if (endDate <= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            tempResultDates.push({
                                formattedDate: format(currentDate1, 'dd-MM-yyyy'),
                                dayName: format(currentDate1, 'EEEE'),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    }
                }
            }

            item.shiftallot?.map(allot => {
                resultshiftallot.push({ ...allot })
            })

            const dayshift = tempResultDates?.map((column, index) => {
                let filteredRowData = resultshiftallot?.filter((val) => val.empcode === item?._doc?.empcode);
                const matchingItem = filteredRowData?.find(item => item && formatAdjDate(item.adjdate) === column.formattedDate);
                const matchingItemAllot = filteredRowData?.find(item => item && formatDateForShiftDate(item.date) === column.formattedDate);
                const matchingDoubleShiftItem = filteredRowData?.find(item => item && item?._doc?.todate === date.formattedDate);
                const matchingRemovedItem = filteredRowData?.find(item => item?._doc?.removedshiftdate === date.formattedDate);
                const matchingAssignShiftItem = filteredRowData?.find(item => item?._doc?.adjdate === date.formattedDate && item?._doc?.adjstatus === 'Approved' && item?._doc?.adjustmenttype === 'Assign Shift');

                const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                    // return item;
                });

                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item?._doc?.weekoff?.includes(column.dayName);
                const isWeekOff = getWeekOffDay(column, filterBoardingLog, item?._doc?.departmentlog, depMonthSet) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                return {
                    userid: item?._doc?._id.toString(),
                    date: column?.formattedDate,
                    empCode: item?._doc?.empcode,
                    shiftlabel: getShiftForDateAttMonthStatus(column, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                }
            })

            const userData = {
                // _id: item?._doc?._id.toString(),
                // userid: item?._doc?._id.toString(),
                company: item?._doc?.company,
                branch: item?._doc?.branch,
                unit: item?._doc?.unit,
                team: item?._doc?.team,
                doj: dojDate,
                department: relevantDepLogEntry && relevantDepLogEntry.department,
                username: item?._doc?.companyname,
                empcode: item?._doc?.empcode,

                totalnumberofdays: getTotalMonthDays(item?._doc?.department, depMonthSet, ismonth, isyear),
                // empshiftdays: getTotalMonthDaysForEmp(dojDate, item?._doc?.department, depMonthSet, ismonth, isyear),
                // totalcounttillcurrendate: getTotalMonthsCurrentDateCount(dojDate, item?._doc?.department, depMonthSet, ismonth, isyear),
                totalshift: getTotalShiftHours(item?._doc?._id.toString(), tempResultDates, allAttandanceList,
                    getShiftForDateAttMonthStatus(column, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem)
                ),
                clsl: getTotalApprovedLeave(item?._doc?.empcode, tempResultDates, allLeaveStatus),
                weekoff: getTotalWeekOff(item?._doc?.empcode, dayshift),
                holiday: getTotalHolidays(item?._doc?.company, item?._doc?.branch, item?._doc?.unit, item?._doc?.team, item?._doc?.companyname, tempResultDates, holidays),
                totalabsentleave: getTotalAbsentLeave(item?._doc?._id.toString(), item?._doc?.empcode, dayshift, getTotalApprovedLeave(item?._doc?.empcode, tempResultDates, allLeaveStatus), getTotalHolidays(item?._doc?.company, item?._doc?.branch, item?._doc?.unit, item?._doc?.team, item?._doc?.companyname, tempResultDates, holidays), allLeaveStatus, allAttandanceList, ismonth, isyear),
                totalpaiddays: getTotalPaidDays(getTotalShiftHours(item?._doc?._id.toString(), tempResultDates, allAttandanceList), getTotalApprovedLeave(item?._doc?.empcode, tempResultDates, allLeaveStatus), getTotalWeekOff(item?._doc?.empcode, dayshift), getTotalHolidays(item?._doc?.company, item?._doc?.branch, item?._doc?.unit, item?._doc?.team, item?._doc?.companyname, tempResultDates, holidays))
            }
            return userData;
        });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    if (!finaluserattmonth) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ finaluserattmonth });
});

exports.getAllUsersPayrunexceldata = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {
        users = await User.find(
            {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
                resonablestatus: {
                    $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
            },
            {

                department: 1,

                processlog: 1,
                boardingLog: 1, attendancemode: 1,
                designationlog: 1,
                company: 1,

                empcode: 1,
                companyname: 1,
                team: 1,
                floor: 1,
                username: 1,

                unit: 1,
                branch: 1,
                designation: 1,
                team: 1,
                shift: 1,

                experience: 1,
                doj: 1,
                dot: 1,
                // role: 1,
                bankname: 1,
                bankdetails: 1,
                bankbranchname: 1,
                accountholdername: 1,
                accountnumber: 1,
                ifsccode: 1,
                shifttiming: 1,
                shiftgrouping: 1,
                legalname: 1,
                callingname: 1,
                aadhar: 1,
                panno: 1,
                panstatus: 1,
                panrefno: 1,
                process: 1,
                // weekoff: 1,
                area: 1,
                shiftallot: 1,
                assignExpLog: 1,
                ipname: 1,
                pfmembername: 1,
                uan: 1,
                insurancenumber: 1,
                shiftallowancelog: 1,
                targetpointlog: 1,
                acheivedpointlog: 1,
                penaltylog: 1,
                totalabsentlog: 1,
                totalpaiddayslog: 1,
                shiftallowancelog: 1,
                targetpointlog: 1,
                acheivedpointlog: 1,
                penaltylog: 1,
                totalabsentlog: 1,
                totalpaiddayslog: 1,
                currmonthattlog: 1,
                currmonthavglog: 1,
                assignpfesilog: 1

            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }
    return res.status(200).json({ users });
});

exports.deleteUserLogObjects = catchAsyncErrors(async (req, res, next) => {
    try {
        const { ids, logname } = req.body;
        // Construct a filter to find the document with the specified ipconfig._id
        const updateOperations = {
            updateOne: {
                filter: {
                    [`${logname}._id`]: ids, // Assuming ids contains the ids you want to delete
                },
                update: {
                    $pull: {
                        [`${logname}`]: { _id: { $in: ids } } // Assuming ids contains the ids you want to delete
                    },
                },
            },
        };
        const { filter, update } = updateOperations.updateOne;
        const user = await User.findOne(filter);
        if (user) {
            await User.updateOne(filter, update);
        }
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
});
//payrun final salary
exports.getAllusersLimitedFinalsalary = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {
        const { month, monthnum, year } = req.body;

        function getMonthStartAndEndDate(monthname, year) {
            // Create a mapping of month names to their 0-based indices
            const monthMap = {
                January: 0,
                February: 1,
                March: 2,
                April: 3,
                May: 4,
                June: 5,
                July: 6,
                August: 7,
                September: 8,
                October: 9,
                November: 10,
                December: 11,
            };

            // Get the month index
            const monthIndex = monthMap[monthname];

            if (monthIndex === undefined) {
                throw new Error('Invalid month name provided.');
            }

            // Start date is the first day of the month
            const monthStartDate = new Date(year, monthIndex, 1);

            // End date is the last day of the month (calculated as the day before the first day of the next month)
            const firstDayNextMonth = new Date(year, monthIndex + 1, 1);
            const monthEndDate = new Date(firstDayNextMonth - 1);

            // Return start and end dates in YYYY-MM-DD format
            return {
                startDate: monthStartDate.toISOString().split('T')[0], // YYYY-MM-DD
                endDate: monthEndDate.toISOString().split('T')[0], // YYYY-MM-DD
            };
        }

        // Example usage
        const { monthStartDate, monthEndDate } = getMonthStartAndEndDate(month, Number(year));

        const depMonthSet = await DepartmentMonth.find({ monthname: month, year: String(year) }, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 });
        let usersAll = await User.find(
            {
                enquirystatus: {
                    $nin: ['Enquiry Purpose'],
                },
            },
            {
                reasondate: 1,
                companyname: 1,
                company: 1,
                branch: 1,
                unit: 1,
                team: 1,
                doj: 1,
                department: 1,
                designation: 1,
                boardingLog: 1,
                departmentlog: 1,
            }
        );

        function filterLatestLogs(monthArray, departmentlog) {
            // Step 1: Sort logs by startdate
            const sortedLogs = [...departmentlog].sort((a, b) => new Date(a.startdate) - new Date(b.startdate));

            // Step 2: Assign an effective end date (next log startdate - 1 day)
            sortedLogs.forEach((log, index) => {
                if (index < sortedLogs.length - 1) {
                    log.enddate = new Date(new Date(sortedLogs[index + 1].startdate).getTime() - 86400000); // 1 day before next log's startdate
                } else {
                    log.enddate = new Date("9999-12-31"); // Default max end date for the last log
                }
            });

            // Step 3: Filter logs based on monthArray and department
            const filteredLogs = sortedLogs.filter(log => {
                return monthArray.some(month => {
                    const fromDate = new Date(month.fromdate);
                    const toDate = new Date(month.todate);
                    const startDate = new Date(log.startdate);
                    const endDate = new Date(log.enddate);

                    return startDate <= toDate && endDate >= fromDate && log.department === month.department;
                });
            });

            // Step 4: Select the latest log per department based on updateddatetime
            const latestLogs = {};
            filteredLogs.forEach(log => {
                const dept = log.department;
                if (!latestLogs[dept] || new Date(log.updateddatetime) > new Date(latestLogs[dept].updateddatetime)) {
                    latestLogs[dept] = log;
                }
            });

            return Object.values(latestLogs);
        }
        function filterLatestLogsTeam(monthArray, teamLog, department) {
            // Step 1: Sort logs by startdate
            const sortedLogs = [...teamLog].sort((a, b) => new Date(a.startdate) - new Date(b.startdate));

            // Step 2: Assign an effective end date (next log startdate - 1 day)
            sortedLogs.forEach((log, index) => {
                if (index < sortedLogs.length - 1) {
                    log.enddate = new Date(new Date(sortedLogs[index + 1].startdate).getTime() - 86400000); // 1 day before next log's startdate
                } else {
                    log.enddate = new Date("9999-12-31"); // Default max end date for the last log
                }
            });

            // Step 3: Filter logs based on monthArray and department
            const filteredLogs = sortedLogs.filter(log => {
                return monthArray.some(month => {
                    const fromDate = new Date(month.fromdate);
                    const toDate = new Date(month.todate);
                    const startDate = new Date(log.startdate);
                    const endDate = new Date(log.enddate);

                    return startDate <= toDate && endDate >= fromDate && department === month.department;
                });
            });

            // Step 4: Select the latest log per department based on updateddatetime
            const latestLogs = {};
            filteredLogs.forEach(log => {
                const dept = log.department;
                if (!latestLogs[dept] || new Date(log.updateddatetime) > new Date(latestLogs[dept].updateddatetime)) {
                    latestLogs[dept] = log;
                }
            });

            return Object.values(latestLogs);
        }

        users = usersAll
            .map((user) => {
                const item = { ...user._doc };
                let filteredBoarding = user.boardingLog.filter((log) => log.logcreation !== 'shift' && log.ischangeteam);

                const finalDepartment = filterLatestLogs(depMonthSet, user.departmentlog).length > 0 ? filterLatestLogs(depMonthSet, user.departmentlog, item.companyname)[(filterLatestLogs(depMonthSet, user.departmentlog).length) - 1]?.department : ""
                item.department = finalDepartment

                item.team = filterLatestLogsTeam(depMonthSet, filteredBoarding, finalDepartment).length > 0 ? filterLatestLogsTeam(depMonthSet, filteredBoarding, finalDepartment)[filterLatestLogsTeam(depMonthSet, filteredBoarding, finalDepartment).length - 1]?.team : ""


                return item;
            })
            .filter((d) => {
                const userDepartmentDate = depMonthSet.find((dms) => d.department === dms.department);
                const fromdate = userDepartmentDate ? new Date(userDepartmentDate.fromdate) : monthStartDate;
                const todate = userDepartmentDate ? new Date(userDepartmentDate.todate) : monthEndDate;
                const dojcompare = d.department == 'Internship' && d.departmentlog.length > 1 ? true : fromdate >= new Date(d.doj) || todate >= new Date(d.doj);
                return dojcompare && (d.reasondate === '' || !d.reasondate || new Date(d.reasondate) >= fromdate || new Date(d.reasondate) >= todate);
            });

    } catch (err) {
        return next(new ErrorHandler('Records not found!', 404));
    }
    if (!users) {
        return next(new ErrorHandler('Users not found', 400));
    }
    return res.status(200).json({ users });
});

exports.getAllUsersPayrunexceldataFinal = catchAsyncErrors(async (req, res, next) => {
    let users, filteredUsers, depMonthSet;
    try {


        await User.collection.createIndex({ companyname: 1, enquirystatus: 1 });
        await DepartmentMonth.collection.createIndex({ monthname: 1, year: 1 });

        const { branch, unit, team, department, month, year } = req.body;

        const filter = {};
        if (branch && branch.length > 0) {
            filter.branch = { $in: branch };
        }
        if (unit && unit.length > 0) {
            filter.unit = { $in: unit };
        }
        if (team && team.length > 0) {
            filter.team = { $in: team };
        }
        if (req.body.employees && req.body.employees.length > 0) {
            filter.companyname = { $in: req.body.employees };
        }
        filter.enquirystatus = { $nin: ['Enquiry Purpose'] };

        // filter.resonablestatus = {
        //   $nin: ['Releave Employee', 'Absconded', 'Hold', 'Terminate'],
        //   // $or: [{ reasondate: { $exists: false } }, { reasondate: { $eq: '' } }, { reasondate: { $gte: date } }],
        // };

        function getMonthStartAndEndDate(monthname, year) {
            // Create a mapping of month names to their 0-based indices
            const monthMap = {
                January: 0,
                February: 1,
                March: 2,
                April: 3,
                May: 4,
                June: 5,
                July: 6,
                August: 7,
                September: 8,
                October: 9,
                November: 10,
                December: 11,
            };

            // Get the month index
            const monthIndex = monthMap[monthname];

            if (monthIndex === undefined) {
                throw new Error('Invalid month name provided.');
            }

            // Start date is the first day of the month
            const monthStartDate = new Date(year, monthIndex, 1);

            // End date is the last day of the month (calculated as the day before the first day of the next month)
            const firstDayNextMonth = new Date(year, monthIndex + 1, 1);
            const monthEndDate = new Date(firstDayNextMonth - 1);

            // Return start and end dates in YYYY-MM-DD format
            return {
                startDate: monthStartDate.toISOString().split('T')[0], // YYYY-MM-DD
                endDate: monthEndDate.toISOString().split('T')[0], // YYYY-MM-DD
            };
        }

        // Example usage
        const { monthStartDate, monthEndDate } = getMonthStartAndEndDate(month, Number(year));

        depMonthSet = await DepartmentMonth.find({ monthname: month, year: year }, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 });
        // const fromDateSet = [...new Set(depMonthSet.map((d) => d.fromdate))];

        filteredUsers = await User.find(filter, {
            department: 1,
            departmentlog: 1,
            processlog: 1,
            boardingLog: 1,
            designationlog: 1,
            company: 1,
            empcode: 1,
            companyname: 1,
            team: 1,
            floor: 1,
            username: 1,
            unit: 1,
            branch: 1,
            designation: 1,
            shift: 1,
            experience: 1,
            doj: 1,
            bankname: 1,
            bankdetails: 1,
            bankbranchname: 1,
            accountholdername: 1,
            accountnumber: 1,
            ifsccode: 1,
            shifttiming: 1,
            shiftgrouping: 1,
            legalname: 1,
            process: 1,
            pfesifromdate: 1,
            isenddate: 1,
            pfdeduction: 1,
            esideduction: 1,
            pfesienddate: 1,
            area: 1,
            shiftallot: 1,
            assignExpLog: 1,
            ipname: 1,
            pfmembername: 1,
            uan: 1,
            insurancenumber: 1,
            shiftallowancelog: 1,
            targetpointlog: 1,
            acheivedpointlog: 1,
            penaltylog: 1,
            totalabsentlog: 1,
            totalpaiddayslog: 1,
            currmonthattlog: 1,
            currmonthavglog: 1,
            assignpfesilog: 1,
            noshiftlog: 1,
            shiftallowtargetlog: 1,
            reasondate: 1,
            nightshiftallowlog: 1,
            resonablestatus: 1
        });
        function filterLatestLogs(monthArray, departmentlog) {
            // Step 1: Sort logs by startdate
            const sortedLogs = [...departmentlog].sort((a, b) => new Date(a.startdate) - new Date(b.startdate));

            // Step 2: Assign an effective end date (next log startdate - 1 day)
            sortedLogs.forEach((log, index) => {
                if (index < sortedLogs.length - 1) {
                    log.enddate = new Date(new Date(sortedLogs[index + 1].startdate).getTime() - 86400000); // 1 day before next log's startdate
                } else {
                    log.enddate = new Date("9999-12-31"); // Default max end date for the last log
                }
            });

            // Step 3: Filter logs based on monthArray and department
            const filteredLogs = sortedLogs.filter(log => {
                return monthArray.some(month => {
                    const fromDate = new Date(month.fromdate);
                    const toDate = new Date(month.todate);
                    const startDate = new Date(log.startdate);
                    const endDate = new Date(log.enddate);

                    return startDate <= toDate && endDate >= fromDate && log.department === month.department;
                });
            });

            // Step 4: Select the latest log per department based on updateddatetime
            const latestLogs = {};
            filteredLogs.forEach(log => {
                const dept = log.department;
                if (!latestLogs[dept] || new Date(log.updateddatetime) > new Date(latestLogs[dept].updateddatetime)) {
                    latestLogs[dept] = log;
                }
            });

            return Object.values(latestLogs);
        }
        function filterLatestLogsTeam(monthArray, teamLog, department) {
            // Step 1: Sort logs by startdate
            const sortedLogs = [...teamLog].sort((a, b) => new Date(a.startdate) - new Date(b.startdate));

            // Step 2: Assign an effective end date (next log startdate - 1 day)
            sortedLogs.forEach((log, index) => {
                if (index < sortedLogs.length - 1) {
                    log.enddate = new Date(new Date(sortedLogs[index + 1].startdate).getTime() - 86400000); // 1 day before next log's startdate
                } else {
                    log.enddate = new Date("9999-12-31"); // Default max end date for the last log
                }
            });

            // Step 3: Filter logs based on monthArray and department
            const filteredLogs = sortedLogs.filter(log => {
                return monthArray.some(month => {
                    const fromDate = new Date(month.fromdate);
                    const toDate = new Date(month.todate);
                    const startDate = new Date(log.startdate);
                    const endDate = new Date(log.enddate);

                    return startDate <= toDate && endDate >= fromDate && department === month.department;
                });
            });

            // Step 4: Select the latest log per department based on updateddatetime
            const latestLogs = {};
            filteredLogs.forEach(log => {
                const dept = log.department;
                if (!latestLogs[dept] || new Date(log.updateddatetime) > new Date(latestLogs[dept].updateddatetime)) {
                    latestLogs[dept] = log;
                }
            });

            return Object.values(latestLogs);
        }

        users = filteredUsers
            .map((user) => {
                const item = { ...user._doc };
                let filteredBoarding = user.boardingLog.filter((log) => log.logcreation !== 'shift' && log.ischangeteam);

                const finalDepartment = filterLatestLogs(depMonthSet, user.departmentlog).length > 0 ? filterLatestLogs(depMonthSet, user.departmentlog, item.companyname)[(filterLatestLogs(depMonthSet, user.departmentlog).length) - 1]?.department : ""
                item.department = finalDepartment

                item.team = filterLatestLogsTeam(depMonthSet, filteredBoarding, finalDepartment).length > 0 ? filterLatestLogsTeam(depMonthSet, filteredBoarding, finalDepartment)[filterLatestLogsTeam(depMonthSet, filteredBoarding, finalDepartment).length - 1]?.team : ""


                return item;
            })
            .filter((d) => {
                const userDepartmentDate = depMonthSet.find((dms) => d.department === dms.department);
                const fromdate = userDepartmentDate ? new Date(userDepartmentDate.fromdate) : monthStartDate;
                const todate = userDepartmentDate ? new Date(userDepartmentDate.todate) : monthEndDate;
                const dojcompare = d.department == 'Internship' && d.departmentlog.length > 1 ? true : fromdate >= new Date(d.doj) || todate >= new Date(d.doj);
                return dojcompare && (d.reasondate === '' || !d.reasondate || new Date(d.reasondate) >= fromdate || new Date(d.reasondate) >= todate) && department.includes(item.department);
            });

    } catch (err) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ users });
});

exports.getAllUserClockinAndClockoutStatusForMontLopCalFilterFinalSalary = catchAsyncErrors(async (req, res, next) => {
    let attendance;
    let allLeaveStatus;
    let resultshiftallot = [];
    let graceTime;
    let clockOutHours;
    let lateclockincount;
    let earlyclockoutcount;
    let onclockout;
    let earlyclockin;
    let earlyclockout;
    let lateclockin;
    let afterlateclockin;
    let beforeearlyclockout;
    let permission;
    let weekOffDates = [];
    let finaluser = [];
    let result = [];
    // let getattendancestatus = [];
    const { ismonth, isyear } = req.body;

    try {
        const filter = {};

        if (req.body.company.length > 0) {
            filter.company = { $in: req.body.company };
        }

        if (req.body.branch && req.body.branch.length > 0) {
            filter.branch = { $in: req.body.branch };
        }

        if (req.body.unit && req.body.unit.length > 0) {
            filter.unit = { $in: req.body.unit };
        }

        if (req.body.department && req.body.department.length > 0) {
            filter.department = { $in: req.body.department };
        }

        if (req.body.team && req.body.team.length > 0) {
            filter.team = { $in: req.body.team };
        }

        if (req.body.designation && req.body.designation.length > 0) {
            filter.designation = { $in: req.body.designation };
        }

        if (req.body.employees && req.body.employees.length > 0) {
            filter.companyname = { $in: req.body.employees };
        }
        filter.enquirystatus = {
            $nin: ["Enquiry Purpose"],
        },
            filter.resonablestatus = {
                $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
            },

            // Use the 'filter' object in your MongoDB query


            let[users, depMonthSet, controlcriteria, holidays, leavetype] = await Promise.all([
                User.find(
                    filter,
                    {
                        company: 1,
                        branch: 1,
                        unit: 1,
                        team: 1,
                        department: 1,
                        designation: 1,
                        doj: 1,
                        empcode: 1,
                        companyname: 1,
                        team: 1,
                        floor: 1,
                        username: 1,

                        weekoff: 1,
                        shiftallot: 1,
                        shifttiming: 1,
                        boardingLog: 1, attendancemode: 1,
                        department: 1,
                        processlog: 1,
                        designationlog: 1,

                        experience: 1,
                    }
                ),
                DepartmentMonth.find({ year: { $eq: isyear }, monthname: { $eq: monthNames[ismonth - 1] } }, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 }),
                ControlCriteria.find(),
                Holiday.find({}, { date: 1, company: 1, applicablefor: 1, unit: 1, team: 1, employee: 1, noofdays: 1 }),
                Leavetype.find({}, { leavetype: 1, code: 1 })
            ])


        const monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];

        const from_date = new Date(isyear, ismonth - 1, 1);

        // Calculate the last day of the previous month
        const last_day_prev_month = new Date(from_date.getFullYear(), from_date.getMonth(), 0);

        // Get the 15th day of the previous month
        const before_month_date = new Date(last_day_prev_month.getFullYear(), last_day_prev_month.getMonth(), 25);

        // Get the 15th day of the next month
        const next_month = new Date(from_date.getFullYear(), from_date.getMonth() + 1, 5);

        let fromdate = before_month_date.toISOString()?.split("T")[0];
        let todate = next_month.toISOString()?.split("T")[0];

        const originalDateObject = new Date(fromdate);


        const originalDateObjecttodate = new Date(todate);
        const maxDateDocument = await Attendance.findOne({}, { createdAt: 1 }).sort({ createdAt: -1 });

        const maxDate = maxDateDocument.length > 0 ? maxDateDocument[0].createdAt : null;

        let maxDateFinal = originalDateObjecttodate > (maxDate ? maxDate : new Date(req.body.today)) ? (maxDate ? maxDate : req.body.today) : originalDateObjecttodate;

        attendance = await Attendance.find(
            {
                $and: [{ createdAt: { $gt: originalDateObject } }, { createdAt: { $lt: maxDateFinal } }],
            },
            { username: 1, clockintime: 1, clockouttime: 1, buttonstatus: 1, date: 1, userid: 1, status: 1, attendancestatus: 1, attendancemanual: 1, autoclockout: 1 }
        );
        const userCds = users.map(user => user.companyname);
        allLeaveStatus = await ApplyLeave.find({ employeename: { $in: userCds } });
        permission = await Permission.find({ employeename: { $in: userCds } }, { employeeid: 1, date: 1, status: 1, applytype: 1, compensationstatus: 1, compensationapplytype: 1, requesthours: 1, shiftmode: 1, });

        // graceTime = controlcriteria[0].gracetime;
        clockOutHours = controlcriteria[0].clockout;
        lateclockincount = controlcriteria[0].lateclockincount;
        earlyclockoutcount = controlcriteria[0].earlyclockoutcount;
        onclockout = controlcriteria[0].onclockout;
        earlyclockin = controlcriteria[0].earlyclockin;
        lateclockin = controlcriteria[0].lateclockin;
        earlyclockout = controlcriteria[0].earlyclockout;
        afterlateclockin = controlcriteria[0].afterlateclockin;
        beforeearlyclockout = controlcriteria[0].afterlateclockin;

        // const monthNames = ["January", "February", "March", "April", "May", "June",
        //     "July", "August", "September", "October", "November", "December"
        // ];

        finaluser = users?.flatMap((item, index) => {

            let isEmployeeGrace = controlcriteria[0].todos && controlcriteria[0].todos.find(d => d.company === item.company &&
                d.branch === item.branch && d.unit === item.unit && d.team === item.team &&
                d.employeename === item.companyname
            )

            if (isEmployeeGrace) {
                graceTime = isEmployeeGrace.employeegracetime;
            }
            else {
                graceTime = controlcriteria[0].gracetime;
            }

            let userDates = [];

            // Remove duplicate entries with the most recent entry
            const uniqueEntriesDep = {};
            item.departmentlog?.forEach(entry => {
                const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                const key = entry.startdate;
                if (!(key in uniqueEntriesDep)) {
                    uniqueEntriesDep[key] = entry;
                }
            });
            const foundDepartment = depMonthSet?.find((d) => Number(d.year) === isyear && d.monthname === monthNames[ismonth - 1]);
            const uniqueDepLog = Object.values(uniqueEntriesDep);
            const relevantDepLogEntry = uniqueDepLog
                .filter(log => new Date(log.startdate) <= new Date(foundDepartment && foundDepartment.fromdate))
                .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

            const comparedDate = depMonthSet?.filter((d) => d.department === (relevantDepLogEntry && relevantDepLogEntry.department));
            const dojDate = item?._doc?.boardingLog.length > 0 ?
                item?._doc?.boardingLog[0].startdate
                : item?._doc?.doj;

            if (comparedDate && comparedDate.length > 0) {
                comparedDate?.forEach((dep) => {
                    if (!dep.fromdate && !dep.todate) {
                        return "";
                    }

                    if (!item?._doc?.doj) {
                        return "";
                    }

                    const [year2, month2, day2] = dojDate?.split("-").map(Number);
                    const joiningDate = new Date(year2, month2 - 1, day2);
                    const [year1, month1, day1] = dep.fromdate?.split("-").map(Number);
                    const [year, month, day] = dep.todate?.split("-").map(Number);
                    const lastDate = new Date(year, month - 1, day);
                    const firstDate = new Date(year1, month1 - 1, day1);

                    if (joiningDate < firstDate) {
                        // Check if the shift date is before or equal to the current date
                        if (lastDate >= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(firstDate);
                            // Loop through the dates in the range
                            while (startDate <= currentDateAttStatus) {
                                userDates.push({
                                    formattedDate: format(startDate, "dd/MM/yyyy"),
                                    dayName: format(startDate, "EEEE"),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        } else if (lastDate <= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(firstDate);
                            // Loop through the dates in the range
                            while (startDate <= lastDate) {
                                userDates.push({
                                    formattedDate: format(startDate, "dd/MM/yyyy"),
                                    dayName: format(startDate, "EEEE"),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        }
                    } else {
                        // Check if the shift date is before or equal to the current date
                        if (lastDate >= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(joiningDate);
                            // Loop through the dates in the range
                            while (startDate <= currentDateAttStatus) {
                                userDates.push({
                                    formattedDate: format(startDate, "dd/MM/yyyy"),
                                    dayName: format(startDate, "EEEE"),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        } else if (lastDate <= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(joiningDate);
                            // Loop through the dates in the range
                            while (startDate <= lastDate) {
                                userDates.push({
                                    formattedDate: format(startDate, "dd/MM/yyyy"),
                                    dayName: format(startDate, "EEEE"),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        }
                    }
                });
            } else {
                const [year2, month2, day2] = dojDate?.split("-").map(Number);
                const joiningDate = new Date(year2, month2 - 1, day2);
                // Calculate the start date of the month based on the selected month
                const startDate = new Date(isyear, ismonth - 1, 1);

                const endDate = new Date(startDate);
                endDate.setMonth(endDate.getMonth() + 1);
                endDate.setDate(endDate.getDate() - 1);

                if (joiningDate < startDate) {
                    // Check if the shift date is before or equal to the current date
                    if (endDate >= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            userDates.push({
                                formattedDate: format(currentDate1, "dd/MM/yyyy"),
                                dayName: format(currentDate1, "EEEE"),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    } else if (endDate <= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            userDates.push({
                                formattedDate: format(currentDate1, "dd/MM/yyyy"),
                                dayName: format(currentDate1, "EEEE"),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    }
                } else {
                    // Check if the shift date is before or equal to the current date
                    if (endDate >= currentDateAttStatus) {
                        // If matched, push the range from 'fromdate' to 'todate'
                        const startDate = new Date(joiningDate);
                        // Loop through the dates in the range
                        while (startDate <= currentDateAttStatus) {
                            userDates.push({
                                formattedDate: format(startDate, "dd/MM/yyyy"),
                                dayName: format(startDate, "EEEE"),
                                dayCount: startDate.getDate(),
                            });
                            startDate.setDate(startDate.getDate() + 1);
                        }
                    } else if (endDate <= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            userDates.push({
                                formattedDate: format(currentDate1, "dd/MM/yyyy"),
                                dayName: format(currentDate1, "EEEE"),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    }
                }
            }

            item.shiftallot?.map((allot) => {
                resultshiftallot.push({ ...allot });
            });

            const filteredMatchingDoubleShiftItem = resultshiftallot?.filter(val => val && val?._doc?.empcode === item?._doc?.empcode && val?._doc?.adjstatus === 'Approved');

            // Filter out the dates that have matching 'Shift Adjustment' todates
            let removedUserDates = userDates.filter(date => {
                // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
                const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem.find(item => item && item?._doc?.todate === date.formattedDate && item?._doc?.adjustmenttype === 'Shift Adjustment');

                // If there is no matching 'Shift Adjustment', keep the date
                return !matchingShiftAdjustmentToDate;
            });

            // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
            let uniqueEntries = new Set();

            // Iterate over removedUserDates and add unique entries to the Set
            userDates.forEach(date => {
                uniqueEntries.add(JSON.stringify({
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    shiftMode: 'Main Shift',
                    weekNumberInMonth: date.weekNumberInMonth,
                }));
            });

            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach(item => {
                const [day, month, year] = item._doc.adjdate?.split('/')
                let newFormattedDate = new Date(`${year}-${month}-${day}`);

                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(JSON.stringify({
                        formattedDate: item._doc.adjdate,
                        dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
                        dayCount: parseInt(moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")),
                        shiftMode: 'Second Shift',
                        weekNumberInMonth: (getWeekNumberInMonth(newFormattedDate) === 1 ? `${getWeekNumberInMonth(newFormattedDate)}st Week` :
                            getWeekNumberInMonth(newFormattedDate) === 2 ? `${getWeekNumberInMonth(newFormattedDate)}nd Week` :
                                getWeekNumberInMonth(newFormattedDate) === 3 ? `${getWeekNumberInMonth(newFormattedDate)}rd Week` :
                                    getWeekNumberInMonth(newFormattedDate) > 3 ? `${getWeekNumberInMonth(newFormattedDate)}th Week` : '')
                    }));
                }
            });

            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries).map(entry => JSON.parse(entry));

            function sortUserDates(dates) {
                return dates.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);
            const createdUserDates = sortedCreatedUserDates?.filter(d => {
                const filterData = userDates.some(val => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date) => {
                let filteredRowData = resultshiftallot?.filter((val) => val?._doc?.empcode == item?._doc?.empcode);
                const matchingItem = filteredRowData?.find(item => item && item?._doc?.adjdate == date.formattedDate);
                const matchingItemAllot = filteredRowData?.find(item => item && formatDate(item?._doc?.date) == date.formattedDate);
                const matchingDoubleShiftItem = filteredRowData?.find(item => item && item?._doc?.todate === date.formattedDate);
                const matchingRemovedItem = filteredRowData?.find(item => item?._doc?.removedshiftdate === date.formattedDate);
                const matchingAssignShiftItem = filteredRowData?.find(item => item?._doc?.adjdate === date.formattedDate && item?._doc?.adjstatus === 'Approved' && item?._doc?.adjustmenttype === 'Assign Shift');

                const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                    // return item;
                });

                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item?._doc?.weekoff?.includes(date.dayName);
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                const row = {
                    id: `${item?._doc?._id.toString()}_${date.formattedDate}_${date.shiftMode}`,
                    userid: item?._doc?._id.toString(),
                    company: item?._doc?.company,
                    branch: item?._doc?.branch,
                    unit: item?._doc?.unit,
                    team: item?._doc?.team,
                    doj: dojDate,
                    department: relevantDepLogEntry && relevantDepLogEntry?.department,
                    username: item?._doc?.companyname,
                    empcode: item?._doc?.empcode,
                    weekoff: item?._doc?.weekoff,
                    boardingLog: item?._doc?.boardingLog,
                    shiftallot: item?._doc?.shiftallot,
                    shift: getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                    date: `${date.formattedDate} ${date.dayName} ${date.dayCount}`,
                    role: item?._doc?.role,
                    rowformattedDate: date.formattedDate,
                    dayName: date.dayName,
                    shiftMode: date.shiftMode,
                    clockin: checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        date.shiftMode,
                    ),
                    clockout: checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        date.shiftMode,
                    ),
                    clockinstatus: checkClockInStatus(
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        graceTime, allLeaveStatus, holidays,
                        checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,), item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname,
                        earlyclockin, lateclockin, afterlateclockin, leavetype, permission,
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    clockoutstatus: checkClockOutStatus(
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        clockOutHours, checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        allLeaveStatus, holidays, item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname, onclockout,
                        earlyclockout, beforeearlyclockout,
                        checkGetClockInAutoStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        leavetype, permission, date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    attendanceautostatus: checkAttendanceStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    lateclockincount: lateclockincount,
                    earlyclockoutcount: earlyclockoutcount,
                    totalnumberofdays: getTotalMonthDaysUser(item?._doc?.department, depMonthSet, ismonth, isyear),
                    empshiftdays: getTotalMonthDaysForEmpUser(dojDate, item?._doc?.department, depMonthSet, ismonth, isyear),
                    totalcounttillcurrendate: getTotalMonthsCurrentDateCountUser(dojDate, item?._doc?.department, depMonthSet, ismonth, isyear),
                    totalshift: getTotalShiftHoursUser(item?._doc?._id.toString(), createdUserDates, attendance),
                    weekoffpresentstatus: checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                };

                return row;
            });

            return userRows;
        });


    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finaluser) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ finaluser });
});
exports.getAllUserClockinAndClockoutStatusForMontLopCalFilterPayRunMasterFetch = catchAsyncErrors(async (req, res, next) => {
    let users;
    let resultshiftallot = [];
    let graceTime;
    let clockOutHours;
    let lateclockincount;
    let earlyclockoutcount;
    let onclockout;
    let earlyclockin;
    let earlyclockout;
    let lateclockin;
    let afterlateclockin;
    let beforeearlyclockout;
    let weekOffDates = [];
    let finaluser = [];
    let result = [];
    // let getattendancestatus = [];
    const { ismonth, isyear } = req.body;

    try {
        const filter = {};

        if (req.body.company.length > 0) {
            filter.company = { $in: req.body.company };
        }

        if (req.body.branch && req.body.branch.length > 0) {
            filter.branch = { $in: req.body.branch };
        }

        if (req.body.unit && req.body.unit.length > 0) {
            filter.unit = { $in: req.body.unit };
        }

        if (req.body.department && req.body.department.length > 0) {
            filter.department = { $in: req.body.department };
        }

        if (req.body.team && req.body.team.length > 0) {
            filter.team = { $in: req.body.team };
        }

        if (req.body.designation && req.body.designation.length > 0) {
            filter.designation = { $in: req.body.designation };
        }

        if (req.body.companyname && req.body.company.length > 0) {
            filter.employees = { $in: req.body.companyname };
        }
        (filter.enquirystatus = {
            $nin: ["Enquiry Purpose"],
        }),
            (filter.resonablestatus = {
                $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
            }),
            // Use the 'filter' object in your MongoDB query

            (users = await User.find(filter, {
                company: 1,
                branch: 1,
                unit: 1,
                team: 1,
                department: 1,
                designation: 1,
                doj: 1,
                dot: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                floor: 1,
                username: 1,

                weekoff: 1,
                shiftallot: 1,
                shifttiming: 1,
                boardingLog: 1, attendancemode: 1,
                department: 1,
                processlog: 1,
                designationlog: 1,

                experience: 1,
                departmentlog: 1,
            }));

        const monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];

        const from_date = new Date(isyear, ismonth - 1, 1);

        // Calculate the last day of the previous month
        const last_day_prev_month = new Date(from_date.getFullYear(), from_date.getMonth(), 0);

        // Get the 15th day of the previous month
        const before_month_date = new Date(last_day_prev_month.getFullYear(), last_day_prev_month.getMonth(), 20);

        // Get the 15th day of the next month
        const next_month = new Date(from_date.getFullYear(), from_date.getMonth() + 1, 10);

        let fromdate = before_month_date.toISOString()?.split("T")[0];
        let todate = next_month.toISOString()?.split("T")[0];

        const originalDateObject = new Date(fromdate);

        const originalDateObjecttodate = new Date(todate);
        const maxDateDocument = await Attendance.findOne({}, { createdAt: 1 }).sort({ createdAt: -1 });

        const maxDate = maxDateDocument.length > 0 ? maxDateDocument[0].createdAt : null;

        let maxDateFinal = originalDateObjecttodate > (maxDate ? maxDate : new Date(req.body.today)) ? (maxDate ? maxDate : req.body.today) : originalDateObjecttodate;
        const userIds = users.map(user => user._id);
        const userCds = users.map(user => user.companyname);

        const [attendance, depMonthSet, controlcriteria, allLeaveStatus, holidays, leavetype, permission, attModearr, attStatus] = await Promise.all([
            Attendance.find(
                {
                    $and: [{ createdAt: { $gt: originalDateObject } }, { createdAt: { $lt: maxDateFinal } }],
                },
                { username: 1, clockintime: 1, clockouttime: 1, buttonstatus: 1, date: 1, userid: 1, status: 1 }
            ),
            DepartmentMonth.find({ year: { $eq: isyear }, monthname: { $eq: monthNames[ismonth - 1] } }, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 }),
            ControlCriteria.find(),
            ApplyLeave.find({ employeename: { $in: userCds } }),
            Holiday.find({}, { date: 1, company: 1, applicablefor: 1, unit: 1, team: 1, employee: 1, noofdays: 1 }),
            Leavetype.find({}, { leavetype: 1, code: 1 }),
            Permission.find({ employeename: { $in: userCds } }, { employeeid: 1, date: 1, status: 1, applytype: 1, compensationstatus: 1, compensationapplytype: 1, requesthours: 1, shiftmode: 1, }),
            AttendanceModeStatus.find(),
            AttendanceStatusMaster.find()

        ])

        // graceTime = controlcriteria[0].gracetime;
        clockOutHours = controlcriteria[0].clockout;
        lateclockincount = controlcriteria[0].lateclockincount;
        earlyclockoutcount = controlcriteria[0].earlyclockoutcount;
        onclockout = controlcriteria[0].onclockout;
        earlyclockin = controlcriteria[0].earlyclockin;
        lateclockin = controlcriteria[0].lateclockin;
        earlyclockout = controlcriteria[0].earlyclockout;
        afterlateclockin = controlcriteria[0].afterlateclockin;
        beforeearlyclockout = controlcriteria[0].afterlateclockin;

        // const monthNames = ["January", "February", "March", "April", "May", "June",
        //     "July", "August", "September", "October", "November", "December"
        // ];

        finaluser = users?.flatMap((item, index) => {

            let isEmployeeGrace = controlcriteria[0].todos && controlcriteria[0].todos.find(d => d.company === item.company &&
                d.branch === item.branch && d.unit === item.unit && d.team === item.team &&
                d.employeename === item.companyname
            )

            if (isEmployeeGrace) {
                graceTime = isEmployeeGrace.employeegracetime;
            }
            else {
                graceTime = controlcriteria[0].gracetime;
            }

            let userDates = [];

            // Remove duplicate entries with the most recent entry
            const uniqueEntriesDep = {};
            item.departmentlog?.forEach(entry => {
                const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                const key = entry.startdate;
                if (!(key in uniqueEntriesDep)) {
                    uniqueEntriesDep[key] = entry;
                }
            });
            const foundDepartment = depMonthSet?.find((d) => Number(d.year) === isyear && d.monthname === monthNames[ismonth - 1]);
            const uniqueDepLog = Object.values(uniqueEntriesDep);
            const relevantDepLogEntry = uniqueDepLog
                .filter(log => new Date(log.startdate) <= new Date(foundDepartment && foundDepartment.fromdate))
                .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

            const comparedDate = depMonthSet?.filter((d) => d.department === (relevantDepLogEntry && relevantDepLogEntry.department));

            const dojDate = item?._doc?.boardingLog.length > 0 ?
                item?._doc?.boardingLog[0].startdate
                : item?._doc?.doj;

            if (comparedDate && comparedDate.length > 0) {
                comparedDate?.forEach((dep) => {
                    if (!dep.fromdate && !dep.todate) {
                        return "";
                    }

                    if (!item?._doc?.doj) {
                        return "";
                    }

                    const [year2, month2, day2] = dojDate?.split("-").map(Number);
                    const joiningDate = new Date(year2, month2 - 1, day2);
                    const [year1, month1, day1] = dep.fromdate?.split("-").map(Number);
                    const [year, month, day] = dep.todate?.split("-").map(Number);
                    const lastDate = new Date(year, month - 1, day);
                    const firstDate = new Date(year1, month1 - 1, day1);

                    if (joiningDate < firstDate) {
                        // Check if the shift date is before or equal to the current date
                        if (lastDate >= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(firstDate);
                            // Loop through the dates in the range
                            while (startDate <= currentDateAttStatus) {
                                userDates.push({
                                    formattedDate: format(startDate, "dd/MM/yyyy"),
                                    dayName: format(startDate, "EEEE"),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        } else if (lastDate <= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(firstDate);
                            // Loop through the dates in the range
                            while (startDate <= lastDate) {
                                userDates.push({
                                    formattedDate: format(startDate, "dd/MM/yyyy"),
                                    dayName: format(startDate, "EEEE"),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        }
                    } else {
                        // Check if the shift date is before or equal to the current date
                        if (lastDate >= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(joiningDate);
                            // Loop through the dates in the range
                            while (startDate <= currentDateAttStatus) {
                                userDates.push({
                                    formattedDate: format(startDate, "dd/MM/yyyy"),
                                    dayName: format(startDate, "EEEE"),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        } else if (lastDate <= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(joiningDate);
                            // Loop through the dates in the range
                            while (startDate <= lastDate) {
                                userDates.push({
                                    formattedDate: format(startDate, "dd/MM/yyyy"),
                                    dayName: format(startDate, "EEEE"),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        }
                    }
                });
            } else {
                const [year2, month2, day2] = dojDate?.split("-").map(Number);
                const joiningDate = new Date(year2, month2 - 1, day2);
                // Calculate the start date of the month based on the selected month
                const startDate = new Date(isyear, ismonth - 1, 1);

                const endDate = new Date(startDate);
                endDate.setMonth(endDate.getMonth() + 1);
                endDate.setDate(endDate.getDate() - 1);

                if (joiningDate < startDate) {
                    // Check if the shift date is before or equal to the current date
                    if (endDate >= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            userDates.push({
                                formattedDate: format(currentDate1, "dd/MM/yyyy"),
                                dayName: format(currentDate1, "EEEE"),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    } else if (endDate <= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            userDates.push({
                                formattedDate: format(currentDate1, "dd/MM/yyyy"),
                                dayName: format(currentDate1, "EEEE"),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    }
                } else {
                    // Check if the shift date is before or equal to the current date
                    if (endDate >= currentDateAttStatus) {
                        // If matched, push the range from 'fromdate' to 'todate'
                        const startDate = new Date(joiningDate);
                        // Loop through the dates in the range
                        while (startDate <= currentDateAttStatus) {
                            userDates.push({
                                formattedDate: format(startDate, "dd/MM/yyyy"),
                                dayName: format(startDate, "EEEE"),
                                dayCount: startDate.getDate(),
                            });
                            startDate.setDate(startDate.getDate() + 1);
                        }
                    } else if (endDate <= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            userDates.push({
                                formattedDate: format(currentDate1, "dd/MM/yyyy"),
                                dayName: format(currentDate1, "EEEE"),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    }
                }
            }

            item.shiftallot?.map((allot) => {
                resultshiftallot.push({ ...allot });
            });

            // Map each user date to a row
            const userRows = userDates?.map((date) => {
                let filteredRowData = resultshiftallot?.filter((val) => val?._doc?.empcode == item?._doc?.empcode);
                const matchingItem = filteredRowData?.find((item) => item && item?._doc?.adjdate == date.formattedDate);
                const matchingItemAllot = filteredRowData?.find((item) => item && formatDate(item?._doc?.date) == date.formattedDate);
                const matchingDoubleShiftItem = filteredRowData?.find(item => item && item?._doc?.todate === date.formattedDate);
                const matchingRemovedItem = filteredRowData?.find(item => item?._doc?.removedshiftdate === date.formattedDate);
                const matchingAssignShiftItem = filteredRowData?.find(item => item?._doc?.adjdate === date.formattedDate && item?._doc?.adjstatus === 'Approved' && item?._doc?.adjustmenttype === 'Assign Shift');

                const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                    // return item;
                });


                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item?._doc?.weekoff?.includes(date.dayName);
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet) === "Week Off" ? true : false;

                if (isWeekOff) {
                    weekOffDates.push(date.formattedDate);
                }
                const updatedDatesBeforeWeekOffDates = [];
                const updatedDatesAfterWeekOffDates = [];

                weekOffDates.forEach((date) => {
                    const [day, month, year] = date?.split("/");
                    const currentDate = new Date(`${year}-${month}-${day}`);

                    // Get the day before
                    const dayBefore = new Date(currentDate);
                    dayBefore.setDate(currentDate.getDate() - 1);
                    const formattedDayBefore = `${dayBefore.getDate()}`.padStart(2, "0");
                    const formattedMonthBefore = `${dayBefore.getMonth() + 1}`.padStart(2, "0");
                    updatedDatesBeforeWeekOffDates.push(`${formattedDayBefore}/${formattedMonthBefore}/${dayBefore.getFullYear()}`);
                });

                weekOffDates.forEach((date) => {
                    const [day, month, year] = date?.split("/");
                    const currentDate = new Date(`${year}-${month}-${day}`);

                    // Get the day after
                    const dayAfter = new Date(currentDate);
                    dayAfter.setDate(currentDate.getDate() + 1);
                    const formattedDayAfter = `${dayAfter.getDate()}`.padStart(2, "0");
                    const formattedMonthAfter = `${dayAfter.getMonth() + 1}`.padStart(2, "0");
                    updatedDatesAfterWeekOffDates.push(`${formattedDayAfter}/${formattedMonthAfter}/${dayAfter.getFullYear()}`);
                });

                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                const row = {
                    id: `${item?._doc?._id.toString()}_${date.formattedDate} `,
                    userid: item?._doc?._id.toString(),
                    company: item?._doc?.company,
                    branch: item?._doc?.branch,
                    unit: item?._doc?.unit,
                    team: item?._doc?.team,
                    doj: dojDate,
                    department: relevantDepLogEntry && relevantDepLogEntry?.department,
                    username: item?._doc?.companyname,
                    empcode: item?._doc?.empcode,
                    weekoff: item?._doc?.weekoff,
                    boardingLog: item?._doc?.boardingLog,
                    shiftallot: item?._doc?.shiftallot,
                    shift: getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                    date: `${date.formattedDate} ${date.dayName} ${date.dayCount}`,
                    rowformattedDate: date.formattedDate,
                    dayName: date.dayName,

                    // updatedDatesBeforeWeekOffDates: updatedDatesBeforeWeekOffDates,
                    // updatedDatesAfterWeekOffDates: updatedDatesAfterWeekOffDates,
                    // weekOffDates: weekOffDates,
                    clockin: checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem)),
                    clockout: checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem)),
                    clockinstatus: checkClockInStatus(
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        graceTime, allLeaveStatus, holidays,
                        checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,), item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname,
                        earlyclockin, lateclockin, afterlateclockin, leavetype, permission,
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    clockoutstatus: checkClockOutStatus(
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem)),
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem)),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        clockOutHours,
                        checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate),
                        allLeaveStatus,
                        holidays,
                        item?._doc.branch,
                        item?._doc?.empcode,
                        item?._doc.company,
                        date.formattedDate,
                        item?._doc.unit,
                        item?._doc.team,
                        item?._doc.companyname,
                        onclockout,
                        earlyclockout,
                        beforeearlyclockout,
                        checkGetClockInAutoStatus(attendance, item?._doc?._id.toString(), date.formattedDate),
                        leavetype, permission, date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    lateclockincount: lateclockincount,
                    earlyclockoutcount: earlyclockoutcount,
                    totalnumberofdays: getTotalMonthDaysUser(item?._doc?.department, depMonthSet, ismonth, isyear),
                    empshiftdays: getTotalMonthDaysForEmpUser(dojDate, item?._doc?.department, depMonthSet, ismonth, isyear),
                    totalcounttillcurrendate: getTotalMonthsCurrentDateCountUser(dojDate, item?._doc?.department, depMonthSet, ismonth, isyear),
                    totalshift: getTotalShiftHoursUser(item?._doc?._id.toString(), userDates, attendance),
                    weekoffpresentstatus: checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                };
                return row;
            });

            return userRows;
        });

    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    if (!finaluser) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ finaluser });
});


exports.updateIntern = catchAsyncErrors(async (req, res, next) => {
    const id = req.params.id;


    let updatedTeamsArray, updatedChannelArray;
    const { rocketchatid, rocketchatroles, rocketchatteamid, rocketchatemail, rocketchatchannelid, companyname, username } = req.body;
    const singleUserData = await User.findById(id);
    let rocketChatUserDetails = {
        rocketchatemail: singleUserData?.rocketchatemail ?? "",
        rocketchatroles: singleUserData?.rocketchatroles?.length ? singleUserData?.rocketchatroles : [],
    };
    let isRocketchatLive = await checkRocketChatHealth();
    let updateRocketDetails = {};
    if (rocketchatid && isRocketchatLive) {
        let singleUserData = await getSingleUserData(rocketchatid)
        if (singleUserData?.userExist) {
            const { rocketchatteamids, rocketchatchannelids } = await findRocketChatTeamChannelIds(req.body);
            const teamUpdateResult = await updateUserRocketchatTeams(rocketchatid, rocketchatroles, rocketchatteamid, rocketchatteamids);
            updatedTeamsArray = teamUpdateResult?.updatedTeamsArray
            const channelUpdateResult = await updateUserRocketchatChannels(rocketchatid, rocketchatchannelid, rocketchatchannelids);
            updatedChannelArray = channelUpdateResult?.updatedChannelArray;
            const userDetailsUpdate = await updateRocketChatUserDetails(rocketchatid, companyname, rocketchatemail, false, username, rocketchatroles);
            rocketChatUserDetails.rocketchatemail = rocketchatemail;
            rocketChatUserDetails.rocketchatroles = userDetailsUpdate?.user?.roles;
        } else {
            await User.findByIdAndUpdate(id, {
                ...req.body,
                rocketchatid: "",
                rocketchatemail: "",
                rocketchatroles: [],
                rocketchatteamid: [],
                rocketchatchannelid: [],
            });
            return res.status(200).json({ message: "Updated successfully" });
        }

        updateRocketDetails = {
            rocketchatteamid: updatedTeamsArray,
            rocketchatchannelid: updatedChannelArray,
            rocketchatemail,
            rocketchatroles: rocketChatUserDetails?.rocketchatroles,
        }
    }
    const uuser = await User.findByIdAndUpdate(id, {
        ...req.body,
        ...updateRocketDetails
    });

    if (!uuser) {
        return next(new ErrorHandler("Data not found!", 404));
    }
    return res.status(200).json({ message: "Updated successfully" });
});




// get All user => /api/users
exports.getAllUsersLogin = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {
        users = await User.find(
            {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
                // resonablestatus: {
                //     $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                // },
            },
            {
                empcode: 1,
                companyname: 1,
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: users.length, users });
});
exports.usersLimitedEmpcode = catchAsyncErrors(async (req, res, next) => {
    let users;

    try {
        users = await User.find(
            {
                ...(req.body.id ? { _id: { $ne: req.body.id } } : {}),
            },
            {
                empcode: 1,
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: users.length, users });
});

exports.usersLimitedEmpcodeCreate = catchAsyncErrors(async (req, res, next) => {
    let userscreate;

    try {
        userscreate = await User.find({ branch: req.body.branch }, { empcode: 1 }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!userscreate) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: userscreate.length, userscreate });
});
exports.usersLimitedEmpcodeNonmanual = catchAsyncErrors(
    async (req, res, next) => {
        let users;

        try {
            users = await User.find(
                {
                    wordcheck: false,
                },
                {
                    empcode: 1,
                }
            );
        } catch (err) {
            return next(new ErrorHandler("Records not found!", 404));
        }

        if (!users) {
            return next(new ErrorHandler("Users not found", 400));
        }

        return res.status(200).json({ count: users.length, users });
    }
);
exports.getAllUserstatus = catchAsyncErrors(async (req, res, next) => {
    let usersstatus;

    try {
        usersstatus = await User.find(
            {},
            {
                status: 1,
                resonablestatus: 1,
                reasonname: 1,
                lastworkday: 1,
                rejoin: 1,
                reasonablestatusremarks: 1,
                department: 1,
                dob: 1,
                contactpersonal: 1,
                processlog: 1,
                boardingLog: 1, attendancemode: 1,
                designationlog: 1,
                company: 1,
                reasondate: 1,
                empreason: 1,
                percentage: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                usernameautogenerate: 1,
                workmode: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,
                addremoteworkmode: 1,

                unit: 1,
                branch: 1,
                department: 1,
                username: 1,
                designation: 1,
                team: 1,
                shift: 1,
                reportingto: 1,
                experience: 1,
                doj: 1,
                dot: 1,
                role: 1,
                bankname: 1,
                bankdetails: 1,
                bankbranchname: 1,
                accountholdername: 1,
                accountnumber: 1,
                ifsccode: 1,
                shifttiming: 1,
                shiftgrouping: 1,
                legalname: 1,
                callingname: 1,
                pdoorno: 1,
                pstreet: 1,
                parea: 1,
                plandmark: 1,
                ptaluk: 1,
                ppost: 1,
                ppincode: 1,
                pcountry: 1,
                pstate: 1,
                pcity: 1,
                cdoorno: 1,
                cstreet: 1,
                carea: 1,
                clandmark: 1,
                ctaluk: 1,
                cpost: 1,
                cpincode: 1,
                ccountry: 1,
                cstate: 1,
                ccity: 1,
                reasondate: 1,
                process: 1,
                workstation: 1,
                weekoff: 1,
                originalpassword: 1,
                enquirystatus: 1,
                area: 1,
                enableworkstation: 1,
                wordcheck: 1,
                shiftallot: 1,
                aadhar: 1,
                panno: 1,
                panstatus: 1,
                panrefno: 1,
                firstname: 1,
                lastname: 1,
                gender: 1,
                prefix: 1,

            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!usersstatus) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: usersstatus.length, usersstatus });
});

exports.getAllUsersexceldata = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {
        users = await User.find(
            {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
                resonablestatus: {
                    $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
            },
            {
                status: 1,
                resonablestatus: 1,
                reasonname: 1,
                lastworkday: 1,
                department: 1, workstationshortname: 1,
                dob: 1,
                location: 1,
                bloodgroup: 1,
                gender: 1,
                maritalstatus: 1,
                lastname: 1,
                contactpersonal: 1,
                processlog: 1,
                boardingLog: 1, attendancemode: 1,
                designationlog: 1,
                company: 1,
                addremoteworkmode: 1,
                reasondate: 1,
                empreason: 1,
                percentage: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                floor: 1,
                username: 1, usernamepc: 1,
                usernameautogenerate: 1,
                workmode: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,

                unit: 1,
                branch: 1,
                designation: 1,
                team: 1,
                shift: 1,
                reportingto: 1,
                experience: 1,
                doj: 1,
                dot: 1,
                role: 1,
                bankname: 1,
                bankdetails: 1,
                bankbranchname: 1,
                accountholdername: 1,
                accountnumber: 1,
                ifsccode: 1,
                shifttiming: 1,
                shiftgrouping: 1,
                legalname: 1,
                callingname: 1,
                pdoorno: 1,
                pstreet: 1,
                parea: 1,
                plandmark: 1,
                ptaluk: 1,
                ppost: 1,
                ppincode: 1,
                pcountry: 1,
                pstate: 1,
                pcity: 1,
                cdoorno: 1,
                cstreet: 1,
                carea: 1,
                clandmark: 1,
                ctaluk: 1,
                cpost: 1,
                cpincode: 1,
                ccountry: 1,
                cstate: 1,
                ccity: 1,
                reasondate: 1,
                process: 1,
                workstation: 1,
                weekoff: 1,
                originalpassword: 1,
                enquirystatus: 1,
                area: 1,
                enableworkstation: 1,
                wordcheck: 1,
                shiftallot: 1,
                twofaenabled: 1,
                fathername: 1,
                mothername: 1,
                firstname: 1,
                contactfamily: 1,
                emergencyno: 1,
                referencetodo: 1,
                contactno: 1,
                details: 1,
                assignExpLog: 1,
                pfesistatus: 1,
                status: 1,
                resonablestatus: 1,
                department: 1,
                dob: 1,
                location: 1,
                bloodgroup: 1,
                gender: 1,
                maritalstatus: 1,
                lastname: 1,
                contactpersonal: 1,
                processlog: 1,
                boardingLog: 1, attendancemode: 1,
                designationlog: 1,
                company: 1,
                reasondate: 1,
                empreason: 1,
                percentage: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                floor: 1,
                username: 1,
                usernameautogenerate: 1,
                workmode: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,

                unit: 1,
                branch: 1,
                designation: 1,
                team: 1,
                shift: 1,
                reportingto: 1,
                experience: 1,
                doj: 1,
                role: 1,
                bankname: 1,
                bankdetails: 1,
                bankbranchname: 1,
                accountholdername: 1,
                accountnumber: 1,
                ifsccode: 1,
                shifttiming: 1,
                shiftgrouping: 1,
                legalname: 1,
                callingname: 1,
                pdoorno: 1,
                pstreet: 1,
                parea: 1,
                plandmark: 1,
                ptaluk: 1,
                ppost: 1,
                ppincode: 1,
                pcountry: 1,
                pstate: 1,
                pcity: 1,
                cdoorno: 1,
                cstreet: 1,
                carea: 1,
                clandmark: 1,
                ctaluk: 1,
                cpost: 1,
                cpincode: 1,
                ccountry: 1,
                cstate: 1,
                ccity: 1,
                reasondate: 1,
                process: 1,
                workstation: 1,
                weekoff: 1,
                originalpassword: 1,
                enquirystatus: 1,
                area: 1,
                enableworkstation: 1,
                wordcheck: 1,
                shiftallot: 1,
                twofaenabled: 1,
                fathername: 1,
                mothername: 1,
                firstname: 1,
                contactfamily: 1,
                emergencyno: 1,
                referencetodo: 1,
                contactno: 1,
                details: 1,
                assignExpLog: 1,
                ipname: 1,
                pfmembername: 1,
                uan: 1,
                insurancenumber: 1,
                shiftallowancelog: 1,
                targetpointlog: 1,
                acheivedpointlog: 1,
                penaltylog: 1, workstation: 1, workstationshortname: 1, workstationinput: 1, usernamepc: 1
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }
    return res.status(200).json({ count: users.length, users });
});
// // view password => api/verification/viewpassword
// exports.viewpassword = catchAsyncErrors(async (req, res, next) => {
//     const { id, otp } = req.body;


//     // Finding if user exists in database
//     const user = await User.findById(id);
//     if (!user) {
//         return next(new ErrorHandler(" Username Not Found", 401));
//     }

//     const overallsettings = await AdminOverAllSettings.find();
//     let individualsettings = await IndividualSettings.find();
//     let individualtwofaswitch = individualsettings?.find((item) =>
//         item.companyname.includes(user?.companyname)
//     );
//     let adminTwofaswitch, loginswitch;
//     if (overallsettings.length === 0) {
//         adminTwofaswitch = true;
//         loginswitch = true;
//     } else {
//         adminTwofaswitch =
//             overallsettings[overallsettings.length - 1].overalltwofaswitch;
//         loginswitch =
//             overallsettings[overallsettings.length - 1].loginrestrictionswitch;
//     }

//     let check = individualtwofaswitch
//         ? individualtwofaswitch?.twofaswitch
//         : adminTwofaswitch;

//     // && !user.role.includes("Manager")

//     let foundData = user?.loginUserStatus?.find((data) => data?.status === "Active")

//     if (foundData?.twofaenabled && check) {
//         if (!otp) {
//             return res.status(201).json({
//                 otpneeded: true,
//             });
//         }
//         const verified = authenticator.check(otp, foundData?.twofasecret);

//         if (!verified) {
//             return next(new ErrorHandler("Kindly check your WinAuth QR code! Invalid Otp", 401));
//         }
//         return res.status(200).json({
//             success: true,
//         });
//     } else {
//         return res.status(200).json({
//             success: true,
//         });
//     }
// });

exports.viewpassword = catchAsyncErrors(async (req, res, next) => {
    const { id, otp } = req.body;


    // Finding if user exists in database
    const user = await User.findById(id);
    if (!user) {
        return next(new ErrorHandler(" Username Not Found", 401));
    }

    const overallsettings = await AdminOverAllSettings.find();
    let individualsettings = await IndividualSettings.find();
    let individualtwofaswitch = individualsettings?.find((item) =>
        item.companyname.includes(user?.companyname)
    );
    let adminTwofaswitch, loginswitch;
    if (overallsettings.length === 0) {
        adminTwofaswitch = true;
        loginswitch = true;
    } else {
        adminTwofaswitch =
            overallsettings[overallsettings.length - 1].overalltwofaswitch;
        loginswitch =
            overallsettings[overallsettings.length - 1].loginrestrictionswitch;
    }

    let check = individualtwofaswitch
        ? individualtwofaswitch?.twofaswitch
        : adminTwofaswitch;

    // && !user.role.includes("Manager")

    let foundData = user?.loginUserStatus?.find((data) => data?.status === "Active")

    if (foundData?.twofaenabled && check) {
        if (!otp) {
            return res.status(201).json({
                otpneeded: true,
            });
        }
        const verified = authenticator.check(otp, foundData?.twofasecret);

        if (!verified) {
            return next(new ErrorHandler("Invalid Otp", 401));
        }
        return res.status(200).json({
            success: true,
        });
    } else {
        return res.status(200).json({
            success: true,
        });
    }
});

// // get total holidays count based on the matched branch
const getTotalHolidaysMinFilter = (rowbranch, tempResultDates, holidays, empname, company, unit, team) => {
    let totalHolidayCount = 0;

    const totalHoliDays = holidays?.filter((d) =>
        d.applicablefor?.includes(rowbranch) && d.employee?.includes(empname)
        && d.company?.includes(company) && d.unit?.includes(unit) && d.team?.includes(team)
    );
    if (totalHoliDays) {
        tempResultDates && tempResultDates?.forEach((date) => {
            totalHoliDays.forEach((holi) => {
                if (formatDateLeaveDate(holi.date) === date.formattedDate) {
                    totalHolidayCount += Number(holi.noofdays);
                }
            });
        });
    }

    return totalHolidayCount;
};
// Add Shift Adjustment Details in user's shiftallot array after adjustment
exports.updateUsersShiftAllotObjects = catchAsyncErrors(
    async (req, res, next) => {
        try {
            const { shiftallotsarray } = req.body;

            // Construct an array of update operations for each item in changecheckedlabel
            const updateOperations = shiftallotsarray.map((changedShifts) => ({
                updateOne: {
                    filter: {
                        "shiftallot._id": changedShifts._id,
                    },
                    update: {
                        $set: {
                            "shiftallot.$.adjfirstshiftmode": changedShifts.adjfirstshiftmode,
                            "shiftallot.$.adjfirstshifttime": changedShifts.adjfirstshifttime,
                            "shiftallot.$.adjustmenttype": changedShifts.adjustmenttype,
                            "shiftallot.$.adjchangeshift": changedShifts.adjchangeshift,
                            "shiftallot.$.adjchangeshiftime": changedShifts.adjchangeshiftime,
                            "shiftallot.$.adjchangereason": changedShifts.adjchangereason,
                            "shiftallot.$.adjdate": changedShifts.adjdate,
                            "shiftallot.$.adjtypeshift": changedShifts.adjtypeshift,
                            "shiftallot.$.adjtypeshifttime": changedShifts.adjtypeshifttime,
                            "shiftallot.$.adjtypereason": changedShifts.adjtypereason,
                            "shiftallot.$.adjapplydate": changedShifts.adjapplydate,
                            "shiftallot.$.adjapplytime": changedShifts.adjapplytime,
                            "shiftallot.$.adjstatus": changedShifts.adjstatus,
                            "shiftallot.$.adjustmentstatus": changedShifts.adjustmentstatus,
                        },
                    },
                },
            }));

            // Execute the update operations one by one to check and update the matching 'Printed' statuses to 'Re-Printed'
            for (const operation of updateOperations) {
                const { filter, update } = operation.updateOne;

                const shiftallot = await User.findOne(filter);

                if (shiftallot) {
                    const product = shiftallot.shiftallot.id(filter["shiftallot._id"]);
                    await User.updateOne(filter, update);
                }
            }

            return res
                .status(200)
                .json({ message: "User Shift updated successfully" });
        } catch (err) {
            return next(new ErrorHandler("Error updating shift!", 500));
        }
    }
);

// Adjust status update "Not Approved" -> "Approved" or "Reject"
exports.updateUsersShiftAllotObjectsStatus = catchAsyncErrors(
    async (req, res, next) => {
        try {
            const { shiftallotsarray } = req.body;

            // Construct an array of update operations for each item in changecheckedlabel
            const updateOperations = shiftallotsarray.map((changedShifts) => ({
                updateOne: {
                    filter: {
                        "shiftallot._id": changedShifts._id,
                    },
                    update: {
                        $set: {
                            "shiftallot.$.adjstatus": changedShifts.adjstatus,
                        },
                    },
                },
            }));

            // Execute the update operations one by one to check and update the matching 'Printed' statuses to 'Re-Printed'
            for (const operation of updateOperations) {
                const { filter, update } = operation.updateOne;

                const shiftallot = await User.findOne(filter);

                if (shiftallot) {
                    const product = shiftallot.shiftallot.id(filter["shiftallot._id"]);
                    await User.updateOne(filter, update);
                }
            }

            return res
                .status(200)
                .json({ message: "User Shift Updated Successfully" });
        } catch (err) {
            return next(new ErrorHandler("Error updating shift!", 500));
        }
    }
);

//hrmanagers
exports.getHrManager = catchAsyncErrors(async (req, res, next) => {
    try {
        let query = {
            role: { $in: ["HiringManager", "HR"] },
            enquirystatus: {
                $nin: ["Enquiry Purpose"],
            },
            resonablestatus: {
                $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
            },
        };
        const hrmanagers = await User.find(query);
        if (!hrmanagers || hrmanagers.length === 0) {
            return next(new ErrorHandler("Hiring Managers not found", 404));
        }
        const hrman = hrmanagers.filter((d) => {
            return d.username;
        });
        return res.status(200).json({ hrman });
    } catch (err) {
        return next(new ErrorHandler("Internal Server Error", 500));
    }
});
// auth controller
// get Signle user => /api/auth/:id

exports.getSingleUserSignleRole = catchAsyncErrors(async (req, res, next) => {
    const suser = await User.findById(req.params.id, {
        role: 1,
        empcode: 1,
        companyname: 1,
        addedby: 1,
        updatedby: 1,
    });
    if (!suser) {
        return next(new ErrorHandler("User not found", 404));
    }
    return res.status(200).json({
        success: true,
        suser,
    });
});

// get All user => /api/users
exports.getAllUserscompanyname = catchAsyncErrors(async (req, res, next) => {
    let users;

    try {
        users = await User.find(
            {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
            },
            { empcode: 1, username: 1, companyname: 1 }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: users.length, users });
});

exports.getAttenddancefilter = catchAsyncErrors(async (req, res, next) => {
    let attandance;
    let attandancefilter;
    let allUsers;
    try {
        allUsers = await User.find(
            {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
                resonablestatus: {
                    $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
            },
            {
                username: 1,
                _id: 1,
                empcode: 1,
                profileimage: 1,
                companyname: 1,
                branch: 1,
                company: 1,
                unit: 1,
                team: 1,
                department: 1,
                resonablestatus: 1,
            }
        );

        let query = {};
        Object.keys(req.body).forEach((key) => {
            if (key !== "headers" && req.body[key].length > 0) {
                query[key] = req.body[key];
            }
        });

        // Filter the allUsers array based on the conditions provided in the query object
        attandance = allUsers.filter((item) => {
            return Object.keys(query).every((key) => {
                return query[key].includes(item[key]);
            });
        });

    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    if (!attandance) {
        return next(new ErrorHandler("Users not found", 400));
    }
    return res
        .status(200)
        .json({ count: attandance.length, attandancefilter: attandance });
});

exports.getAllUserAttMonthCountFilterLimited = catchAsyncErrors(async (req, res, next) => {

    let allAttandanceList;
    let allLeaveStatus;
    let resultshiftallot = [];
    let finaluserattmonth = [];
    const { ismonth, isyear, } = req.body;

    try {
        const [users, depMonthSet, holidays] = await Promise.all([
            User.find(
                {

                    resonablestatus: {
                        $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                    },
                }, {
                company: 1,
                branch: 1,
                unit: 1,
                team: 1,
                department: 1,
                doj: 1,
                dot: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                floor: 1,
                username: 1,
                designation: 1,
                weekoff: 1,
                shiftallot: 1,
                shifttiming: 1,
                boardingLog: 1, attendancemode: 1,
            }
            ),
            DepartmentMonth.find({}, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 }),
            Holiday.find({}, { date: 1, company: 1, applicablefor: 1, unit: 1, team: 1, employee: 1, noofdays: 1 }),
        ])
        const userCds = users.map(user => user.companyname);
        const userIds = users.map(user => user._id);
        allLeaveStatus = await ApplyLeave.find({ employeename: { $in: userCds } });

        allAttandanceList = await Attendance.find({ userid: { $in: userIds } });
        const monthNames = ["January", "February", "March", "April", "May", "June",
            "July", "August", "September", "October", "November", "December"
        ];

        finaluserattmonth = users?.map((item, index) => {
            let tempResultDates = [];

            item.shiftallot && item.shiftallot?.map(allot => {
                resultshiftallot.push({ ...allot })
            })

            // Define an array to store the resulting dates
            // const comparedDate = depMonthSet?.filter((d) => d.department === item.department && Number(d.year) === isyear && Number(d.month) === ismonth);

            // Remove duplicate entries with the most recent entry
            const uniqueEntriesDep = {};
            item.departmentlog?.forEach(entry => {
                const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                const key = entry.startdate;
                if (!(key in uniqueEntriesDep)) {
                    uniqueEntriesDep[key] = entry;
                }
            });
            const foundDepartment = depMonthSet?.find((d) => Number(d.year) === isyear && d.monthname === monthNames[ismonth - 1]);
            const uniqueDepLog = Object.values(uniqueEntriesDep);
            const relevantDepLogEntry = uniqueDepLog
                .filter(log => new Date(log.startdate) <= new Date(foundDepartment && foundDepartment.fromdate))
                .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

            const comparedDate = depMonthSet?.filter((d) => d.department === (relevantDepLogEntry && relevantDepLogEntry.department) && Number(d.year) === isyear && d.monthname === monthNames[ismonth - 1]);
            const dojDate = item?._doc?.boardingLog.length > 0 ?
                item?._doc?.boardingLog[0].startdate
                : item?._doc?.doj;

            if (comparedDate && comparedDate.length > 0) {
                comparedDate?.forEach((dep) => {
                    if (!dep.fromdate && !dep.todate) {
                        return '';
                    }

                    if (!item?._doc?.doj) {
                        return "";
                    }

                    const [year2, month2, day2] = dojDate?.split('-').map(Number);
                    const joiningDate = new Date(year2, month2 - 1, day2);
                    const [year1, month1, day1] = dep.fromdate?.split('-').map(Number);
                    const [year, month, day] = dep.todate?.split('-').map(Number);
                    const lastDate = new Date(year, month - 1, day);
                    const firstDate = new Date(year1, month1 - 1, day1);

                    if (joiningDate < firstDate) {
                        // Check if the shift date is before or equal to the current date
                        // if (lastDate >= currentDateAttStatus) {
                        //     // If matched, push the range from 'fromdate' to 'todate'
                        //     const startDate = new Date(firstDate);
                        //     // Loop through the dates in the range
                        //     while (startDate <= currentDateAttStatus) {
                        //         tempResultDates.push({
                        //             formattedDate: format(startDate, 'dd-MM-yyyy'),
                        //             dayName: format(startDate, 'EEEE'),
                        //             dayCount: startDate.getDate(),
                        //         });
                        //         startDate.setDate(startDate.getDate() + 1);
                        //     }
                        // } else if (lastDate <= currentDateAttStatus) {
                        // If matched, push the range from 'fromdate' to 'todate'
                        const startDate = new Date(firstDate);
                        // Loop through the dates in the range
                        while (startDate <= lastDate) {
                            tempResultDates.push({
                                formattedDate: format(startDate, 'dd-MM-yyyy'),
                                dayName: format(startDate, 'EEEE'),
                                dayCount: startDate.getDate(),
                            });
                            startDate.setDate(startDate.getDate() + 1);
                        }
                        // }
                    } else {
                        // Check if the shift date is before or equal to the current date
                        // if (lastDate >= currentDateAttStatus) {
                        //     // If matched, push the range from 'fromdate' to 'todate'
                        //     const startDate = new Date(joiningDate);
                        //     // Loop through the dates in the range
                        //     while (startDate <= currentDateAttStatus) {
                        //         tempResultDates.push({
                        //             formattedDate: format(startDate, 'dd-MM-yyyy'),
                        //             dayName: format(startDate, 'EEEE'),
                        //             dayCount: startDate.getDate(),
                        //         });
                        //         startDate.setDate(startDate.getDate() + 1);
                        //     }
                        // }
                        // else if (lastDate <= currentDateAttStatus) {
                        // If matched, push the range from 'fromdate' to 'todate'
                        const startDate = new Date(joiningDate);
                        // Loop through the dates in the range
                        while (startDate <= lastDate) {
                            tempResultDates.push({
                                formattedDate: format(startDate, 'dd-MM-yyyy'),
                                dayName: format(startDate, 'EEEE'),
                                dayCount: startDate.getDate(),
                            });
                            startDate.setDate(startDate.getDate() + 1);
                        }
                    }
                    // }
                });
            }
            else {
                const [year2, month2, day2] = dojDate?.split('-').map(Number);
                const joiningDate = new Date(year2, month2 - 1, day2);
                // Calculate the start date of the month based on the selected month
                const startDate = new Date(isyear, ismonth - 1, 1);

                const endDate = new Date(startDate);
                endDate.setMonth(endDate.getMonth() + 1);
                endDate.setDate(endDate.getDate() - 1);

                if (joiningDate < startDate) {
                    // Check if the shift date is before or equal to the current date
                    // if (endDate >= currentDateAttStatus) {
                    //     let currentDate1 = new Date(startDate);

                    //     while (currentDate1 <= endDate) {
                    //         tempResultDates.push({
                    //             formattedDate: format(currentDate1, 'dd-MM-yyyy'),
                    //             dayName: format(currentDate1, 'EEEE'),
                    //             dayCount: currentDate1.getDate(),
                    //         });
                    //         currentDate1.setDate(currentDate1.getDate() + 1);
                    //     }
                    // } else if (endDate <= currentDateAttStatus) {
                    let currentDate1 = new Date(startDate);

                    while (currentDate1 <= endDate) {
                        tempResultDates.push({
                            formattedDate: format(currentDate1, 'dd-MM-yyyy'),
                            dayName: format(currentDate1, 'EEEE'),
                            dayCount: currentDate1.getDate(),
                        });
                        currentDate1.setDate(currentDate1.getDate() + 1);
                    }
                    // }
                } else {
                    // Check if the shift date is before or equal to the current date
                    // if (endDate >= currentDateAttStatus) {
                    //     // If matched, push the range from 'fromdate' to 'todate'
                    //     const startDate = new Date(joiningDate);
                    //     // Loop through the dates in the range
                    //     while (startDate <= currentDateAttStatus) {
                    //         tempResultDates.push({
                    //             formattedDate: format(startDate, 'dd-MM-yyyy'),
                    //             dayName: format(startDate, 'EEEE'),
                    //             dayCount: startDate.getDate(),
                    //         });
                    //         startDate.setDate(startDate.getDate() + 1);
                    //     }
                    // } else if (endDate <= currentDateAttStatus) {
                    let currentDate1 = new Date(startDate);

                    while (currentDate1 <= endDate) {
                        tempResultDates.push({
                            formattedDate: format(currentDate1, 'dd-MM-yyyy'),
                            dayName: format(currentDate1, 'EEEE'),
                            dayCount: currentDate1.getDate(),
                        });
                        currentDate1.setDate(currentDate1.getDate() + 1);
                    }
                }
                // }
            }

            item.shiftallot?.map(allot => {
                resultshiftallot.push({ ...allot })
            })

            const dayshift = tempResultDates?.map((column, index) => {
                let filteredRowData = resultshiftallot?.filter((val) => val.empcode === item?._doc?.empcode);
                const matchingItem = filteredRowData?.find(item => item && formatAdjDate(item.adjdate) === column.formattedDate);
                const matchingItemAllot = filteredRowData?.find(item => item && formatDateForShiftDate(item.date) === column.formattedDate);
                const matchingDoubleShiftItem = filteredRowData?.find(item => item && item?._doc?.todate === date.formattedDate);
                const matchingRemovedItem = filteredRowData?.find(item => item?._doc?.removedshiftdate === date.formattedDate);
                const matchingAssignShiftItem = filteredRowData?.find(item => item?._doc?.adjdate === date.formattedDate && item?._doc?.adjstatus === 'Approved' && item?._doc?.adjustmenttype === 'Assign Shift');

                const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                    // return item;
                });

                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item?._doc?.weekoff?.includes(column.dayName);
                const isWeekOff = getWeekOffDay(column, filterBoardingLog, item?._doc?.departmentlog, depMonthSet) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                return {
                    userid: item?._doc?._id.toString(),
                    date: column?.formattedDate,
                    empCode: item?._doc?.empcode,
                    shiftlabel: getShiftForDateAttMonthStatus(column, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                }
            })

            const userData = {
                // _id: item?._doc?._id.toString(),
                // userid: item?._doc?._id.toString(),
                company: item?._doc?.company,
                branch: item?._doc?.branch,
                unit: item?._doc?.unit,
                team: item?._doc?.team,
                doj: dojDate,
                department: relevantDepLogEntry && relevantDepLogEntry.department,
                username: item?._doc?.companyname,
                empcode: item?._doc?.empcode,

                totalnumberofdays: getTotalMonthDays(item?._doc?.department, depMonthSet, ismonth, isyear),
                // empshiftdays: getTotalMonthDaysForEmp(dojDate, item?._doc?.department, depMonthSet, ismonth, isyear),
                // totalcounttillcurrendate: getTotalMonthsCurrentDateCount(dojDate, item?._doc?.department, depMonthSet, ismonth, isyear),
                // totalshift: getTotalShiftHours(item?._doc?._id.toString(), tempResultDates, allAttandanceList),
                // clsl: getTotalApprovedLeave(item?._doc?.empcode, tempResultDates, allLeaveStatus),
                weekoff: getTotalWeekOff(item?._doc?.empcode, dayshift),
                holiday: getTotalHolidays(item?._doc?.company, item?._doc?.branch, item?._doc?.unit, item?._doc?.team, item?._doc?.companyname, tempResultDates, holidays),
                // totalabsentleave: getTotalAbsentLeave(item?._doc?._id.toString(), item?._doc?.empcode, dayshift, getTotalApprovedLeave(item?._doc?.empcode, tempResultDates, allLeaveStatus), getTotalHolidays(item?._doc?.company, item?._doc?.branch, item?._doc?.unit, item?._doc?.team, item?._doc?.companyname, tempResultDates, holidays), allLeaveStatus, allAttandanceList, ismonth, isyear),
                // totalpaiddays: getTotalPaidDays(getTotalShiftHours(item?._doc?._id.toString(), tempResultDates, allAttandanceList), getTotalApprovedLeave(item?._doc?.empcode, tempResultDates, allLeaveStatus), getTotalWeekOff(item?._doc?.empcode, dayshift), getTotalHolidays(item?._doc?.company, item?._doc?.branch, item?._doc?.unit, item?._doc?.team, item?._doc?.companyname, tempResultDates, holidays))
            }
            return userData;
        });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finaluserattmonth) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ finaluserattmonth });
});


// get All user => /api/users  assingedby profile pic
exports.getAllUserstaskProfile = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {
        users = await User.findById(req.body.userprofile);
        return res.status(200).json({ users });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

});

exports.getAllUserslimit = catchAsyncErrors(async (req, res, next) => {
    let users;

    try {
        users = await User.find(
            {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
                resonablestatus: {
                    $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
            },
            {
                department: 1,
                company: 1,
                empcode: 1,
                companyname: 1,
                username: 1,
                role: 1,
                branch: 1,
                unit: 1,
                designation: 1,
                team: 1,
                doj: 1,
                dot: 1,
                floor: 1, area: 1, workstation: 1
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: users.length, users });
});

exports.getAllAddEmployeeLimit = catchAsyncErrors(async (req, res, next) => {
    const { page = 1, limit = 1, sizename, sort, search } = req.query;

    const filters = {
        enquirystatus: {
            $nin: ["Enquiry Purpose"],
        },
    };
    if (sizename) {
        filters.sizename = sizename;
    }

    const query = User.find(filters);

    if (search) {
        query.where({ name: { $regex: search, $options: "i" } });
    }

    if (sort) {
        const [field, order] = sort?.split(":");
        query.sort({ [field]: order === "desc" ? -1 : 1 });
    }
    try {
        const items = await query.skip((page - 1) * limit).limit(+limit);
        const totalCount = await User.countDocuments(filters);

        if (!items) {
            return next(new ErrorHandler("Data not found!", 404));
        }

        return res.status(200).json({
            items,
            totalPages: Math.ceil(totalCount / limit),
        });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
});

const createUserAndAddToTeamsAndGroups = async (userData, teamIds, groupIds) => {
    try {
        // Step 1: Log in to Rocket.Chat
        const { authToken, userId, rocketchatdomainurl } = await rocketChatLogin();

        // Step 2: Create the user
        const userResponse = await axios.post(
            `${rocketchatdomainurl}/api/v1/users.create`,
            {
                name: userData.name,
                email: userData.email,
                password: userData.password,
                username: userData.username,
                active: userData.active || true,
                nickname: userData.nickname || "",
                // bio: userData.bio,
                joinDefaultChannels: userData.joinDefaultChannels || true,
                // statusText: userData.statusText,
                roles: userData.roles || ["user"],
                requirePasswordChange: userData.requirePasswordChange || false,
                setRandomPassword: userData.setRandomPassword || false,
                sendWelcomeEmail: false,
                verified: userData.verified || false,
                customFields: userData.customFields || {}
            },
            {
                headers: {
                    "X-Auth-Token": authToken,
                    "X-User-Id": userId,
                    "Content-Type": "application/json",
                },
            }
        );

        const newUserId = userResponse.data.user._id; // Get the newly created user's ID

        // Step 3: Add the user to specified teams
        for (const teamId of teamIds) {
            await axios.post(
                `${rocketchatdomainurl}/api/v1/teams.addMembers`,
                {
                    teamId: teamId,
                    members: [
                        {
                            userId: newUserId,
                            roles: userData.roles || ["member"], // Adjust roles as needed
                        },
                    ],
                },
                {
                    headers: {
                        "X-Auth-Token": authToken,
                        "X-User-Id": userId,
                        "Content-Type": "application/json",
                    },
                }
            );
        }

        // Step 4: Invite the user to specified groups
        for (const groupId of groupIds) {
            await axios.post(
                `${rocketchatdomainurl}/api/v1/groups.invite`,
                {
                    roomId: groupId,
                    userId: newUserId,
                },
                {
                    headers: {
                        "X-Auth-Token": authToken,
                        "X-User-Id": userId,
                        "Content-Type": "application/json",
                    },
                }
            );
        }

        return {
            message: "User created, added to teams, and invited to groups successfully",
            user: userResponse.data.user,
            teamIds, groupIds
        };
    } catch (error) {
        throw new ErrorHandler(
            error.response?.data?.message || "Failed to create user, add to teams, or invite to groups",
            error.response?.status || 500
        );
    }
};


const updateUserRocketchatTeams = async (rocketChatUserId, rocketChatUserRole, array1, array2) => {
    try {
        // array1 is from user
        //array2 is from grouping
        // Step 1: Log in to Rocket.Chat
        const { authToken, userId, rocketchatdomainurl } = await rocketChatLogin();

        // Step 2: Identify teams to add and remove based on array comparison
        const teamsToAdd = array2.filter(teamId => !array1.includes(teamId));
        const teamsToRemove = array1.filter(teamId => !array2.includes(teamId));

        // Step 3: Add the user to the teams in `teamsToAdd`
        for (const teamId of teamsToAdd) {
            await axios.post(
                `${rocketchatdomainurl}/api/v1/teams.addMembers`,
                {
                    teamId: teamId,
                    members: [
                        {
                            userId: rocketChatUserId,
                            roles: rocketChatUserRole || ["member"], // Adjust roles if needed
                        },
                    ],
                },
                {
                    headers: {
                        "X-Auth-Token": authToken,
                        "X-User-Id": userId,
                        "Content-Type": "application/json",
                    },
                }
            );

            // Add the team ID to array1 after adding to team
            array1.push(teamId);
        }

        // Step 4: Remove the user from the teams in `teamsToRemove`
        for (const teamId of teamsToRemove) {
            await axios.post(
                `${rocketchatdomainurl}/api/v1/teams.removeMember`,
                {
                    teamId: teamId,
                    userId: rocketChatUserId,
                },
                {
                    headers: {
                        "X-Auth-Token": authToken,
                        "X-User-Id": userId,
                        "Content-Type": "application/json",
                    },
                }
            );
            // Remove the team ID from array1 after removing from team
            const index = array1.indexOf(teamId);
            if (index > -1) {
                array1.splice(index, 1);
            }

        }

        return {
            message: "User's team memberships updated successfully",
            addedToTeams: teamsToAdd,
            removedFromTeams: teamsToRemove,
            updatedTeamsArray: array1 // Return the updated array1
        };
    } catch (error) {
        throw new ErrorHandler(
            error.response?.data?.message || "Failed to update user teams",
            error.response?.status || 500
        );
    }
};
const updateUserRocketchatChannels = async (rocketChatUserId, array1, array2) => {
    try {
        // array1 is from user
        //array2 is from grouping
        // Step 1: Log in to Rocket.Chat
        const { authToken, userId, rocketchatdomainurl } = await rocketChatLogin();

        // Step 2: Identify teams to add and remove based on array comparison
        const groupsToAdd = array2.filter(groupId => !array1.includes(groupId));
        const groupsToRemove = array1.filter(groupId => !array2.includes(groupId));

        // Step 3: Add the user to the teams in `groupsToAdd`
        for (const groupId of groupsToAdd) {
            await axios.post(
                `${rocketchatdomainurl}/api/v1/groups.invite`,
                {
                    roomId: groupId,
                    userId: rocketChatUserId,
                },
                {
                    headers: {
                        "X-Auth-Token": authToken,
                        "X-User-Id": userId,
                        "Content-Type": "application/json",
                    },
                }
            );
            // Add the group ID to array1 after adding to group
            array1.push(groupId);
        }

        // Step 4: Remove the user from the teams in `groupsToRemove`
        for (const groupId of groupsToRemove) {
            await axios.post(
                `${rocketchatdomainurl}/api/v1/groups.kick`,
                {
                    roomId: groupId,
                    userId: rocketChatUserId,
                },
                {
                    headers: {
                        "X-Auth-Token": authToken,
                        "X-User-Id": userId,
                        "Content-Type": "application/json",
                    },
                }
            );
            // Remove the group ID from array1 after removing from group
            const index = array1.indexOf(groupId);
            if (index > -1) {
                array1.splice(index, 1);
            }
        }

        return {
            message: "User's Channel memberships updated successfully",
            addedToChannels: groupsToAdd,
            removedFromChannels: groupsToRemove,
            updatedChannelArray: array1 // Return the updated array1
        };
    } catch (error) {
        throw new ErrorHandler(
            error.response?.data?.message || "Failed to update user channels",
            error.response?.status || 500
        );
    }
};

const findRocketChatTeamChannelIds = async (body) => {
    const { company, branch, unit, team, department, designation, companyname, workmode, process, rocketchatshiftgrouping, rocketchatshift } = body;
    let rocketWorkMode = workmode === "Remote" ? "Remote" : "Office";
    const pipeline = [
        {
            $match: {
                $or: [
                    {
                        type: "Company",
                        company: { $in: [company] },
                        workmode: { $in: [rocketWorkMode] },
                    },
                    {
                        type: "Branch",
                        company: { $in: [company] },
                        branch: { $in: [branch] },
                        workmode: { $in: [rocketWorkMode] },
                    },
                    {
                        type: "Unit",
                        company: { $in: [company] },
                        branch: { $in: [branch] },
                        unit: { $in: [unit] },
                        workmode: { $in: [rocketWorkMode] },
                    },
                    {
                        type: "Team",
                        company: { $in: [company] },
                        branch: { $in: [branch] },
                        unit: { $in: [unit] },
                        team: { $in: [team] },
                        workmode: { $in: [rocketWorkMode] },
                    },
                    {
                        type: "Department",
                        company: { $in: [company] },
                        branch: { $in: [branch] },
                        unit: { $in: [unit] },
                        department: { $in: [department] },
                        workmode: { $in: [rocketWorkMode] },
                    },
                    {
                        type: "Designation",
                        company: { $in: [company] },
                        branch: { $in: [branch] },
                        unit: { $in: [unit] },
                        designation: { $in: [designation] },
                        workmode: { $in: [rocketWorkMode] },
                    },
                    {
                        type: "Individual",
                        company: { $in: [company] },
                        branch: { $in: [branch] },
                        unit: { $in: [unit] },
                        team: { $in: [team] },
                        employeename: { $in: [companyname] },
                        workmode: { $in: [rocketWorkMode] },
                    },
                    {
                        type: "VPN Type",
                        company: { $in: [company] },
                        branch: { $in: [branch] },
                        unit: { $in: [unit] },
                        team: { $in: [team] },
                        employeename: { $in: [companyname] },
                        workmode: { $in: [rocketWorkMode] },
                    },
                    {
                        type: "Process",
                        company: { $in: [company] },
                        branch: { $in: [branch] },
                        unit: { $in: [unit] },
                        team: { $in: [team] },
                        process: { $in: [process] },
                        workmode: { $in: [rocketWorkMode] },
                    },
                    {
                        type: "Shift",
                        company: { $in: [company] },
                        branch: { $in: [branch] },
                        unit: { $in: [unit] },
                        team: { $in: [team] },
                        workmode: { $in: [rocketWorkMode] },
                        shiftgrouping: { $in: rocketchatshiftgrouping },
                        shift: { $in: rocketchatshift },
                    },
                ],
            },
        },
        {
            $project: {
                rocketchatteamid: 1,
                rocketchatchannelid: 1,
            },
        },
    ];

    try {
        const results = await rocketChatTeamChannelGrouping.aggregate(pipeline);

        // Concatenate all values of rocketchatteamid and rocketchatchannelid into separate arrays
        const allRocketChatTeamIds = results.flatMap((doc) => doc.rocketchatteamid || []);
        const allRocketChatChannelIds = results.flatMap((doc) => doc.rocketchatchannelid || []);

        // Remove duplicates
        const uniqueRocketChatTeamIds = [...new Set(allRocketChatTeamIds)];
        const uniqueRocketChatChannelIds = [...new Set(allRocketChatChannelIds)];

        return {
            rocketchatteamids: uniqueRocketChatTeamIds || [],
            rocketchatchannelids: uniqueRocketChatChannelIds || [],
        };
    } catch (error) {
        throw error;
    }
};


exports.regAuth = catchAsyncErrors(async (req, res, next) => {
    const {
        prefix,
        rejoineduser,
        rejoineddetails,
        firstname,
        lastname,
        legalname,
        callingname,
        fathername,
        mothername,
        gender,
        maritalstatus,
        dob,
        username,
        usernameautogenerate,
        workmode,
        password, religion,
        autogeneratepassword, passexpdate, newEmployeePassUpdateCheck,
        status,
        percentage,
        bloodgroup,
        profileimage,
        location,
        email,
        employeecount,
        systemmode,
        addremoteworkmode,
        companyemail,
        resetstatus, extratime, extrastatus, extratimestatus, extradate, extraTimeStatus,
        contactpersonal,
        contactfamily,
        emergencyno,
        doj,
        dot,
        referencetodo,
        contactno,
        details,
        companyname,
        pdoorno,
        pstreet,
        parea,
        plandmark,
        ptaluk,
        ppost,
        ppincode,
        pcountry,
        pstate,
        aadhar,
        panno,
        panstatus,
        panrefno,
        pcity,
        cdoorno,
        cstreet,
        carea,
        clandmark,
        ctaluk,
        cpost,
        cpincode,
        ccountry,
        cstate,
        ccity,
        branch,
        unit,
        samesprmnt,
        addedby,
        updatedby,
        floor,
        company,
        experience,
        department,
        team,
        designation,
        shifttiming,
        shiftgrouping,
        reportingto,
        empcode,
        remark,
        dom,
        accesslocation,
        workstation,
        weekoff,
        assignExpMode,
        assignExpvalue,
        assignExpDate,
        esideduction,
        pfdeduction,
        uan,
        pfmembername,
        insurancenumber,
        ipname,
        pfesifromdate,
        isenddate,
        pfesienddate,
        originalpassword,
        enquirystatus,
        area,
        enableworkstation,
        wordcheck,
        shiftallot,
        files,
        eduTodo,
        addAddQuaTodo,
        workhistTodo,
        //draft,
        modeOfInt,
        intDuration,
        intCourse,
        intStartDate,
        intEndDate,
        clickedGenerate,
        role,
        bankname,
        bankdetails,
        bankbranchname,
        accountholdername,
        accountnumber,
        ifsccode,
        assignExpLog,
        departmentlog,
        designationlog,
        boardingLog,
        processlog,
        salarycode,
        salarysetup,
        basic,
        hra,
        conveyance,
        medicalallowance,
        productionallowance,
        otherallowance,
        productionallowancetwo,
        ctc, mode, rejoin,
        shifttype,
        reasonablestatusremarks,
        endexp,
        endtardate,
        endtar,
        assignEndExp,


        assignEndExpDate,
        assignEndTar,
        assignEndTarDate,
        process,
        processtype,
        processduration,
        date,
        time,

        grosssalary,
        timemins,
        modeexperience,
        targetexperience,
        expval,
        expmode,
        targetpts,
        workstationofficestatus,
        workstationinput,
        attendancemode,

        createrocketchat,
        rocketchatemail,
        rocketchatroles, faceDescriptor
    } = req.body;
    if (!username || !password) {
        return next(new ErrorHandler("Please fill all fields", 400));
    }
    // encrypt password before saving
    const salt = await bcrypt.genSalt(10);
    const hashPassword = await bcrypt.hash(password, salt);
    const newUserData = {
        name: companyname,
        email: rocketchatemail,
        password: password,
        username: username,
        active: true,
        nickname: callingname,
        // bio: "All about the user",
        joinDefaultChannels: true,
        // statusText: "On a vacation",
        roles: rocketchatroles,
        // requirePasswordChange: true,
        // setRandomPassword: true,
        sendWelcomeEmail: true,
        verified: false,
        // customFields: {
        //     clearance: "High",
        //     team: "Queen"
        // }
    };
    let rocketChatData;
    let isRocketchatLive = await checkRocketChatHealth();
    if (createrocketchat && isRocketchatLive) {

        const { rocketchatteamids, rocketchatchannelids } = await findRocketChatTeamChannelIds(req.body)
        rocketChatData = await createUserAndAddToTeamsAndGroups(newUserData, rocketchatteamids, rocketchatchannelids)
    }
    const user = await User.create({
        rejoineduser: rejoineduser || '',
        rejoineddetails: rejoineddetails?.length > 0 ? rejoineddetails : [],
        rocketchatid: (createrocketchat && isRocketchatLive) ? rocketChatData?.user?._id : "",
        rocketchatemail: (createrocketchat && isRocketchatLive) ? rocketchatemail : "",
        rocketchatroles: (createrocketchat && isRocketchatLive) ? rocketChatData?.user?.roles : [],
        rocketchatteamid: (createrocketchat && isRocketchatLive) ? rocketChatData?.teamIds : [],
        rocketchatchannelid: (createrocketchat && isRocketchatLive) ? rocketChatData?.groupIds : [],
        prefix,
        username,
        usernameautogenerate,
        workmode,
        lastname,
        email,
        employeecount,
        systemmode, religion,
        companyemail, passexpdate, newEmployeePassUpdateCheck,
        addremoteworkmode,
        resetstatus, extratime, extrastatus, extratimestatus, extradate, extraTimeStatus,
        firstname,
        legalname,
        callingname,
        fathername,
        mothername,
        gender,
        maritalstatus,
        dob,
        dom,
        //draft,
        status,
        percentage,
        bloodgroup,
        profileimage,
        location,
        email,
        employeecount,
        systemmode,
        companyemail, resetstatus, extratime, extrastatus, extratimestatus, extradate, extraTimeStatus,
        contactpersonal,
        contactfamily,
        emergencyno,
        doj,
        rejoin,
        reasonablestatusremarks,
        dot,
        referencetodo,
        contactno,
        details,
        companyname,
        addremoteworkmode,
        pdoorno,
        pstreet,
        parea,
        plandmark,
        ptaluk,
        ppost,
        ppincode,
        pcountry,
        pstate,
        aadhar,
        panno,
        panstatus,
        panrefno,
        pcity,
        cdoorno,
        cstreet,
        carea,
        clandmark,
        ctaluk,
        cpost,
        cpincode,
        ccountry,
        cstate,
        ccity,
        branch,
        unit,
        floor,
        samesprmnt,
        experience,
        addedby,
        updatedby,
        department,
        team,
        //draft,
        designation,
        shifttiming,
        shiftgrouping,
        reportingto,
        empcode,
        remark,
        accesslocation,
        workstation,
        weekoff,
        assignExpMode,
        assignExpvalue,
        assignExpDate,
        esideduction,
        pfdeduction,
        uan,
        pfmembername,
        insurancenumber,
        ipname,
        pfesifromdate,
        isenddate,
        pfesienddate,
        originalpassword,
        enquirystatus,
        area,
        enableworkstation,
        wordcheck,
        shiftallot,
        files,
        eduTodo,
        company,
        addAddQuaTodo,
        workhistTodo,
        modeOfInt,
        intDuration,
        intCourse,
        intStartDate,
        intEndDate,
        clickedGenerate,
        role,
        bankname,
        bankdetails,
        bankbranchname,
        accountholdername,
        accountnumber,
        ifsccode,
        password: hashPassword,
        autogeneratepassword,
        assignExpLog,
        departmentlog,
        designationlog,
        boardingLog,
        processlog,
        employeecount,
        salarycode,
        salarysetup,
        basic,
        hra,
        conveyance,
        medicalallowance,
        productionallowance,
        otherallowance,
        productionallowancetwo,
        ctc, mode, assignExpMode,
        assignExpvalue,
        assignExpDate,
        shifttype,
        endexp,
        endtardate,
        endtar,
        assignEndExp,


        assignEndExpDate,
        assignEndTar,
        assignEndTarDate,
        process,
        processtype,
        processduration,
        date,
        time,

        grosssalary,
        timemins,
        modeexperience,
        targetexperience,
        expval,
        expmode,
        targetpts,
        workstationofficestatus,
        workstationinput,
        attendancemode, faceDescriptor
    });

    const token = await new Token({
        userId: user._id,
        token: crypto.randomBytes(32).toString("hex"),
    }).save();

    const url = `http://anubhuthi.org/${user._id}/verify/${token.token}`;
    await sendVerificationEmail(user.email, "Verify Email", url);

    return res.status(201).json({
        success: true,
        user,
    });
});

// Login user => api/users
exports.loginAuth = catchAsyncErrors(async (req, res, next) => {
    const { username, password, otp, publicIP } = req.body;
    const resonablestatusarray = [
        "Absconded",
        "Hold",
        "Terminate",
        "Releave Employee",
        "Not Joined",
        "Postponed",
        "Rejected",
        "Closed",
    ];
    // Check if email & password entered by user
    if (!username || !password) {
        return next(new ErrorHandler("Please enter username and password", 400));
    }

    // Finding if user exists in database
    const user = await User.findOne({ username }).select("+password");
    if (!user) {
        return next(new ErrorHandler("Invalid Username or Password", 401));
    }

    // If checks password is correct or not
    const isPwdMatched = await bcrypt.compare(password, user.password);

    if (!isPwdMatched) {
        return next(new ErrorHandler("Invalid Password", 401));
    }
    if (resonablestatusarray.includes(user?.resonablestatus)) {
        return next(new ErrorHandler("Login Restricted", 401));
    }

    // if(!user.emailverification && !user.role.includes("Manager")){
    //   let token = await Token.findOne({userId:user._id});
    //   if(!token){
    //     token = await new Token({
    //       userId: user._id,
    //       token:crypto.randomBytes(32).toString("hex")
    //     }).save();

    //     const url = `http://anubhuthi.org/${user._id}/verify/${token.token}`;
    //     await sendVerificationEmail(user.email,"Verify Email",url)
    //   }
    //   return next(new ErrorHandler('An email has been sent to your account for verification. Please verify your email.', 400));
    // }

    const overallsettings = await AdminOverAllSettings.find();
    const clockinip = await ClockinIP.find({ branch: user?.branch });
    let individualsettings = await IndividualSettings.find();
    let individualtwofaswitch = individualsettings?.find((item) =>
        item.companyname.includes(user?.companyname)
    );
    let adminTwofaswitch, loginswitch;
    if (overallsettings.length === 0) {
        adminTwofaswitch = true;
        loginswitch = true;
    } else {
        adminTwofaswitch =
            overallsettings[overallsettings.length - 1].overalltwofaswitch;
        loginswitch =
            overallsettings[overallsettings.length - 1].loginrestrictionswitch;
    }

    let check = individualtwofaswitch
        ? individualtwofaswitch?.twofaswitch
        : adminTwofaswitch;
    let checkLogin = individualtwofaswitch
        ? individualtwofaswitch?.loginipswitch
        : loginswitch;
    var logincheck;
    if (clockinip?.length === 0) {
        logincheck = "NOTSHOW";
    } else {
        logincheck = "SHOW";
    }
    const isIpInData = clockinip?.some((entry) =>
        entry.ipaddress.includes(publicIP)
    );
    if (
        checkLogin &&
        !user.role.includes("Manager") &&
        logincheck === "SHOW" &&
        !isIpInData
    ) {
        //return next(new ErrorHandler("Login Restricted", 401));
    }

    if (!user.twofaenabled && check && !user.role.includes("Manager")) {
        const secret = authenticator.generateSecret();
        const uri = authenticator.keyuri(user?.companyname, "HILIFE.AI", secret);
        const image = await qrcode.toDataURL(uri);
        user["twofatempsecret"] = secret;
        const result = await user.save();
        return res.status(201).json({
            generateqr: true,
            image,
            result,
        });
    } else if (user.twofaenabled && check && !user.role.includes("Manager")) {
        if (!otp) {
            return res.status(201).json({
                otpneeded: true,
            });
        }
        const verified = authenticator.check(otp, user.twofasecret);

        if (!verified) {
            return next(new ErrorHandler("Kindly check your WinAuth QR code! Invalid Otp", 401));
        }
        sendToken(user, 200, res);
    } else {
        sendToken(user, 200, res);
    }
});




// exports.logincheckAuth = catchAsyncErrors(async (req, res, next) => {
//     let resversion = false;
//     let appUpdateCalculation = 7
//     try {
//         const {
//             username,
//             password,
//             otp,
//             publicIP,
//             macAddress,
//             systemname,
//             currenturl,
//             localIp,
//             hostname,
//             version,
//             applogin,
//         } = req.body;
//         let MatchedNotMatched;
//         let controlcriteria;
//         let holidayWeekOffRestriction;
//         let userCheckInControlCriteria;
//         resversion = version === "1.11.0" ? true : resversion = version === "1.10.0" ? true : resversion = version === "1.12.0" ? true : resversion = version === "1.13.0" ? true : false



//         // let hostname = "TT_1_U4_G-HRA";
//         const resonablestatusarray = [
//             "Absconded",
//             "Hold",
//             "Terminate",
//             "Releave Employee",
//             "Not Joined",
//             "Postponed",
//             "Rejected",
//             "Closed",
//         ];
//         //version mismatch
//         if (!username || !password) {
//             return next(new ErrorHandler("Please enter username and password", 400));
//         }
//         // Check if email & password entered by user
//         if (applogin === true && version !== "1.8.0" && version !== "1.9.0" && version !== "1.11.0" && version !== "1.10.0" && version !== "1.12.0" && version !== "1.13.0") {
//             return next(new ErrorHandler("Please Update current version!..", 400));
//         }

//         if (applogin === undefined || version === undefined) {
//             return next(new ErrorHandler("Please Update current version!..", 400));
//         }
//         // Finding if user exists in database
//         const user = await User.findOne({
//             resonablestatus: {
//                 $nin: [
//                     "Not Joined",
//                     "Postponed",
//                     "Rejected",
//                     "Closed",
//                     "Releave Employee",
//                     "Absconded",
//                     "Hold",
//                     "Terminate",
//                 ],
//             },
//             username,
//         }).select("+password");
//         if (!user) {
//             return next(
//                 new ErrorHandler(
//                     "Login Restricted! Please Enter Valid Username&Password",
//                     401
//                 )
//             );
//         }


//         const userUniqueAddresss = user?.loginUserStatus?.find(data => data?.username === systemname && macAddress === data?.macaddress)
//         appUpdateCalculation = userUniqueAddresss ? 7 - (Math.floor((new Date().getTime() - new Date(userUniqueAddresss?.createdAt).getTime()) / (1000 * 60 * 60 * 24))) : 7;


//         // If checks password is correct or not
//         const isPwdMatched = await bcrypt.compare(password, user.password);

//         if (!isPwdMatched) {
//             return next(new ErrorHandler("Invalid Password", 401));
//         }
//         if (resonablestatusarray.includes(user?.resonablestatus)) {
//             return next(new ErrorHandler("Login Restricted", 401));
//         }

//         const overallsettings = await AdminOverAllSettings.find();
//         const clockinip = await ClockinIP.find({ branch: user?.branch });
//         let individualsettings = await IndividualSettings.find({
//             company: user?.company,
//             branch: user?.branch,
//             unit: user?.unit,
//             team: user?.team,
//             companyname: { $in: user?.companyname },
//         });
//         let individualtwofaswitch = individualsettings?.find((item) =>
//             item.companyname.includes(user?.companyname)
//         );


//         let autoLogoutTime = await AutoLogout.aggregate([
//             {
//                 $facet: {
//                     matchedData: [
//                         {
//                             $unwind: "$todos"
//                         },
//                         {
//                             $match: {
//                                 "todos.employeename":
//                                     user.companyname
//                             }
//                         },
//                         {
//                             $project: {
//                                 autologoutmins:
//                                     "$todos.autologoutmins"
//                             }
//                         }
//                     ],
//                     notMatched: [
//                         {
//                             $match: {
//                                 autologoutswitch: true
//                             }
//                         },
//                         {
//                             $project: {
//                                 autologoutmins: "$autologoutmins"
//                             }
//                         }
//                     ]
//                 }
//             },
//             {
//                 $project: {
//                     result: {
//                         $cond: {
//                             if: {
//                                 $gt: [{ $size: "$matchedData" }, 0]
//                             },
//                             then: "$matchedData",
//                             else: "$notMatched"
//                         }
//                     }
//                 }
//             }
//         ])


//         let checkAutoLogoutTime = autoLogoutTime[0].result?.length > 0 ? autoLogoutTime[0].result[0]?.autologoutmins : 5;

//         const dateCheck = new Date();
//         dateCheck.setMinutes(dateCheck.getMinutes() + Number(checkAutoLogoutTime));
//         let checkAutoLogoutDate = req?.body?.checkautologout === "check" ? dateCheck : "none"
//         let externalurl =
//             overallsettings[overallsettings.length - 1]?.externalurl?.length > 0
//                 ? overallsettings[overallsettings.length - 1]?.externalurl?.map(
//                     (item) => new URL(item).hostname
//                 )
//                 : [];
//         let internalurl =
//             overallsettings[overallsettings.length - 1]?.internalurl?.length > 0
//                 ? overallsettings[overallsettings.length - 1]?.internalurl?.map(
//                     (item) => new URL(item).hostname
//                 )
//                 : [];

//         let finalLoginMode = individualtwofaswitch
//             ? individualtwofaswitch?.loginmode
//             : overallsettings[overallsettings.length - 1]?.loginmode;
//         if (internalurl?.length === 0 ||
//             externalurl?.length === 0
//         ) {

//             return next(
//                 new ErrorHandler(`UnAuthorized Login 1, Contact Administrator`, 401)
//             );
//         }

//         if (
//             currenturl !== undefined &&
//             finalLoginMode === "Internal Login" &&
//             !internalurl?.includes(currenturl) &&
//             !user.role?.includes("Manager")
//         ) {

//             return next(
//                 new ErrorHandler(`UnAuthorized Login 2, Contact Administrator`, 401)
//             );
//         } else if (
//             currenturl !== undefined &&
//             finalLoginMode === "External Login" &&
//             !externalurl?.includes(currenturl) &&
//             !user.role?.includes("Manager")
//         ) {
//             return next(
//                 new ErrorHandler(`UnAuthorized Login 3,Contact Administrator`, 401)
//             );
//         }
//         else if (
//             currenturl !== undefined &&
//             finalLoginMode === "Both Login" &&
//             (!externalurl?.includes(currenturl) &&
//                 !internalurl?.includes(currenturl)) &&
//             !user.role?.includes("Manager")
//         ) {
//             return next(
//                 new ErrorHandler(`UnAuthorized Login 4,Contact Administrator`, 401)
//             );
//         }

//         //   if (!user.role.includes("Manager")) {
//         const today = moment();
//         const pastThreeAttendaysDays = [
//             today.clone().format("DD-MM-YYYY"),
//             today.clone().subtract(1, "days").format("DD-MM-YYYY"),
//             today.clone().subtract(2, "days").format("DD-MM-YYYY"),
//             today.clone().subtract(3, "days").format("DD-MM-YYYY"),
//         ];
//         const pastThreeLeaveDays = [
//             today.clone().format("DD/MM/YYYY"),

//             today.clone().subtract(1, "days").format("DD/MM/YYYY"),
//             today.clone().subtract(2, "days").format("DD/MM/YYYY"),
//             today.clone().subtract(3, "days").format("DD/MM/YYYY"),
//         ];
//         const pastThreeDaysISO = [
//             today.clone().format("YYYY-MM-DD"),
//             today.clone().subtract(1, "days").format("YYYY-MM-DD"),
//             today.clone().subtract(2, "days").format("YYYY-MM-DD"),
//             today.clone().subtract(3, "days").format("YYYY-MM-DD"),
//         ];

//         // Fetch relevant attendance records, leave records, and holidays for the specific user in parallel
//         const [attendance, allLeaveStatus, holidays] = await Promise.all([
//             // Fetch relevant attendance records for the past 3 days for the specific user
//             Attendance.find(
//                 {
//                     date: {
//                         $in: pastThreeAttendaysDays,
//                     },
//                     userid: user._id,
//                 },
//                 { date: 1, userid: 1 }
//             ).lean(),

//             // Fetch relevant leave records for the specific user
//             ApplyLeave.find(
//                 {
//                     date: { $in: pastThreeLeaveDays },
//                     employeeid: user.empcode,
//                     employeename: user.companyname,
//                     status: { $nin: ["Rejected"] },
//                 },
//                 { employeename: 1, employeeid: 1, date: 1 }
//             ).lean(),

//             // Fetch relevant holidays for the specific user
//             Holiday.find(
//                 {
//                     date: { $in: pastThreeDaysISO },
//                     company: { $in: [user.company] }, // Checks if user's company is in the company array
//                     applicablefor: { $in: [user.branch] }, // Checks if user's branch is in the applicablefor array
//                     unit: { $in: [user.unit] }, // Checks if user's unit is in the unit array
//                     team: { $in: [user.team] }, // Checks if user's team is in the team array
//                     employee: { $in: [user.companyname, "ALL"] }, // This checks if 'user.companyname' or 'ALL' is in the employee array
//                 },
//                 { date: 1, employee: 1 }
//             ).lean(),
//         ]);

//         // Continue with your logic

//         // Create maps for attendance, leave, and holidays for quick lookup

//         const attendanceMap = attendance.reduce((acc, item) => {
//             const date = moment(item.date, "DD-MM-YYYY").format("DD/MM/YYYY");
//             acc[date] = true;
//             return acc;
//         }, {});
//         const myCheckList = await MyCheckList.find({ candidatename: { $in: [user.companyname] } }).lean();
//         let leaveWithCheckList = allLeaveStatus.map((item) => {
//             let foundData = myCheckList?.find(
//                 (dataNew) => dataNew.commonid == item._id
//             );
//             let areAllGroupsCompleted = foundData?.groups?.every(
//                 (itemNew) => (itemNew.data !== undefined && itemNew.data !== "") || itemNew.files !== undefined
//             );

//             if (areAllGroupsCompleted) {
//                 return {
//                     ...item,
//                     updatestatus: "Completed",
//                 };
//             }
//             return null;
//         }).filter(item => item);
//         const leaveMap = leaveWithCheckList.reduce((acc, item) => {
//             item.date.forEach((date) => {
//                 acc[date] = true;
//             });
//             return acc;
//         }, {});

//         const holidayMap = holidays.reduce((acc, item) => {
//             const date = moment(item.date).format("DD/MM/YYYY");
//             acc[date] = true;
//             return acc;
//         }, {});

//         // Function to check the status for the past 3 days
//         const checkStatusForPast3Days = (weekOffDays) => {
//             let absentDays = 0;
//             let leaveDays = 0;
//             let holidayDays = 0;

//             for (let date of pastThreeLeaveDays) {
//                 // const dayOfWeek = moment(date, "DD/MM/YYYY").format("dddd"); // Get day of the week

//                 // if (weekOffDays.includes(dayOfWeek)) {
//                 //   continue; // Skip week off days
//                 // }
//                 if (attendanceMap[date]) {
//                     // User was present on this date
//                     continue;
//                 } else if (leaveMap[date]) {
//                     // User was on leave on this date
//                     leaveDays++;
//                 } else if (holidayMap[date]) {
//                     // User had a holiday on this date

//                     holidayDays++;
//                 } else {
//                     // User was absent on this date
//                     absentDays++;
//                 }
//             }

//             if (absentDays >= 4) {
//                 return "Long Absent";
//             } else if (leaveDays >= 4) {
//                 return "Long Leave";
//             } else if (holidayDays >= 4) {
//                 return null;
//             } else {
//                 return null;
//             }
//         };

//         // Function to determine the final status
//         const determineStatus = (attendanceStatus, livestatus) => {
//             if (attendanceStatus) {
//                 return attendanceStatus;
//             } else if (livestatus) {
//                 return livestatus;
//             } else {
//                 return "No Status";
//             }
//         };
//         let weekOffDays = [];
//         if (user.boardingLog && user.boardingLog.length > 0) {
//             const lastBoardingLog = user.boardingLog[user.boardingLog.length - 1];
//             weekOffDays = lastBoardingLog.weekoff || [];
//         }
//         // Determine the user's status
//         const attendanceStatus = checkStatusForPast3Days(weekOffDays);
//         const livestatus = !attendanceStatus ? "Live" : null;

//         const userStatus = determineStatus(attendanceStatus, livestatus);

//         const todaydate = moment().format("DD-MM-YYYY");
//         const tomorrow = moment().add(1, "days").format("DD-MM-YYYY");
//         const dayAfterTomorrow = moment().add(2, "days").format("DD-MM-YYYY");
//         const dateArray = [todaydate, tomorrow, dayAfterTomorrow];

//         let checkArray = user?.longleaveabsentaprooveddate?.every(
//             (date) => !dateArray.includes(date)
//         );
//         if (
//             !pastThreeDaysISO?.includes(user?.doj) &&
//             (userStatus === "Long Absent" || userStatus === "Long Leave") &&
//             Array.isArray(user?.longleaveabsentaprooveddate) &&
//             checkArray &&
//             !user.role.includes("Manager")
//         ) {
//             return next(
//                 new ErrorHandler(
//                     `Login Restricted! You're in ${userStatus}, Please Contact Administrator`,
//                     401
//                 )
//             );
//         }

//         controlcriteria = await ControlCriteria.find();
//         const lastCriteria = controlcriteria?.[controlcriteria.length - 1];
//         userCheckInControlCriteria = lastCriteria?.weekofftodos?.find(data =>
//             data?.employeename === user?.companyname &&
//             data?.company === user?.company &&
//             data?.branch === user?.branch &&
//             data?.unit === user?.unit
//         );
//         const holidayWeekOffData = await HolidayWeekOffRestriction.findOne({ companyname: user?.companyname, date: moment().format("YYYY-MM-DD") });
//         holidayWeekOffRestriction = holidayWeekOffData ? true : false;


//         let adminTwofaswitch, loginswitch;
//         if (overallsettings.length === 0) {
//             adminTwofaswitch = true;
//             loginswitch = true;
//         } else {
//             adminTwofaswitch =
//                 overallsettings[overallsettings.length - 1].overalltwofaswitch;
//             loginswitch =
//                 overallsettings[overallsettings.length - 1].loginrestrictionswitch;
//         }

//         let loginapprestriction = user?.extramode
//             ? user?.extramode
//             : individualtwofaswitch
//                 ? individualtwofaswitch?.loginapprestriction
//                 : overallsettings[overallsettings.length - 1]?.loginapprestriction;
//         let restrictionBtwShift = individualtwofaswitch
//             ? individualtwofaswitch?.loginapprestriction
//             : overallsettings[overallsettings.length - 1]?.loginapprestriction;

//         let check = individualtwofaswitch
//             ? individualtwofaswitch?.twofaswitch
//             : adminTwofaswitch;
//         let checkLogin = individualtwofaswitch
//             ? individualtwofaswitch?.loginipswitch
//             : loginswitch;

//         const WorkStationShortName = await WorkStationShortNameGeneration();

//         const workStationFind = WorkStationShortName?.find(data => data?.systemshortname === hostname)
//         const workstationNames = user?.workstation;
//         let matchedWorkStation = "";
//         let matchedUserWorkStation = "";

//         if (workstationNames[0] === `${workStationFind?.cabinname}(${workStationFind?.branch}-${workStationFind?.floor})`) {

//             matchedUserWorkStation = user?.workstation?.find(data => data === `${workStationFind?.cabinname}(${workStationFind?.branch}-${workStationFind?.floor})`)
//             matchedWorkStation = "Primary WorkStation";

//         } else if (workstationNames?.slice(1, user?.workstation?.length).includes(`${workStationFind?.cabinname}(${workStationFind?.branch}-${workStationFind?.floor})`)) {

//             matchedUserWorkStation = user?.workstation?.find(data => data === `${workStationFind?.cabinname}(${workStationFind?.branch}-${workStationFind?.floor})`)
//             matchedWorkStation = "Secondary WorkStation";

//         } else if (user?.workstationinput?.slice(0, 15) === hostname) {

//             matchedUserWorkStation = user?.workstationinput
//             matchedWorkStation = "Work From Home";
//         }

//         MatchedNotMatched = ["Primary WorkStation", "Secondary WorkStation", "Work From Home"].includes(matchedWorkStation) ? "Matched" : "Not-Matched";
//         const userSecondaryWorkStationCount = user?.loginUserStatus?.length > 0 ? user?.loginUserStatus?.filter(data => data.matched === 'Secondary WorkStation') : []
//         const countWorStation = matchedWorkStation === "Primary WorkStation" ?
//             1 : matchedWorkStation === "Secondary WorkStation" ? 2 : 0

//         user["sigindate"] = moment().format("DD-MM-YYYY");
//         const result = await user.save();

//         var logincheck;
//         if (clockinip?.length === 0) {
//             logincheck = "NOTSHOW";
//         } else {
//             logincheck = "SHOW";
//         }
//         const isIpInData = clockinip?.some((entry) =>
//             entry.ipaddress.includes(publicIP)
//         );
//         if (
//             checkLogin &&
//             !user.role.includes("Manager") &&
//             logincheck === "SHOW" &&
//             !isIpInData
//         ) {
//             return next(new ErrorHandler("Login Restricted", 401));
//         }
//         const userMacTwoFatrue = user?.loginUserStatus?.some(
//             (data) => (data.macaddress === macAddress || data.hostname === hostname) && data?.twofaenabled === true
//         );


//         if (!userMacTwoFatrue && check && !user.role.includes("Manager")) {

//             // authenticator.options = { step: 60 };
//             const secret = authenticator.generateSecret();
//             const uri = authenticator.keyuri(user?.companyname, "HILIFE.AI", secret);
//             const image = await qrcode.toDataURL(uri);
//             if (
//                 user?.loginUserStatus?.length == 0 ||
//                 user?.loginUserStatus === undefined
//             ) {
//                 user["loginUserStatus"] = {
//                     macaddress: macAddress,
//                     username: systemname,
//                     localip: localIp,
//                     status: "Active",
//                     twofatempsecret: secret,
//                     hostname: hostname,
//                     twofaenabled: false,
//                     version: version,
//                     workstation: matchedUserWorkStation,
//                     matchedstatus: MatchedNotMatched,
//                     matched: matchedWorkStation,
//                     count: countWorStation

//                 };
//                 const result = await user.save();
//                 return res.status(201).json({
//                     generateqr: true,
//                     image,
//                     result,
//                     loginapprestriction,
//                     checkAutoLogoutTime,
//                     checkAutoLogoutDate,
//                     controlcriteria,
//                     MatchedNotMatched,
//                     resversion,
//                     matchedWorkStation,
//                     appUpdateCalculation,
//                     restrictionBtwShift,
//                     holidayWeekOffRestriction,
//                     userCheckInControlCriteria
//                 });
//             } else if (user?.loginUserStatus?.length > 0) {
//                 const gesyscont = user?.loginUserStatus.filter((data) => {
//                     return data.macaddress != "none";
//                 });

//                 if (macAddress != "none") {
//                     if (
//                         ((Number(user?.employeecount) + Number(user?.wfhcount)) === gesyscont?.length) &&
//                         !user?.loginUserStatus?.some(
//                             (data) => (data.macaddress === macAddress || data.hostname === hostname)
//                         )
//                     ) {
//                         return next(
//                             new ErrorHandler(
//                                 "Reached Your System Count.Please Contact Administrator",
//                                 401
//                             )
//                         );
//                     } else {
//                         const remaining = user?.loginUserStatus
//                             ?.filter((data) => data.macaddress !== macAddress && data.hostname !== hostname)
//                             ?.map((dar) => ({ ...dar, status: "Inactive" }));

//                         user["loginUserStatus"] = [
//                             ...remaining,
//                             {
//                                 macaddress: macAddress,

//                                 username: systemname,
//                                 localip: localIp,
//                                 status: "Active",
//                                 hostname: hostname,
//                                 twofatempsecret: secret,
//                                 twofaenabled: false,
//                                 version: version,
//                                 workstation: matchedUserWorkStation,
//                                 matchedstatus: MatchedNotMatched,
//                                 matched: matchedWorkStation,
//                                 count: countWorStation
//                             },
//                         ];
//                         const result = await user.save();
//                         return res.status(201).json({
//                             generateqr: true,
//                             image,
//                             result,
//                             loginapprestriction,
//                             checkAutoLogoutTime,
//                             checkAutoLogoutDate,
//                             controlcriteria,
//                             MatchedNotMatched,
//                             resversion,
//                             matchedWorkStation,
//                             appUpdateCalculation,
//                             restrictionBtwShift,
//                             holidayWeekOffRestriction,
//                             userCheckInControlCriteria
//                         });
//                     }
//                 } else {
//                     if (macAddress != "none") {
//                         const remaining = user?.loginUserStatus
//                             ?.filter((data) => (data.macaddress !== macAddress || data.hostname !== hostname))
//                             ?.map((dar) => ({ ...dar, status: "Inactive" }));

//                         user["loginUserStatus"] = [
//                             ...remaining,
//                             {
//                                 macaddress: macAddress,
//                                 username: systemname,
//                                 localip: localIp,
//                                 status: "Active",
//                                 hostname: hostname,
//                                 twofatempsecret: secret,
//                                 twofaenabled: false,
//                                 version: version,
//                                 workstation: matchedUserWorkStation,
//                                 matchedstatus: MatchedNotMatched,
//                                 matched: matchedWorkStation,
//                                 count: countWorStation
//                             },
//                         ];

//                         const result = await user.save();
//                         return res.status(201).json({
//                             generateqr: true,
//                             image,
//                             result,
//                             loginapprestriction,
//                             checkAutoLogoutTime,
//                             checkAutoLogoutDate,
//                             controlcriteria,
//                             MatchedNotMatched,
//                             resversion,
//                             matchedWorkStation,
//                             appUpdateCalculation,
//                             restrictionBtwShift,
//                             holidayWeekOffRestriction,
//                             userCheckInControlCriteria
//                         });
//                     } else {
//                         const result = user;
//                         return res.status(201).json({
//                             generateqr: true,
//                             image,

//                             result,
//                             loginapprestriction,
//                             checkAutoLogoutTime,
//                             checkAutoLogoutDate,
//                             controlcriteria,
//                             MatchedNotMatched,
//                             resversion,
//                             matchedWorkStation,
//                             appUpdateCalculation,
//                             restrictionBtwShift,
//                             holidayWeekOffRestriction,
//                             userCheckInControlCriteria
//                         });
//                     }
//                 }
//             }
//         } else if (userMacTwoFatrue && check && !user.role.includes("Manager")) {
//             if (!otp) {
//                 const remaining = user?.loginUserStatus
//                     ?.filter((data) => data.macaddress !== macAddress)
//                     ?.map((dar) => ({ ...dar, status: "Inactive" }));

//                 return res.status(201).json({
//                     otpneeded: true,
//                     loginapprestriction,
//                     checkAutoLogoutTime,
//                     checkAutoLogoutDate,
//                     controlcriteria,
//                     MatchedNotMatched,
//                     resversion,
//                     matchedWorkStation,
//                     appUpdateCalculation,
//                     restrictionBtwShift,
//                     holidayWeekOffRestriction,
//                     userCheckInControlCriteria
//                 });
//             }

//             const userMacTwoFaSecret = user?.loginUserStatus?.find(
//                 (data) => (data.macaddress === macAddress || data.hostname === hostname) && data?.twofaenabled === true
//             );
//             const remaining = user?.loginUserStatus
//                 ?.map((data) => {
//                     if (data.macaddress === macAddress || data.hostname === hostname) {
//                         data['status'] = "Active"
//                     } else {
//                         data['status'] = "Inactive"
//                     }
//                     return data
//                 }
//                 );
//             user["loginUserStatus"] = remaining;
//             const result = await user.save();
//             const verified = authenticator.check(otp, userMacTwoFaSecret.twofasecret);

//             if (!verified) {
//                 return next(new ErrorHandler("Kindly check your WinAuth QR code! Invalid Otp", 401));
//             }
//             checksendToken(result, 200, res, loginapprestriction, checkAutoLogoutTime,
//                 checkAutoLogoutDate, controlcriteria, MatchedNotMatched, resversion,
//                 matchedWorkStation, appUpdateCalculation, restrictionBtwShift, holidayWeekOffRestriction, userCheckInControlCriteria);
//         } else {
//             const gesyscont = user?.loginUserStatus.filter((data) => {
//                 return data.macaddress != "none";
//             });
//             if (
//                 user?.loginUserStatus?.find((data) =>
//                     (data.macaddress === macAddress || data.hostname === hostname))
//             ) {
//                 const result = await user.save();
//                 checksendToken(result, 200, res, loginapprestriction, checkAutoLogoutTime,
//                     checkAutoLogoutDate, controlcriteria, MatchedNotMatched, resversion,
//                     matchedWorkStation, appUpdateCalculation, restrictionBtwShift, holidayWeekOffRestriction, userCheckInControlCriteria);
//             } else if (

//                 ((Number(user?.employeecount) + Number(user?.wfhcount)) === gesyscont?.length) &&
//                 macAddress !== "none" && hostname !== "none" &&
//                 !user?.loginUserStatus?.some((data) => (data.macaddress === macAddress || data.hostname === hostname))
//             ) {
//                 return next(
//                     new ErrorHandler(
//                         "Reached Your System Count.Please Contact Administrator",
//                         401
//                     )
//                 );
//             } else {
//                 if (macAddress !== "none") {
//                     const remaining = user?.loginUserStatus?.map((dar) => ({
//                         ...dar,
//                         status: "Inactive",
//                     }));

//                     user["loginUserStatus"] = [
//                         ...remaining,
//                         {
//                             macaddress: macAddress,
//                             username: systemname,
//                             hostname: hostname,
//                             localip: localIp,
//                             status: "Active",
//                             version: version,
//                             workstation: matchedUserWorkStation,
//                             matchedstatus: MatchedNotMatched,
//                             matched: matchedWorkStation,
//                             count: countWorStation
//                         },
//                     ];
//                     // user["signintime"] = (todaydate && extraTime?.length > 0 && extraTime[0] === moment().format("YYYY-MM-DD")) ?
//                     // moment(user?.signintime).format("DD-MM-YYYY")=== moment().format("DD-MM-YYYY") ? "" : todaydate : ''

//                     const result = await user.save();
//                     checksendToken(
//                         result,
//                         200,
//                         res,
//                         loginapprestriction,
//                         checkAutoLogoutTime,
//                         checkAutoLogoutDate,
//                         controlcriteria,
//                         MatchedNotMatched, resversion,
//                         matchedWorkStation,
//                         appUpdateCalculation,
//                         restrictionBtwShift,
//                         holidayWeekOffRestriction,
//                         userCheckInControlCriteria
//                     );
//                 } else {
//                     checksendToken(user, 200, res, loginapprestriction, checkAutoLogoutTime,
//                         checkAutoLogoutDate, controlcriteria, MatchedNotMatched, resversion,
//                         matchedWorkStation, appUpdateCalculation, restrictionBtwShift, holidayWeekOffRestriction, userCheckInControlCriteria);
//                 }
//             }
//         }
//     } catch (err) {
//         return next(new ErrorHandler("User not found", 404));
//     }
// });




// exports.logincheckAuth = catchAsyncErrors(async (req, res, next) => {

//     let resversion = false;
//     let appUpdateCalculation = 7
//     try {
//         const {
//             username,
//             password,
//             otp,
//             publicIP,
//             macAddress,
//             systemname,
//             currenturl,
//             localIp,
//             hostname,
//             version,
//             applogin,
//         } = req.body;
//         let MatchedNotMatched;
//         let controlcriteria;
//         let holidayWeekOffRestriction;
//         let userCheckInControlCriteria;
//         resversion = version === "1.11.0" ? true : resversion = version === "1.10.0" ? true : resversion = version === "1.12.0" ? true : resversion = version === "1.13.0" ? true : resversion = version === "1.14.0" ? true : false

//         const PresenLoginUserDate = new Date();
//         // let hostname = "TT_1_U4_G-HRA";
//         const resonablestatusarray = [
//             "Absconded",
//             "Hold",
//             "Terminate",
//             "Releave Employee",
//             "Not Joined",
//             "Postponed",
//             "Rejected",
//             "Closed",
//         ];
//         //version mismatch
//         if (!username || !password) {
//             return next(new ErrorHandler("Please enter username and password", 400));
//         }
//         // Check if email & password entered by user
//         if (applogin === true && version !== "1.8.0" && version !== "1.9.0" && version !== "1.11.0" && version !== "1.10.0" && version !== "1.12.0" && version !== "1.13.0" && version !== "1.14.0") {
//             return next(new ErrorHandler("Please Update current version!..", 400));
//         }

//         if (applogin === undefined || version === undefined) {
//             return next(new ErrorHandler("Please Update current version!..", 400));
//         }
//         // Finding if user exists in database
//         const user = await User.findOne({
//             resonablestatus: {
//                 $nin: [
//                     "Not Joined",
//                     "Postponed",
//                     "Rejected",
//                     "Closed",
//                     "Releave Employee",
//                     "Absconded",
//                     "Hold",
//                     "Terminate",
//                 ],
//             },
//             username,
//         }).select("+password");
//         if (!user) {
//             return next(
//                 new ErrorHandler(
//                     "Login Restricted! Please Enter Valid Username&Password",
//                     401
//                 )
//             );
//         }


//         const userUniqueAddresss = user?.loginUserStatus?.find(data => data?.username === systemname && macAddress === data?.macaddress)
//         appUpdateCalculation = userUniqueAddresss ? 7 - (Math.floor((new Date().getTime() - new Date(userUniqueAddresss?.createdAt).getTime()) / (1000 * 60 * 60 * 24))) : 7;


//         // If checks password is correct or not
//         const isPwdMatched = await bcrypt.compare(password, user.password);

//         if (!isPwdMatched) {
//             return next(new ErrorHandler("Invalid Password", 401));
//         }
//         if (resonablestatusarray.includes(user?.resonablestatus)) {
//             return next(new ErrorHandler("Login Restricted", 401));
//         }

//         const overallsettings = await AdminOverAllSettings.find();
//         const clockinip = await ClockinIP.find({ branch: user?.branch });
//         let individualsettings = await IndividualSettings.find({
//             company: user?.company,
//             branch: user?.branch,
//             unit: user?.unit,
//             team: user?.team,
//             companyname: { $in: user?.companyname },
//         });
//         let individualtwofaswitch = individualsettings?.find((item) =>
//             item.companyname.includes(user?.companyname)
//         );


//         let autoLogoutTime = await AutoLogout.aggregate([
//             {
//                 $facet: {
//                     matchedData: [
//                         {
//                             $unwind: "$todos"
//                         },
//                         {
//                             $match: {
//                                 "todos.employeename":
//                                     user.companyname
//                             }
//                         },
//                         {
//                             $project: {
//                                 autologoutmins:
//                                     "$todos.autologoutmins"
//                             }
//                         }
//                     ],
//                     notMatched: [
//                         {
//                             $match: {
//                                 autologoutswitch: true
//                             }
//                         },
//                         {
//                             $project: {
//                                 autologoutmins: "$autologoutmins"
//                             }
//                         }
//                     ]
//                 }
//             },
//             {
//                 $project: {
//                     result: {
//                         $cond: {
//                             if: {
//                                 $gt: [{ $size: "$matchedData" }, 0]
//                             },
//                             then: "$matchedData",
//                             else: "$notMatched"
//                         }
//                     }
//                 }
//             }
//         ])


//         let checkAutoLogoutTime = autoLogoutTime[0].result?.length > 0 ? autoLogoutTime[0].result[0]?.autologoutmins : 5;

//         const dateCheck = new Date();
//         dateCheck.setMinutes(dateCheck.getMinutes() + Number(checkAutoLogoutTime));
//         let checkAutoLogoutDate = req?.body?.checkautologout === "check" ? dateCheck : "none"
//         let overallLoginByWorkStation =
//             overallsettings[overallsettings.length - 1]?.loginbyworkstation
//                 ? overallsettings[overallsettings.length - 1]?.loginbyworkstation
//                 : {
//                     primary: true,
//                     secondary: true,
//                     wfh: true,
//                     unauthorized: true,
//                 };
//         let indiviDualLoginByWorkStation =
//             individualtwofaswitch?.loginbyworkstation
//                 ? individualtwofaswitch?.loginbyworkstation
//                 : {};
//         let finalLoginByWorkStation = Object.entries(indiviDualLoginByWorkStation)?.length > 0 ? indiviDualLoginByWorkStation : overallLoginByWorkStation;
//         let externalurl =
//             overallsettings[overallsettings.length - 1]?.externalurl?.length > 0
//                 ? overallsettings[overallsettings.length - 1]?.externalurl?.map(
//                     (item) => new URL(item).hostname
//                 )
//                 : [];
//         let internalurl =
//             overallsettings[overallsettings.length - 1]?.internalurl?.length > 0
//                 ? overallsettings[overallsettings.length - 1]?.internalurl?.map(
//                     (item) => new URL(item).hostname
//                 )
//                 : [];

//         let finalLoginMode = individualtwofaswitch
//             ? individualtwofaswitch?.loginmode
//             : overallsettings[overallsettings.length - 1]?.loginmode;
//         if (internalurl?.length === 0 ||
//             externalurl?.length === 0
//         ) {

//             return next(
//                 new ErrorHandler(`UnAuthorized Login 1, Contact Administrator`, 401)
//             );
//         }

//         if (
//             currenturl !== undefined &&
//             finalLoginMode === "Internal Login" &&
//             !internalurl?.includes(currenturl) &&
//             !user.role?.includes("Manager")
//         ) {

//             return next(
//                 new ErrorHandler(`UnAuthorized Login 2, Contact Administrator`, 401)
//             );
//         } else if (
//             currenturl !== undefined &&
//             finalLoginMode === "External Login" &&
//             !externalurl?.includes(currenturl) &&
//             !user.role?.includes("Manager")
//         ) {
//             return next(
//                 new ErrorHandler(`UnAuthorized Login 3,Contact Administrator`, 401)
//             );
//         }
//         else if (
//             currenturl !== undefined &&
//             finalLoginMode === "Both Login" &&
//             (!externalurl?.includes(currenturl) &&
//                 !internalurl?.includes(currenturl)) &&
//             !user.role?.includes("Manager")
//         ) {

//             return next(
//                 new ErrorHandler(`UnAuthorized Login 4,Contact Administrator`, 401)
//             );
//         }

//         //   if (!user.role.includes("Manager")) {
//         const today = moment();
//         const pastThreeAttendaysDays = [
//             today.clone().format("DD-MM-YYYY"),
//             today.clone().subtract(1, "days").format("DD-MM-YYYY"),
//             today.clone().subtract(2, "days").format("DD-MM-YYYY"),
//             today.clone().subtract(3, "days").format("DD-MM-YYYY"),
//         ];
//         const pastThreeLeaveDays = [
//             today.clone().format("DD/MM/YYYY"),

//             today.clone().subtract(1, "days").format("DD/MM/YYYY"),
//             today.clone().subtract(2, "days").format("DD/MM/YYYY"),
//             today.clone().subtract(3, "days").format("DD/MM/YYYY"),
//         ];
//         const pastThreeDaysISO = [
//             today.clone().format("YYYY-MM-DD"),
//             today.clone().subtract(1, "days").format("YYYY-MM-DD"),
//             today.clone().subtract(2, "days").format("YYYY-MM-DD"),
//             today.clone().subtract(3, "days").format("YYYY-MM-DD"),
//         ];

//         // Fetch relevant attendance records, leave records, and holidays for the specific user in parallel
//         const [attendance, allLeaveStatus, holidays] = await Promise.all([
//             // Fetch relevant attendance records for the past 3 days for the specific user
//             Attendance.find(
//                 {
//                     date: {
//                         $in: pastThreeAttendaysDays,
//                     },
//                     userid: user._id,
//                 },
//                 { date: 1, userid: 1 }
//             ).lean(),

//             // Fetch relevant leave records for the specific user
//             ApplyLeave.find(
//                 {
//                     date: { $in: pastThreeLeaveDays },
//                     employeeid: user.empcode,
//                     employeename: user.companyname,
//                     status: { $nin: ["Rejected"] },
//                 },
//                 { employeename: 1, employeeid: 1, date: 1 }
//             ).lean(),

//             // Fetch relevant holidays for the specific user
//             Holiday.find(
//                 {
//                     date: { $in: pastThreeDaysISO },
//                     company: { $in: [user.company] }, // Checks if user's company is in the company array
//                     applicablefor: { $in: [user.branch] }, // Checks if user's branch is in the applicablefor array
//                     unit: { $in: [user.unit] }, // Checks if user's unit is in the unit array
//                     team: { $in: [user.team] }, // Checks if user's team is in the team array
//                     employee: { $in: [user.companyname, "ALL"] }, // This checks if 'user.companyname' or 'ALL' is in the employee array
//                 },
//                 { date: 1, employee: 1 }
//             ).lean(),
//         ]);

//         // Continue with your logic

//         // Create maps for attendance, leave, and holidays for quick lookup

//         const attendanceMap = attendance.reduce((acc, item) => {
//             const date = moment(item.date, "DD-MM-YYYY").format("DD/MM/YYYY");
//             acc[date] = true;
//             return acc;
//         }, {});
//         const myCheckList = await MyCheckList.find({ candidatename: { $in: [user.companyname] } }).lean();
//         let leaveWithCheckList = allLeaveStatus.map((item) => {
//             let foundData = myCheckList?.find(
//                 (dataNew) => dataNew.commonid == item._id
//             );
//             let areAllGroupsCompleted = foundData?.groups?.every(
//                 (itemNew) => (itemNew.data !== undefined && itemNew.data !== "") || itemNew.files !== undefined
//             );

//             if (areAllGroupsCompleted) {
//                 return {
//                     ...item,
//                     updatestatus: "Completed",
//                 };
//             }
//             return null;
//         }).filter(item => item);
//         const leaveMap = leaveWithCheckList.reduce((acc, item) => {
//             item.date.forEach((date) => {
//                 acc[date] = true;
//             });
//             return acc;
//         }, {});

//         const holidayMap = holidays.reduce((acc, item) => {
//             const date = moment(item.date).format("DD/MM/YYYY");
//             acc[date] = true;
//             return acc;
//         }, {});

//         // Function to check the status for the past 3 days
//         const checkStatusForPast3Days = (weekOffDays) => {
//             let absentDays = 0;
//             let leaveDays = 0;
//             let holidayDays = 0;

//             for (let date of pastThreeLeaveDays) {
//                 // const dayOfWeek = moment(date, "DD/MM/YYYY").format("dddd"); // Get day of the week

//                 // if (weekOffDays.includes(dayOfWeek)) {
//                 //   continue; // Skip week off days
//                 // }
//                 if (attendanceMap[date]) {
//                     // User was present on this date
//                     continue;
//                 } else if (leaveMap[date]) {
//                     // User was on leave on this date
//                     leaveDays++;
//                 } else if (holidayMap[date]) {
//                     // User had a holiday on this date

//                     holidayDays++;
//                 } else {
//                     // User was absent on this date
//                     absentDays++;
//                 }
//             }

//             if (absentDays >= 4) {
//                 return "Long Absent";
//             } else if (leaveDays >= 4) {
//                 return "Long Leave";
//             } else if (holidayDays >= 4) {
//                 return null;
//             } else {
//                 return null;
//             }
//         };

//         // Function to determine the final status
//         const determineStatus = (attendanceStatus, livestatus) => {
//             if (attendanceStatus) {
//                 return attendanceStatus;
//             } else if (livestatus) {
//                 return livestatus;
//             } else {
//                 return "No Status";
//             }
//         };
//         let weekOffDays = [];
//         if (user.boardingLog && user.boardingLog.length > 0) {
//             const lastBoardingLog = user.boardingLog[user.boardingLog.length - 1];
//             weekOffDays = lastBoardingLog.weekoff || [];
//         }
//         // Determine the user's status
//         const attendanceStatus = checkStatusForPast3Days(weekOffDays);
//         const livestatus = !attendanceStatus ? "Live" : null;

//         const userStatus = determineStatus(attendanceStatus, livestatus);

//         const todaydate = moment().format("DD-MM-YYYY");
//         const tomorrow = moment().add(1, "days").format("DD-MM-YYYY");
//         const dayAfterTomorrow = moment().add(2, "days").format("DD-MM-YYYY");
//         const dateArray = [todaydate, tomorrow, dayAfterTomorrow];

//         let checkArray = user?.longleaveabsentaprooveddate?.every(
//             (date) => !dateArray.includes(date)
//         );
//         if (
//             !pastThreeDaysISO?.includes(user?.doj) &&
//             (userStatus === "Long Absent" || userStatus === "Long Leave") &&
//             Array.isArray(user?.longleaveabsentaprooveddate) &&
//             checkArray &&
//             !user.role.includes("Manager")
//         ) {
//             return next(
//                 new ErrorHandler(
//                     `Login Restricted! You're in ${userStatus}, Please Contact Administrator`,
//                     401
//                 )
//             );
//         }

//         controlcriteria = await ControlCriteria.find();
//         const lastCriteria = controlcriteria?.[controlcriteria.length - 1];
//         userCheckInControlCriteria = lastCriteria?.weekofftodos?.find(data =>
//             data?.employeename === user?.companyname &&
//             data?.company === user?.company &&
//             data?.branch === user?.branch &&
//             data?.unit === user?.unit
//         );
//         const holidayWeekOffData = await HolidayWeekOffRestriction.findOne({ companyname: user?.companyname, date: moment().format("YYYY-MM-DD") });
//         holidayWeekOffRestriction = holidayWeekOffData ? true : false;
//         if (user?.loginUserStatus?.length > 0) {
//             const remaining = user?.loginUserStatus
//                 ?.map((data) => {
//                     if (data.macaddress === macAddress || data.hostname === hostname) {
//                         data['status'] = "Active",
//                             data['date'] = PresenLoginUserDate,
//                             data['version'] = version
//                     } else {
//                         data['status'] = "Inactive"
//                     }
//                     return data
//                 }
//                 );
//             user["loginUserStatus"] = remaining;
//             const resultloginUserStatus = await user.save();
//         }




//         let adminTwofaswitch, loginswitch;
//         if (overallsettings.length === 0) {
//             adminTwofaswitch = true;
//             loginswitch = true;
//         } else {
//             adminTwofaswitch =
//                 overallsettings[overallsettings.length - 1].overalltwofaswitch;
//             loginswitch =
//                 overallsettings[overallsettings.length - 1].loginrestrictionswitch;
//         }

//         let loginapprestriction = user?.extramode
//             ? user?.extramode
//             : individualtwofaswitch
//                 ? individualtwofaswitch?.loginapprestriction
//                 : overallsettings[overallsettings.length - 1]?.loginapprestriction;
//         let restrictionBtwShift = individualtwofaswitch
//             ? individualtwofaswitch?.loginapprestriction
//             : overallsettings[overallsettings.length - 1]?.loginapprestriction;

//         let check = individualtwofaswitch
//             ? individualtwofaswitch?.twofaswitch
//             : adminTwofaswitch;
//         let checkLogin = individualtwofaswitch
//             ? individualtwofaswitch?.loginipswitch
//             : loginswitch;

//         const WorkStationShortName = await WorkStationShortNameGeneration();
//         const checkWorkStationAccess = (matchedWorkStation, finalLoginByWorkStation) => {
//             if (!finalLoginByWorkStation) return true; // Handle undefined/null case

//             switch (matchedWorkStation) {
//                 case "Work From Home":
//                     return finalLoginByWorkStation?.wfh === true;
//                 case "Secondary WorkStation":
//                     return finalLoginByWorkStation?.secondary === true;
//                 case "Primary WorkStation":
//                     return finalLoginByWorkStation?.primary === true;
//                 case "":
//                     return finalLoginByWorkStation?.unauthorized === true;
//                 default:
//                     return false;
//             }
//         };

//         const workStationFind = WorkStationShortName?.find(data => data?.systemshortname === hostname)
//         const workstationNames = user?.workstation;
//         let matchedWorkStation = "";
//         let matchedUserWorkStation = "";

//         if (workstationNames[0] === `${workStationFind?.cabinname}(${workStationFind?.branch}-${workStationFind?.floor})`) {

//             matchedUserWorkStation = user?.workstation?.find(data => data === `${workStationFind?.cabinname}(${workStationFind?.branch}-${workStationFind?.floor})`)
//             matchedWorkStation = "Primary WorkStation";

//         } else if (workstationNames?.slice(1, user?.workstation?.length).includes(`${workStationFind?.cabinname}(${workStationFind?.branch}-${workStationFind?.floor})`)) {

//             matchedUserWorkStation = user?.workstation?.find(data => data === `${workStationFind?.cabinname}(${workStationFind?.branch}-${workStationFind?.floor})`)
//             matchedWorkStation = "Secondary WorkStation";

//         } else if (user?.workstationinput?.slice(0, 15) === hostname) {

//             matchedUserWorkStation = user?.workstationinput
//             matchedWorkStation = "Work From Home";
//         }

//         let loginByWorkStation = await checkWorkStationAccess(matchedWorkStation, finalLoginByWorkStation);

//         if (req.body.macAddress !== "none" && !user?.role?.includes("Manager") && !loginByWorkStation) {
//             return next(
//                 new ErrorHandler(
//                     `This WorkStation Login Restricted!! Please Login Authorized WorkStation!!!`,
//                     401
//                 )
//             );
//         }

//         MatchedNotMatched = ["Primary WorkStation", "Secondary WorkStation", "Work From Home"].includes(matchedWorkStation) ? "Matched" : "Not-Matched";
//         const userSecondaryWorkStationCount = user?.loginUserStatus?.length > 0 ? user?.loginUserStatus?.filter(data => data.matched === 'Secondary WorkStation') : []
//         const countWorStation = matchedWorkStation === "Primary WorkStation" ?
//             1 : matchedWorkStation === "Secondary WorkStation" ? 2 : 0

//         user["sigindate"] = moment().format("DD-MM-YYYY");
//         const result = await user.save();

//         var logincheck;
//         if (clockinip?.length === 0) {
//             logincheck = "NOTSHOW";
//         } else {
//             logincheck = "SHOW";
//         }
//         const isIpInData = clockinip?.some((entry) =>
//             entry.ipaddress.includes(publicIP)
//         );
//         if (
//             checkLogin &&
//             !user.role.includes("Manager") &&
//             logincheck === "SHOW" &&
//             !isIpInData
//         ) {
//             return next(new ErrorHandler("Login Restricted", 401));
//         }
//         const userMacTwoFatrue = user?.loginUserStatus?.some(
//             (data) => (data.macaddress === macAddress || data.hostname === hostname) && data?.twofaenabled === true
//         );


//         if (!userMacTwoFatrue && check && !user.role.includes("Manager")) {

//             // authenticator.options = { step: 60 };
//             const secret = authenticator.generateSecret();
//             const uri = authenticator.keyuri(user?.companyname, "HILIFE.AI", secret);
//             const image = await qrcode.toDataURL(uri);
//             if (
//                 user?.loginUserStatus?.length == 0 ||
//                 user?.loginUserStatus === undefined
//             ) {
//                 user["loginUserStatus"] = {
//                     macaddress: macAddress,
//                     username: systemname,
//                     localip: localIp,
//                     status: "Active",
//                     twofatempsecret: secret,
//                     hostname: hostname,
//                     twofaenabled: false,
//                     version: version,
//                     workstation: matchedUserWorkStation,
//                     matchedstatus: MatchedNotMatched,
//                     matched: matchedWorkStation,
//                     count: countWorStation,
//                     date: PresenLoginUserDate

//                 };
//                 const result = await user.save();
//                 return res.status(201).json({
//                     generateqr: true,
//                     image,
//                     result,
//                     loginapprestriction,
//                     checkAutoLogoutTime,
//                     checkAutoLogoutDate,
//                     controlcriteria,
//                     MatchedNotMatched,
//                     resversion,
//                     matchedWorkStation,
//                     appUpdateCalculation,
//                     restrictionBtwShift,
//                     holidayWeekOffRestriction,
//                     userCheckInControlCriteria
//                 });
//             } else if (user?.loginUserStatus?.length > 0) {
//                 const gesyscont = user?.loginUserStatus.filter((data) => {
//                     return data.macaddress != "none";
//                 });

//                 if (macAddress != "none") {
//                     if (
//                         ((Number(user?.employeecount) + Number(user?.wfhcount)) === gesyscont?.length) &&
//                         !user?.loginUserStatus?.some(
//                             (data) => (data.macaddress === macAddress || data.hostname === hostname)
//                         )
//                     ) {
//                         return next(
//                             new ErrorHandler(
//                                 "Reached Your System Count.Please Contact Administrator",
//                                 401
//                             )
//                         );
//                     } else {
//                         const remaining = user?.loginUserStatus
//                             ?.filter((data) => data.macaddress !== macAddress && data.hostname !== hostname)
//                             ?.map((dar) => ({ ...dar, status: "Inactive" }));

//                         user["loginUserStatus"] = [
//                             ...remaining,
//                             {
//                                 macaddress: macAddress,

//                                 username: systemname,
//                                 localip: localIp,
//                                 status: "Active",
//                                 hostname: hostname,
//                                 twofatempsecret: secret,
//                                 twofaenabled: false,
//                                 version: version,
//                                 workstation: matchedUserWorkStation,
//                                 matchedstatus: MatchedNotMatched,
//                                 matched: matchedWorkStation,
//                                 count: countWorStation,
//                                 date: PresenLoginUserDate
//                             },
//                         ];
//                         const result = await user.save();
//                         return res.status(201).json({
//                             generateqr: true,
//                             image,
//                             result,
//                             loginapprestriction,
//                             checkAutoLogoutTime,
//                             checkAutoLogoutDate,
//                             controlcriteria,
//                             MatchedNotMatched,
//                             resversion,
//                             matchedWorkStation,
//                             appUpdateCalculation,
//                             restrictionBtwShift,
//                             holidayWeekOffRestriction,
//                             userCheckInControlCriteria
//                         });
//                     }
//                 } else {
//                     if (macAddress != "none") {
//                         const remaining = user?.loginUserStatus
//                             ?.filter((data) => (data.macaddress !== macAddress || data.hostname !== hostname))
//                             ?.map((dar) => ({ ...dar, status: "Inactive" }));

//                         user["loginUserStatus"] = [
//                             ...remaining,
//                             {
//                                 macaddress: macAddress,
//                                 username: systemname,
//                                 localip: localIp,
//                                 status: "Active",
//                                 hostname: hostname,
//                                 twofatempsecret: secret,
//                                 twofaenabled: false,
//                                 version: version,
//                                 workstation: matchedUserWorkStation,
//                                 matchedstatus: MatchedNotMatched,
//                                 matched: matchedWorkStation,
//                                 count: countWorStation,
//                                 date: PresenLoginUserDate
//                             },
//                         ];

//                         const result = await user.save();
//                         return res.status(201).json({
//                             generateqr: true,
//                             image,
//                             result,
//                             loginapprestriction,
//                             checkAutoLogoutTime,
//                             checkAutoLogoutDate,
//                             controlcriteria,
//                             MatchedNotMatched,
//                             resversion,
//                             matchedWorkStation,
//                             appUpdateCalculation,
//                             restrictionBtwShift,
//                             holidayWeekOffRestriction,
//                             userCheckInControlCriteria
//                         });
//                     } else {
//                         const result = user;
//                         return res.status(201).json({
//                             generateqr: true,
//                             image,

//                             result,
//                             loginapprestriction,
//                             checkAutoLogoutTime,
//                             checkAutoLogoutDate,
//                             controlcriteria,
//                             MatchedNotMatched,
//                             resversion,
//                             matchedWorkStation,
//                             appUpdateCalculation,
//                             restrictionBtwShift,
//                             holidayWeekOffRestriction,
//                             userCheckInControlCriteria
//                         });
//                     }
//                 }
//             }
//         } else if (userMacTwoFatrue && check && !user.role.includes("Manager")) {
//             if (!otp) {
//                 const remaining = user?.loginUserStatus
//                     ?.filter((data) => data.macaddress !== macAddress)
//                     ?.map((dar) => ({ ...dar, status: "Inactive" }));

//                 return res.status(201).json({
//                     otpneeded: true,
//                     loginapprestriction,
//                     checkAutoLogoutTime,
//                     checkAutoLogoutDate,
//                     controlcriteria,
//                     MatchedNotMatched,
//                     resversion,
//                     matchedWorkStation,
//                     appUpdateCalculation,
//                     restrictionBtwShift,
//                     holidayWeekOffRestriction,
//                     userCheckInControlCriteria
//                 });
//             }

//             const userMacTwoFaSecret = user?.loginUserStatus?.find(
//                 (data) => (data.macaddress === macAddress || data.hostname === hostname) && data?.twofaenabled === true
//             );

//             const remaining = user?.loginUserStatus
//                 ?.map((data) => {
//                     if (data.macaddress === macAddress || data.hostname === hostname) {
//                         data['status'] = "Active",
//                             data['date'] = PresenLoginUserDate
//                     } else {
//                         data['status'] = "Inactive"
//                     }
//                     return data
//                 }
//                 );
//             user["loginUserStatus"] = remaining;
//             const result = await user.save();
//             const verified = authenticator.check(otp, userMacTwoFaSecret.twofasecret);

//             if (!verified) {
//                 return next(new ErrorHandler("Kindly check your WinAuth QR code! Invalid Otp", 401));
//             }
//             checksendToken(result, 200, res, loginapprestriction, checkAutoLogoutTime,
//                 checkAutoLogoutDate, controlcriteria, MatchedNotMatched, resversion,
//                 matchedWorkStation, appUpdateCalculation, restrictionBtwShift, holidayWeekOffRestriction, userCheckInControlCriteria);
//         } else {
//             const gesyscont = user?.loginUserStatus.filter((data) => {
//                 return data.macaddress != "none";
//             });
//             if (
//                 user?.loginUserStatus?.find((data) =>
//                     (data.macaddress === macAddress || data.hostname === hostname))
//             ) {
//                 const result = await user.save();
//                 checksendToken(result, 200, res, loginapprestriction, checkAutoLogoutTime,
//                     checkAutoLogoutDate, controlcriteria, MatchedNotMatched, resversion,
//                     matchedWorkStation, appUpdateCalculation, restrictionBtwShift, holidayWeekOffRestriction, userCheckInControlCriteria);
//             } else if (

//                 ((Number(user?.employeecount) + Number(user?.wfhcount)) === gesyscont?.length) &&
//                 macAddress !== "none" && hostname !== "none" &&
//                 !user?.loginUserStatus?.some((data) => (data.macaddress === macAddress || data.hostname === hostname))
//             ) {
//                 return next(
//                     new ErrorHandler(
//                         "Reached Your System Count.Please Contact Administrator",
//                         401
//                     )
//                 );
//             } else {
//                 if (macAddress !== "none") {
//                     const remaining = user?.loginUserStatus?.map((dar) => ({
//                         ...dar,
//                         status: "Inactive",
//                     }));

//                     user["loginUserStatus"] = [
//                         ...remaining,
//                         {
//                             macaddress: macAddress,
//                             username: systemname,
//                             hostname: hostname,
//                             localip: localIp,
//                             status: "Active",
//                             version: version,
//                             workstation: matchedUserWorkStation,
//                             matchedstatus: MatchedNotMatched,
//                             matched: matchedWorkStation,
//                             count: countWorStation,
//                             date: PresenLoginUserDate
//                         },
//                     ];
//                     // user["signintime"] = (todaydate && extraTime?.length > 0 && extraTime[0] === moment().format("YYYY-MM-DD")) ?
//                     // moment(user?.signintime).format("DD-MM-YYYY")=== moment().format("DD-MM-YYYY") ? "" : todaydate : ''

//                     const result = await user.save();
//                     checksendToken(
//                         result,
//                         200,
//                         res,
//                         loginapprestriction,
//                         checkAutoLogoutTime,
//                         checkAutoLogoutDate,
//                         controlcriteria,
//                         MatchedNotMatched, resversion,
//                         matchedWorkStation,
//                         appUpdateCalculation,
//                         restrictionBtwShift,
//                         holidayWeekOffRestriction,
//                         userCheckInControlCriteria
//                     );
//                 } else {
//                     checksendToken(user, 200, res, loginapprestriction, checkAutoLogoutTime,
//                         checkAutoLogoutDate, controlcriteria, MatchedNotMatched, resversion,
//                         matchedWorkStation, appUpdateCalculation, restrictionBtwShift, holidayWeekOffRestriction, userCheckInControlCriteria);
//                 }
//             }
//         }
//     } catch (err) {
//         console.log(err, 'er1')
//         return next(new ErrorHandler("User not found", 404));
//     }
// });

// exports.logincheckAuth = catchAsyncErrors(async (req, res, next) => {

//     let resversion = false;
//     let appUpdateCalculation = 7
//     try {
//         const {
//             username,
//             password,
//             otp,
//             publicIP,
//             macAddress,
//             systemname,
//             currenturl,
//             localIp,
//             hostname,
//             version,
//             applogin,
//         } = req.body;
//         let MatchedNotMatched;
//         let controlcriteria;
//         let holidayWeekOffRestriction;
//         let userCheckInControlCriteria;
//         resversion = version === "1.11.0" ? true : resversion = version === "1.10.0" ? true : resversion = version === "1.12.0" ? true : resversion = version === "1.13.0" ? true : resversion = version === "1.14.0" ? true : false

//         const PresenLoginUserDate = new Date();
//         // let hostname = "TT_1_U4_G-HRA";
//         const resonablestatusarray = [
//             "Absconded",
//             "Hold",
//             "Terminate",
//             "Releave Employee",
//             "Not Joined",
//             "Postponed",
//             "Rejected",
//             "Closed",
//         ];
//         //version mismatch
//         if (!username || !password) {
//             return next(new ErrorHandler("Please enter username and password", 400));
//         }
//         // Check if email & password entered by user
//         if (applogin === true && version !== "1.8.0" && version !== "1.9.0" && version !== "1.11.0" && version !== "1.10.0" && version !== "1.12.0" && version !== "1.13.0" && version !== "1.14.0") {
//             return next(new ErrorHandler("Please Update current version!..", 400));
//         }

//         if (applogin === undefined || version === undefined) {
//             return next(new ErrorHandler("Please Update current version!..", 400));
//         }
//         // Finding if user exists in database
//         const user = await User.findOne({
//             resonablestatus: {
//                 $nin: [
//                     "Not Joined",
//                     "Postponed",
//                     "Rejected",
//                     "Closed",
//                     "Releave Employee",
//                     "Absconded",
//                     "Hold",
//                     "Terminate",
//                 ],
//             },
//             username,
//         }).select("+password");
//         if (!user) {
//             return next(
//                 new ErrorHandler(
//                     "Login Restricted! Please Enter Valid Username&Password",
//                     401
//                 )
//             );
//         }


//         const userUniqueAddresss = user?.loginUserStatus?.find(data => data?.username === systemname && macAddress === data?.macaddress)
//         appUpdateCalculation = userUniqueAddresss ? 7 - (Math.floor((new Date().getTime() - new Date(userUniqueAddresss?.createdAt).getTime()) / (1000 * 60 * 60 * 24))) : 7;


//         // If checks password is correct or not
//         const isPwdMatched = await bcrypt.compare(password, user.password);

//         if (!isPwdMatched) {
//             return next(new ErrorHandler("Invalid Password", 401));
//         }
//         if (resonablestatusarray.includes(user?.resonablestatus)) {
//             return next(new ErrorHandler("Login Restricted", 401));
//         }

//         const overallsettings = await AdminOverAllSettings.find();
//         const clockinip = await ClockinIP.find({ branch: user?.branch });
//         let individualsettings = await IndividualSettings.find({
//             company: user?.company,
//             branch: user?.branch,
//             unit: user?.unit,
//             team: user?.team,
//             companyname: { $in: user?.companyname },
//         });
//         let individualtwofaswitch = individualsettings?.find((item) =>
//             item.companyname.includes(user?.companyname)
//         );


//         let autoLogoutTime = await AutoLogout.aggregate([
//             {
//                 $facet: {
//                     matchedData: [
//                         {
//                             $unwind: "$todos"
//                         },
//                         {
//                             $match: {
//                                 "todos.employeename":
//                                     user.companyname
//                             }
//                         },
//                         {
//                             $project: {
//                                 autologoutmins:
//                                     "$todos.autologoutmins"
//                             }
//                         }
//                     ],
//                     notMatched: [
//                         {
//                             $match: {
//                                 autologoutswitch: true
//                             }
//                         },
//                         {
//                             $project: {
//                                 autologoutmins: "$autologoutmins"
//                             }
//                         }
//                     ]
//                 }
//             },
//             {
//                 $project: {
//                     result: {
//                         $cond: {
//                             if: {
//                                 $gt: [{ $size: "$matchedData" }, 0]
//                             },
//                             then: "$matchedData",
//                             else: "$notMatched"
//                         }
//                     }
//                 }
//             }
//         ])


//         let checkAutoLogoutTime = autoLogoutTime[0].result?.length > 0 ? autoLogoutTime[0].result[0]?.autologoutmins : 5;

//         const dateCheck = new Date();
//         dateCheck.setMinutes(dateCheck.getMinutes() + Number(checkAutoLogoutTime));
//         let checkAutoLogoutDate = req?.body?.checkautologout === "check" ? dateCheck : "none"
//         let overallLoginByWorkStation =
//             overallsettings[overallsettings.length - 1]?.loginbyworkstation
//                 ? overallsettings[overallsettings.length - 1]?.loginbyworkstation
//                 : {
//                     primary: true,
//                     secondary: true,
//                     wfh: true,
//                     unauthorized: true,
//                 };
//         let indiviDualLoginByWorkStation =
//             individualtwofaswitch?.loginbyworkstation
//                 ? individualtwofaswitch?.loginbyworkstation
//                 : {};
//         let finalLoginByWorkStation = Object.entries(indiviDualLoginByWorkStation)?.length > 0 ? indiviDualLoginByWorkStation : overallLoginByWorkStation;
//         let externalurl =
//             overallsettings[overallsettings.length - 1]?.externalurl?.length > 0
//                 ? overallsettings[overallsettings.length - 1]?.externalurl?.map(
//                     (item) => new URL(item).hostname
//                 )
//                 : [];
//         let internalurl =
//             overallsettings[overallsettings.length - 1]?.internalurl?.length > 0
//                 ? overallsettings[overallsettings.length - 1]?.internalurl?.map(
//                     (item) => new URL(item).hostname
//                 )
//                 : [];

//         let finalLoginMode = individualtwofaswitch
//             ? individualtwofaswitch?.loginmode
//             : overallsettings[overallsettings.length - 1]?.loginmode;
//         if (internalurl?.length === 0 ||
//             externalurl?.length === 0
//         ) {

//             return next(
//                 new ErrorHandler(`UnAuthorized Login 1, Contact Administrator`, 401)
//             );
//         }

//         if (
//             currenturl !== undefined &&
//             finalLoginMode === "Internal Login" &&
//             !internalurl?.includes(currenturl) &&
//             !user.role?.includes("Manager")
//         ) {

//             return next(
//                 new ErrorHandler(`UnAuthorized Login 2, Contact Administrator`, 401)
//             );
//         } else if (
//             currenturl !== undefined &&
//             finalLoginMode === "External Login" &&
//             !externalurl?.includes(currenturl) &&
//             !user.role?.includes("Manager")
//         ) {
//             return next(
//                 new ErrorHandler(`UnAuthorized Login 3,Contact Administrator`, 401)
//             );
//         }
//         else if (
//             currenturl !== undefined &&
//             finalLoginMode === "Both Login" &&
//             (!externalurl?.includes(currenturl) &&
//                 !internalurl?.includes(currenturl)) &&
//             !user.role?.includes("Manager")
//         ) {

//             return next(
//                 new ErrorHandler(`UnAuthorized Login 4,Contact Administrator`, 401)
//             );
//         }

//         //   if (!user.role.includes("Manager")) {
//         const today = moment();
//         const pastThreeAttendaysDays = [
//             today.clone().format("DD-MM-YYYY"),
//             today.clone().subtract(1, "days").format("DD-MM-YYYY"),
//             today.clone().subtract(2, "days").format("DD-MM-YYYY"),
//             today.clone().subtract(3, "days").format("DD-MM-YYYY"),
//         ];
//         const pastThreeLeaveDays = [
//             today.clone().format("DD/MM/YYYY"),

//             today.clone().subtract(1, "days").format("DD/MM/YYYY"),
//             today.clone().subtract(2, "days").format("DD/MM/YYYY"),
//             today.clone().subtract(3, "days").format("DD/MM/YYYY"),
//         ];
//         const pastThreeDaysISO = [
//             today.clone().format("YYYY-MM-DD"),
//             today.clone().subtract(1, "days").format("YYYY-MM-DD"),
//             today.clone().subtract(2, "days").format("YYYY-MM-DD"),
//             today.clone().subtract(3, "days").format("YYYY-MM-DD"),
//         ];

//         // Fetch relevant attendance records, leave records, and holidays for the specific user in parallel
//         const [attendance, allLeaveStatus, holidays] = await Promise.all([
//             // Fetch relevant attendance records for the past 3 days for the specific user
//             Attendance.find(
//                 {
//                     date: {
//                         $in: pastThreeAttendaysDays,
//                     },
//                     userid: user._id,
//                 },
//                 { date: 1, userid: 1 }
//             ).lean(),

//             // Fetch relevant leave records for the specific user
//             ApplyLeave.find(
//                 {
//                     date: { $in: pastThreeLeaveDays },
//                     employeeid: user.empcode,
//                     employeename: user.companyname,
//                     status: { $nin: ["Rejected"] },
//                 },
//                 { employeename: 1, employeeid: 1, date: 1 }
//             ).lean(),

//             // Fetch relevant holidays for the specific user
//             Holiday.find(
//                 {
//                     date: { $in: pastThreeDaysISO },
//                     company: { $in: [user.company] }, // Checks if user's company is in the company array
//                     applicablefor: { $in: [user.branch] }, // Checks if user's branch is in the applicablefor array
//                     unit: { $in: [user.unit] }, // Checks if user's unit is in the unit array
//                     team: { $in: [user.team] }, // Checks if user's team is in the team array
//                     employee: { $in: [user.companyname, "ALL"] }, // This checks if 'user.companyname' or 'ALL' is in the employee array
//                 },
//                 { date: 1, employee: 1 }
//             ).lean(),
//         ]);

//         // Continue with your logic

//         // Create maps for attendance, leave, and holidays for quick lookup

//         const attendanceMap = attendance.reduce((acc, item) => {
//             const date = moment(item.date, "DD-MM-YYYY").format("DD/MM/YYYY");
//             acc[date] = true;
//             return acc;
//         }, {});
//         const myCheckList = await MyCheckList.find({ candidatename: { $in: [user.companyname] } }).lean();
//         let leaveWithCheckList = allLeaveStatus.map((item) => {
//             let foundData = myCheckList?.find(
//                 (dataNew) => dataNew.commonid == item._id
//             );
//             let areAllGroupsCompleted = foundData?.groups?.every(
//                 (itemNew) => (itemNew.data !== undefined && itemNew.data !== "") || itemNew.files !== undefined
//             );

//             if (areAllGroupsCompleted) {
//                 return {
//                     ...item,
//                     updatestatus: "Completed",
//                 };
//             }
//             return null;
//         }).filter(item => item);
//         const leaveMap = leaveWithCheckList.reduce((acc, item) => {
//             item.date.forEach((date) => {
//                 acc[date] = true;
//             });
//             return acc;
//         }, {});

//         const holidayMap = holidays.reduce((acc, item) => {
//             const date = moment(item.date).format("DD/MM/YYYY");
//             acc[date] = true;
//             return acc;
//         }, {});

//         // Function to check the status for the past 3 days
//         const checkStatusForPast3Days = (weekOffDays) => {
//             let absentDays = 0;
//             let leaveDays = 0;
//             let holidayDays = 0;

//             for (let date of pastThreeLeaveDays) {
//                 // const dayOfWeek = moment(date, "DD/MM/YYYY").format("dddd"); // Get day of the week

//                 // if (weekOffDays.includes(dayOfWeek)) {
//                 //   continue; // Skip week off days
//                 // }
//                 if (attendanceMap[date]) {
//                     // User was present on this date
//                     continue;
//                 } else if (leaveMap[date]) {
//                     // User was on leave on this date
//                     leaveDays++;
//                 } else if (holidayMap[date]) {
//                     // User had a holiday on this date

//                     holidayDays++;
//                 } else {
//                     // User was absent on this date
//                     absentDays++;
//                 }
//             }

//             if (absentDays >= 4) {
//                 return "Long Absent";
//             } else if (leaveDays >= 4) {
//                 return "Long Leave";
//             } else if (holidayDays >= 4) {
//                 return null;
//             } else {
//                 return null;
//             }
//         };

//         // Function to determine the final status
//         const determineStatus = (attendanceStatus, livestatus) => {
//             if (attendanceStatus) {
//                 return attendanceStatus;
//             } else if (livestatus) {
//                 return livestatus;
//             } else {
//                 return "No Status";
//             }
//         };
//         let weekOffDays = [];
//         if (user.boardingLog && user.boardingLog.length > 0) {
//             const lastBoardingLog = user.boardingLog[user.boardingLog.length - 1];
//             weekOffDays = lastBoardingLog.weekoff || [];
//         }
//         // Determine the user's status
//         const attendanceStatus = checkStatusForPast3Days(weekOffDays);
//         const livestatus = !attendanceStatus ? "Live" : null;

//         const userStatus = determineStatus(attendanceStatus, livestatus);

//         const todaydate = moment().format("DD-MM-YYYY");
//         const tomorrow = moment().add(1, "days").format("DD-MM-YYYY");
//         const dayAfterTomorrow = moment().add(2, "days").format("DD-MM-YYYY");
//         const dateArray = [todaydate, tomorrow, dayAfterTomorrow];

//         let checkArray = user?.longleaveabsentaprooveddate?.every(
//             (date) => !dateArray.includes(date)
//         );
//         if (
//             !pastThreeDaysISO?.includes(user?.doj) &&
//             (userStatus === "Long Absent" || userStatus === "Long Leave") &&
//             Array.isArray(user?.longleaveabsentaprooveddate) &&
//             checkArray &&
//             !user.role.includes("Manager")
//         ) {
//             return next(
//                 new ErrorHandler(
//                     `Login Restricted! You're in ${userStatus}, Please Contact Administrator`,
//                     401
//                 )
//             );
//         }

//         controlcriteria = await ControlCriteria.find();
//         const lastCriteria = controlcriteria?.[controlcriteria.length - 1];
//         userCheckInControlCriteria = lastCriteria?.weekofftodos?.find(data =>
//             data?.employeename === user?.companyname &&
//             data?.company === user?.company &&
//             data?.branch === user?.branch &&
//             data?.unit === user?.unit
//         );
//         const holidayWeekOffData = await HolidayWeekOffRestriction.findOne({ companyname: user?.companyname, date: moment().format("YYYY-MM-DD") });
//         holidayWeekOffRestriction = holidayWeekOffData ? true : false;





//         let adminTwofaswitch, loginswitch;
//         if (overallsettings.length === 0) {
//             adminTwofaswitch = true;
//             loginswitch = true;
//         } else {
//             adminTwofaswitch =
//                 overallsettings[overallsettings.length - 1].overalltwofaswitch;
//             loginswitch =
//                 overallsettings[overallsettings.length - 1].loginrestrictionswitch;
//         }

//         let loginapprestriction = user?.extramode
//             ? user?.extramode
//             : individualtwofaswitch
//                 ? individualtwofaswitch?.loginapprestriction
//                 : overallsettings[overallsettings.length - 1]?.loginapprestriction;
//         let restrictionBtwShift = individualtwofaswitch
//             ? individualtwofaswitch?.loginapprestriction
//             : overallsettings[overallsettings.length - 1]?.loginapprestriction;

//         let check = individualtwofaswitch
//             ? individualtwofaswitch?.twofaswitch
//             : adminTwofaswitch;
//         let checkLogin = individualtwofaswitch
//             ? individualtwofaswitch?.loginipswitch
//             : loginswitch;

//         const WorkStationShortName = await WorkStationShortNameGeneration();
//         const checkWorkStationAccess = (matchedWorkStation, finalLoginByWorkStation) => {
//             if (!finalLoginByWorkStation) return true; // Handle undefined/null case

//             switch (matchedWorkStation) {
//                 case "Work From Home":
//                     return finalLoginByWorkStation?.wfh === true;
//                 case "Secondary WorkStation":
//                     return finalLoginByWorkStation?.secondary === true;
//                 case "Primary WorkStation":
//                     return finalLoginByWorkStation?.primary === true;
//                 case "":
//                     return finalLoginByWorkStation?.unauthorized === true;
//                 default:
//                     return false;
//             }
//         };

//         const workStationFind = WorkStationShortName?.find(data => data?.systemshortname === hostname)
//         const workstationNames = user?.workstation;
//         let matchedWorkStation = "";
//         let matchedUserWorkStation = "";

//         if (workstationNames[0] === `${workStationFind?.cabinname}(${workStationFind?.branch}-${workStationFind?.floor})`) {

//             matchedUserWorkStation = user?.workstation?.find(data => data === `${workStationFind?.cabinname}(${workStationFind?.branch}-${workStationFind?.floor})`)
//             matchedWorkStation = "Primary WorkStation";

//         } else if (workstationNames?.slice(1, user?.workstation?.length).includes(`${workStationFind?.cabinname}(${workStationFind?.branch}-${workStationFind?.floor})`)) {

//             matchedUserWorkStation = user?.workstation?.find(data => data === `${workStationFind?.cabinname}(${workStationFind?.branch}-${workStationFind?.floor})`)
//             matchedWorkStation = "Secondary WorkStation";

//         } else if (user?.workstationinput?.slice(0, 15) === hostname) {

//             matchedUserWorkStation = user?.workstationinput
//             matchedWorkStation = "Work From Home";
//         }

//         let loginByWorkStation = await checkWorkStationAccess(matchedWorkStation, finalLoginByWorkStation);

//         if (req.body.macAddress !== "none" && !user?.role?.includes("Manager") && !loginByWorkStation) {
//             return next(
//                 new ErrorHandler(
//                     `This WorkStation Login Restricted!! Please Login Authorized WorkStation!!!`,
//                     401
//                 )
//             );
//         }

//         MatchedNotMatched = ["Primary WorkStation", "Secondary WorkStation", "Work From Home"].includes(matchedWorkStation) ? "Matched" : "Not-Matched";
//         const userSecondaryWorkStationCount = user?.loginUserStatus?.length > 0 ? user?.loginUserStatus?.filter(data => data.matched === 'Secondary WorkStation') : []
//         const countWorStation = matchedWorkStation === "Primary WorkStation" ?
//             1 : matchedWorkStation === "Secondary WorkStation" ? 2 : 0

//         user["sigindate"] = moment().format("DD-MM-YYYY");
//         const result = await user.save();
//         if (user?.loginUserStatus?.length > 0) {
//             const remaining = user?.loginUserStatus
//                 ?.map((data) => {
//                     if (data.macaddress === macAddress || data.hostname === hostname) {
//                         data['status'] = "Active",
//                             data['date'] = PresenLoginUserDate,
//                             data['version'] = version,
//                             data['hostname'] = hostname,
//                             data['workstation'] = matchedUserWorkStation,
//                             data['matchedstatus'] = MatchedNotMatched,
//                             data['matched'] = matchedWorkStation,
//                             data['count'] = countWorStation

//                     } else {
//                         data['status'] = "Inactive"
//                     }
//                     return data
//                 }
//                 );
//             user["loginUserStatus"] = remaining;
//             const resultloginUserStatus = await user.save();
//         }

//         var logincheck;
//         if (clockinip?.length === 0) {
//             logincheck = "NOTSHOW";
//         } else {
//             logincheck = "SHOW";
//         }
//         const isIpInData = clockinip?.some((entry) =>
//             entry.ipaddress.includes(publicIP)
//         );
//         if (
//             checkLogin &&
//             !user.role.includes("Manager") &&
//             logincheck === "SHOW" &&
//             !isIpInData
//         ) {
//             return next(new ErrorHandler("Login Restricted", 401));
//         }
//         const userMacTwoFatrue = user?.loginUserStatus?.some(
//             (data) => (data.macaddress === macAddress || data.hostname === hostname) && data?.twofaenabled === true
//         );


//         if (!userMacTwoFatrue && check && !user.role.includes("Manager")) {

//             // authenticator.options = { step: 60 };
//             const secret = authenticator.generateSecret();
//             const uri = authenticator.keyuri(user?.companyname, "HILIFE.AI", secret);
//             const image = await qrcode.toDataURL(uri);
//             if (
//                 user?.loginUserStatus?.length == 0 ||
//                 user?.loginUserStatus === undefined
//             ) {
//                 user["loginUserStatus"] = {
//                     macaddress: macAddress,
//                     username: systemname,
//                     localip: localIp,
//                     status: "Active",
//                     twofatempsecret: secret,
//                     hostname: hostname,
//                     twofaenabled: false,
//                     version: version,
//                     workstation: matchedUserWorkStation,
//                     matchedstatus: MatchedNotMatched,
//                     matched: matchedWorkStation,
//                     count: countWorStation,
//                     date: PresenLoginUserDate

//                 };
//                 const result = await user.save();
//                 return res.status(201).json({
//                     generateqr: true,
//                     image,
//                     result,
//                     loginapprestriction,
//                     checkAutoLogoutTime,
//                     checkAutoLogoutDate,
//                     controlcriteria,
//                     MatchedNotMatched,
//                     resversion,
//                     matchedWorkStation,
//                     appUpdateCalculation,
//                     restrictionBtwShift,
//                     holidayWeekOffRestriction,
//                     userCheckInControlCriteria
//                 });
//             } else if (user?.loginUserStatus?.length > 0) {
//                 const gesyscont = user?.loginUserStatus.filter((data) => {
//                     return data.macaddress != "none";
//                 });

//                 if (macAddress != "none") {
//                     if (
//                         ((Number(user?.employeecount) + Number(user?.wfhcount)) === gesyscont?.length) &&
//                         !user?.loginUserStatus?.some(
//                             (data) => (data.macaddress === macAddress || data.hostname === hostname)
//                         )
//                     ) {
//                         return next(
//                             new ErrorHandler(
//                                 "Reached Your System Count.Please Contact Administrator",
//                                 401
//                             )
//                         );
//                     } else {
//                         const remaining = user?.loginUserStatus
//                             ?.filter((data) => data.macaddress !== macAddress && data.hostname !== hostname)
//                             ?.map((dar) => ({ ...dar, status: "Inactive" }));

//                         user["loginUserStatus"] = [
//                             ...remaining,
//                             {
//                                 macaddress: macAddress,

//                                 username: systemname,
//                                 localip: localIp,
//                                 status: "Active",
//                                 hostname: hostname,
//                                 twofatempsecret: secret,
//                                 twofaenabled: false,
//                                 version: version,
//                                 workstation: matchedUserWorkStation,
//                                 matchedstatus: MatchedNotMatched,
//                                 matched: matchedWorkStation,
//                                 count: countWorStation,
//                                 date: PresenLoginUserDate
//                             },
//                         ];
//                         const result = await user.save();
//                         return res.status(201).json({
//                             generateqr: true,
//                             image,
//                             result,
//                             loginapprestriction,
//                             checkAutoLogoutTime,
//                             checkAutoLogoutDate,
//                             controlcriteria,
//                             MatchedNotMatched,
//                             resversion,
//                             matchedWorkStation,
//                             appUpdateCalculation,
//                             restrictionBtwShift,
//                             holidayWeekOffRestriction,
//                             userCheckInControlCriteria
//                         });
//                     }
//                 } else {
//                     if (macAddress != "none") {
//                         const remaining = user?.loginUserStatus
//                             ?.filter((data) => (data.macaddress !== macAddress || data.hostname !== hostname))
//                             ?.map((dar) => ({ ...dar, status: "Inactive" }));

//                         user["loginUserStatus"] = [
//                             ...remaining,
//                             {
//                                 macaddress: macAddress,
//                                 username: systemname,
//                                 localip: localIp,
//                                 status: "Active",
//                                 hostname: hostname,
//                                 twofatempsecret: secret,
//                                 twofaenabled: false,
//                                 version: version,
//                                 workstation: matchedUserWorkStation,
//                                 matchedstatus: MatchedNotMatched,
//                                 matched: matchedWorkStation,
//                                 count: countWorStation,
//                                 date: PresenLoginUserDate
//                             },
//                         ];

//                         const result = await user.save();
//                         return res.status(201).json({
//                             generateqr: true,
//                             image,
//                             result,
//                             loginapprestriction,
//                             checkAutoLogoutTime,
//                             checkAutoLogoutDate,
//                             controlcriteria,
//                             MatchedNotMatched,
//                             resversion,
//                             matchedWorkStation,
//                             appUpdateCalculation,
//                             restrictionBtwShift,
//                             holidayWeekOffRestriction,
//                             userCheckInControlCriteria
//                         });
//                     } else {
//                         const result = user;
//                         return res.status(201).json({
//                             generateqr: true,
//                             image,

//                             result,
//                             loginapprestriction,
//                             checkAutoLogoutTime,
//                             checkAutoLogoutDate,
//                             controlcriteria,
//                             MatchedNotMatched,
//                             resversion,
//                             matchedWorkStation,
//                             appUpdateCalculation,
//                             restrictionBtwShift,
//                             holidayWeekOffRestriction,
//                             userCheckInControlCriteria
//                         });
//                     }
//                 }
//             }
//         } else if (userMacTwoFatrue && check && !user.role.includes("Manager")) {
//             if (!otp) {
//                 const remaining = user?.loginUserStatus
//                     ?.filter((data) => data.macaddress !== macAddress)
//                     ?.map((dar) => ({ ...dar, status: "Inactive" }));

//                 return res.status(201).json({
//                     otpneeded: true,
//                     loginapprestriction,
//                     checkAutoLogoutTime,
//                     checkAutoLogoutDate,
//                     controlcriteria,
//                     MatchedNotMatched,
//                     resversion,
//                     matchedWorkStation,
//                     appUpdateCalculation,
//                     restrictionBtwShift,
//                     holidayWeekOffRestriction,
//                     userCheckInControlCriteria
//                 });
//             }

//             const userMacTwoFaSecret = user?.loginUserStatus?.find(
//                 (data) => (data.macaddress === macAddress || data.hostname === hostname) && data?.twofaenabled === true
//             );

//             const remaining = user?.loginUserStatus
//                 ?.map((data) => {
//                     if (data.macaddress === macAddress || data.hostname === hostname) {
//                         data['status'] = "Active",
//                             data['date'] = PresenLoginUserDate
//                     } else {
//                         data['status'] = "Inactive"
//                     }
//                     return data
//                 }
//                 );
//             user["loginUserStatus"] = remaining;
//             const result = await user.save();
//             const verified = authenticator.check(otp, userMacTwoFaSecret.twofasecret);

//             if (!verified) {
//                 return next(new ErrorHandler("Kindly check your WinAuth QR code! Invalid Otp", 401));
//             }
//             checksendToken(result, 200, res, loginapprestriction, checkAutoLogoutTime,
//                 checkAutoLogoutDate, controlcriteria, MatchedNotMatched, resversion,
//                 matchedWorkStation, appUpdateCalculation, restrictionBtwShift, holidayWeekOffRestriction, userCheckInControlCriteria);
//         } else {
//             const gesyscont = user?.loginUserStatus.filter((data) => {
//                 return data.macaddress != "none";
//             });
//             if (
//                 user?.loginUserStatus?.find((data) =>
//                     (data.macaddress === macAddress || data.hostname === hostname))
//             ) {
//                 const result = await user.save();
//                 checksendToken(result, 200, res, loginapprestriction, checkAutoLogoutTime,
//                     checkAutoLogoutDate, controlcriteria, MatchedNotMatched, resversion,
//                     matchedWorkStation, appUpdateCalculation, restrictionBtwShift, holidayWeekOffRestriction, userCheckInControlCriteria);
//             } else if (

//                 ((Number(user?.employeecount) + Number(user?.wfhcount)) === gesyscont?.length) &&
//                 macAddress !== "none" && hostname !== "none" &&
//                 !user?.loginUserStatus?.some((data) => (data.macaddress === macAddress || data.hostname === hostname))
//             ) {
//                 return next(
//                     new ErrorHandler(
//                         "Reached Your System Count.Please Contact Administrator",
//                         401
//                     )
//                 );
//             } else {
//                 if (macAddress !== "none") {
//                     const remaining = user?.loginUserStatus?.map((dar) => ({
//                         ...dar,
//                         status: "Inactive",
//                     }));

//                     user["loginUserStatus"] = [
//                         ...remaining,
//                         {
//                             macaddress: macAddress,
//                             username: systemname,
//                             hostname: hostname,
//                             localip: localIp,
//                             status: "Active",
//                             version: version,
//                             workstation: matchedUserWorkStation,
//                             matchedstatus: MatchedNotMatched,
//                             matched: matchedWorkStation,
//                             count: countWorStation,
//                             date: PresenLoginUserDate
//                         },
//                     ];
//                     // user["signintime"] = (todaydate && extraTime?.length > 0 && extraTime[0] === moment().format("YYYY-MM-DD")) ?
//                     // moment(user?.signintime).format("DD-MM-YYYY")=== moment().format("DD-MM-YYYY") ? "" : todaydate : ''

//                     const result = await user.save();
//                     checksendToken(
//                         result,
//                         200,
//                         res,
//                         loginapprestriction,
//                         checkAutoLogoutTime,
//                         checkAutoLogoutDate,
//                         controlcriteria,
//                         MatchedNotMatched, resversion,
//                         matchedWorkStation,
//                         appUpdateCalculation,
//                         restrictionBtwShift,
//                         holidayWeekOffRestriction,
//                         userCheckInControlCriteria
//                     );
//                 } else {
//                     checksendToken(user, 200, res, loginapprestriction, checkAutoLogoutTime,
//                         checkAutoLogoutDate, controlcriteria, MatchedNotMatched, resversion,
//                         matchedWorkStation, appUpdateCalculation, restrictionBtwShift, holidayWeekOffRestriction, userCheckInControlCriteria);
//                 }
//             }
//         }
//     } catch (err) {
//         console.log(err, 'er1')
//         return next(new ErrorHandler("User not found", 404));
//     }
// });



exports.updateDateAfterLogin = catchAsyncErrors(async (req, res, next) => {
    const { username, companyname } = req.body;
    const PresenLoginUserDate = new Date();
    try {
        const user = await User.findOne(
            { username, companyname },
            { loginUserStatus: 1 }
        );

        if (!user) {
            return next(new ErrorHandler("User not found", 404));
        }

        const updatedStatus = user.loginUserStatus.map((entry) => {
            if (entry.status === "Active") {
                return { ...entry, date: PresenLoginUserDate };
            }
            return entry;
        });

        user.loginUserStatus = updatedStatus;
        const result = await user.save();

        return res.status(200).json({
            success: true,
            message: "Login user status updated successfully",
            data: result.loginUserStatus
        });
    } catch (err) {
        return next(new ErrorHandler("Internal Server Error", 500));
    }
});


exports.logincheckAuth = catchAsyncErrors(async (req, res, next) => {
    let resversion = false;
    let appUpdateCalculation = 7;
    try {
        const { username, password, otp, publicIP, macAddress, systemname, currenturl, localIp, hostname, version, applogin } = req.body;
        let MatchedNotMatched;
        let controlcriteria;
        let holidayWeekOffRestriction;
        let userCheckInControlCriteria;
        resversion = version === '1.13.0' ? true : (resversion = version === '1.14.0' ? true : (resversion = version === '1.15.0' ? true : (resversion = version === '1.16.0' ? true : false)));

        // const PresenLoginUserDate = new Date();
        // let hostname = "TT_1_U4_G-HRA";
        const resonablestatusarray = ['Absconded', 'Hold', 'Terminate', 'Releave Employee', 'Not Joined', 'Postponed', 'Rejected', 'Closed'];
        //version mismatch
        if (!username || !password) {
            return next(new ErrorHandler('Please enter username and password', 400));
        }
        // Check if email & password entered by user
        if (applogin === true && version !== '1.13.0' && version !== '1.14.0' && version !== '1.15.0' && version !== '1.16.0') {
            return next(new ErrorHandler('Please Update current version!..', 400));
        }

        if (applogin === undefined || version === undefined) {
            return next(new ErrorHandler('Please Update current version!..', 400));
        }
        // Finding if user exists in database
        const user = await User.findOne({
            resonablestatus: {
                $nin: ['Not Joined', 'Postponed', 'Rejected', 'Closed', 'Releave Employee', 'Absconded', 'Hold', 'Terminate'],
            },

            username,
        }).select('+password');
        if (!user) {
            return next(new ErrorHandler('Login Restricted! Please Enter Valid Username&Password', 401));
        }

        const userUniqueAddresss = user?.loginUserStatus?.find((data) => data?.username === systemname && macAddress === data?.macaddress);
        appUpdateCalculation = userUniqueAddresss ? 7 - Math.floor((new Date().getTime() - new Date(userUniqueAddresss?.createdAt).getTime()) / (1000 * 60 * 60 * 24)) : 7;

        // If checks password is correct or not
        const isPwdMatched = await bcrypt.compare(password, user.password);

        if (!isPwdMatched) {
            return next(new ErrorHandler('Invalid Password', 401));
        }
        if (resonablestatusarray.includes(user?.resonablestatus)) {
            return next(new ErrorHandler('Login Restricted', 401));
        }

        const overallsettings = await AdminOverAllSettings.find({}, { loginbyworkstation: 1, externalurl: 1, internalurl: 1, loginmode: 1, overalltwofaswitch: 1, loginrestrictionswitch: 1, loginapprestriction: 1 });

        const clockinip = await ClockinIP.find({ branch: user?.branch });
        let individualsettings = await IndividualSettings.find({
            company: user?.company,
            branch: user?.branch,
            unit: user?.unit,
            team: user?.team,
            companyname: { $in: user?.companyname },
        });
        let individualtwofaswitch = individualsettings?.find((item) => item.companyname.includes(user?.companyname));

        let autoLogoutTime = await AutoLogout.aggregate([
            {
                $facet: {
                    matchedData: [
                        {
                            $unwind: '$todos',
                        },
                        {
                            $match: {
                                'todos.employeename': user.companyname,
                            },
                        },
                        {
                            $project: {
                                autologoutmins: '$todos.autologoutmins',
                            },
                        },
                    ],
                    notMatched: [
                        {
                            $match: {
                                autologoutswitch: true,
                            },
                        },
                        {
                            $project: {
                                autologoutmins: '$autologoutmins',
                            },
                        },
                    ],
                },
            },
            {
                $project: {
                    result: {
                        $cond: {
                            if: {
                                $gt: [{ $size: '$matchedData' }, 0],
                            },
                            then: '$matchedData',
                            else: '$notMatched',
                        },
                    },
                },
            },
        ]);

        let checkAutoLogoutTime = autoLogoutTime[0].result?.length > 0 ? autoLogoutTime[0].result[0]?.autologoutmins : 5;

        const dateCheck = new Date();
        dateCheck.setMinutes(dateCheck.getMinutes() + Number(checkAutoLogoutTime));
        let checkAutoLogoutDate = req?.body?.checkautologout === 'check' ? dateCheck : 'none';
        let overallLoginByWorkStation = overallsettings[overallsettings.length - 1]?.loginbyworkstation
            ? overallsettings[overallsettings.length - 1]?.loginbyworkstation
            : {
                primary: true,
                secondary: true,
                wfh: true,
                unauthorized: true,
            };
        let indiviDualLoginByWorkStation = individualtwofaswitch?.loginbyworkstation ? individualtwofaswitch?.loginbyworkstation : {};
        let finalLoginByWorkStation = Object.entries(indiviDualLoginByWorkStation)?.length > 0 ? indiviDualLoginByWorkStation : overallLoginByWorkStation;
        let externalurl = overallsettings[overallsettings.length - 1]?.externalurl?.length > 0 ? overallsettings[overallsettings.length - 1]?.externalurl?.map((item) => new URL(item).hostname) : [];
        let internalurl = overallsettings[overallsettings.length - 1]?.internalurl?.length > 0 ? overallsettings[overallsettings.length - 1]?.internalurl?.map((item) => new URL(item).hostname) : [];

        let finalLoginMode = individualtwofaswitch ? individualtwofaswitch?.loginmode : overallsettings[overallsettings.length - 1]?.loginmode;
        if (internalurl?.length === 0 || externalurl?.length === 0) {
            return next(new ErrorHandler(`UnAuthorized Login 1, Contact Administrator`, 401));
        }

        if (currenturl !== undefined && finalLoginMode === 'Internal Login' && !internalurl?.includes(currenturl) && !user.role?.includes('Manager')) {
            return next(new ErrorHandler(`UnAuthorized Login 2, Contact Administrator`, 401));
        } else if (currenturl !== undefined && finalLoginMode === 'External Login' && !externalurl?.includes(currenturl) && !user.role?.includes('Manager')) {
            return next(new ErrorHandler(`UnAuthorized Login 3,Contact Administrator`, 401));
        } else if (currenturl !== undefined && finalLoginMode === 'Both Login' && !externalurl?.includes(currenturl) && !internalurl?.includes(currenturl) && !user.role?.includes('Manager')) {
            return next(new ErrorHandler(`UnAuthorized Login 4,Contact Administrator`, 401));
        }

        const attendenceControlCriteria = await ControlCriteria.find({}, { allowedautoclockoutcount: 1 });

        const autoCLockOutCount = attendenceControlCriteria[0]?.allowedautoclockoutcount ? Number(attendenceControlCriteria[0]?.allowedautoclockoutcount) : 0;
        const finalautoCLockOutCount = autoCLockOutCount + 1;
        let checkAutoClockAttendance = [];

        if (autoCLockOutCount > 0) {
            checkAutoClockAttendance = await Attendance.find({ userid: user._id })
                .sort({ createdAt: -1 }) // Sort by latest date
                .limit(finalautoCLockOutCount) // Limit to the latest N records
                .exec();
        }

        let checkAutoClockOut = checkAutoClockAttendance?.length > 0 && checkAutoClockAttendance?.length === finalautoCLockOutCount && checkAutoClockAttendance?.every((data) => data?.autoclockout === true);

        if (!user.role.includes('Manager') && checkAutoClockOut && !user?.autoclockoutreleasedates?.includes(moment().format('DD-MM-YYYY'))) {
            return next(new ErrorHandler(`You're in Long Auto clockkout! Contact Supervisor`, 401));
        }

        //   if (!user.role.includes("Manager")) {
        const today = moment();
        const pastThreeAttendaysDays = [today.clone().format('DD-MM-YYYY'), today.clone().subtract(1, 'days').format('DD-MM-YYYY'), today.clone().subtract(2, 'days').format('DD-MM-YYYY'), today.clone().subtract(3, 'days').format('DD-MM-YYYY')];
        const pastThreeLeaveDays = [today.clone().format('DD/MM/YYYY'), today.clone().subtract(1, 'days').format('DD/MM/YYYY'), today.clone().subtract(2, 'days').format('DD/MM/YYYY'), today.clone().subtract(3, 'days').format('DD/MM/YYYY')];
        const pastThreeDaysISO = [today.clone().format('YYYY-MM-DD'), today.clone().subtract(1, 'days').format('YYYY-MM-DD'), today.clone().subtract(2, 'days').format('YYYY-MM-DD'), today.clone().subtract(3, 'days').format('YYYY-MM-DD')];

        // Fetch relevant attendance records, leave records, and holidays for the specific user in parallel
        const [attendance, allLeaveStatus, holidays] = await Promise.all([
            // Fetch relevant attendance records for the past 3 days for the specific user
            Attendance.find(
                {
                    date: {
                        $in: pastThreeAttendaysDays,
                    },
                    userid: user._id,
                },
                { date: 1, userid: 1 }
            ).lean(),

            // Fetch relevant leave records for the specific user
            ApplyLeave.find(
                {
                    date: { $in: pastThreeLeaveDays },
                    employeeid: user.empcode,
                    employeename: user.companyname,
                    status: { $nin: ['Rejected', 'Cancel'] },
                },
                { employeename: 1, employeeid: 1, date: 1 }
            ).lean(),

            // Fetch relevant holidays for the specific user
            Holiday.find(
                {
                    date: { $in: pastThreeDaysISO },
                    company: { $in: [user.company] }, // Checks if user's company is in the company array
                    applicablefor: { $in: [user.branch] }, // Checks if user's branch is in the applicablefor array
                    unit: { $in: [user.unit] }, // Checks if user's unit is in the unit array
                    team: { $in: [user.team] }, // Checks if user's team is in the team array
                    employee: { $in: [user.companyname, 'ALL'] }, // This checks if 'user.companyname' or 'ALL' is in the employee array
                },
                { date: 1, employee: 1 }
            ).lean(),
        ]);

        // Continue with your logic

        // Create maps for attendance, leave, and holidays for quick lookup

        const attendanceMap = attendance.reduce((acc, item) => {
            const date = moment(item.date, 'DD-MM-YYYY').format('DD/MM/YYYY');
            acc[date] = true;
            return acc;
        }, {});
        const myCheckList = await MyCheckList.find({ candidatename: { $in: [user.companyname] } }).lean();
        let leaveWithCheckList = allLeaveStatus
            .map((item) => {
                let foundData = myCheckList?.find((dataNew) => dataNew.commonid == item._id);
                let areAllGroupsCompleted = foundData?.groups?.every((itemNew) => (itemNew.data !== undefined && itemNew.data !== '') || itemNew.files !== undefined);

                if (areAllGroupsCompleted) {
                    return {
                        ...item,
                        updatestatus: 'Completed',
                    };
                }
                return null;
            })
            .filter((item) => item);
        const leaveMap = leaveWithCheckList.reduce((acc, item) => {
            item.date.forEach((date) => {
                acc[date] = true;
            });
            return acc;
        }, {});

        const holidayMap = holidays.reduce((acc, item) => {
            const date = moment(item.date).format('DD/MM/YYYY');
            acc[date] = true;
            return acc;
        }, {});

        // Function to check the status for the past 3 days
        const checkStatusForPast3Days = (weekOffDays) => {
            let absentDays = 0;
            let leaveDays = 0;
            let holidayDays = 0;

            for (let date of pastThreeLeaveDays) {
                // const dayOfWeek = moment(date, "DD/MM/YYYY").format("dddd"); // Get day of the week

                // if (weekOffDays.includes(dayOfWeek)) {
                //   continue; // Skip week off days
                // }
                if (attendanceMap[date]) {
                    // User was present on this date
                    continue;
                } else if (leaveMap[date]) {
                    // User was on leave on this date
                    leaveDays++;
                } else if (holidayMap[date]) {
                    // User had a holiday on this date

                    holidayDays++;
                } else {
                    // User was absent on this date
                    absentDays++;
                }
            }

            if (absentDays >= 4) {
                return 'Long Absent';
            } else if (leaveDays >= 4) {
                return 'Long Leave';
            } else if (holidayDays >= 4) {
                return null;
            } else {
                return null;
            }
        };

        // Function to determine the final status
        const determineStatus = (attendanceStatus, livestatus) => {
            if (attendanceStatus) {
                return attendanceStatus;
            } else if (livestatus) {
                return livestatus;
            } else {
                return 'No Status';
            }
        };
        let weekOffDays = [];
        if (user.boardingLog && user.boardingLog.length > 0) {
            const lastBoardingLog = user.boardingLog[user.boardingLog.length - 1];
            weekOffDays = lastBoardingLog.weekoff || [];
        }
        // Determine the user's status
        const attendanceStatus = checkStatusForPast3Days(weekOffDays);
        const livestatus = !attendanceStatus ? 'Live' : null;

        const userStatus = determineStatus(attendanceStatus, livestatus);

        const todaydate = moment().format('DD-MM-YYYY');
        const tomorrow = moment().add(1, 'days').format('DD-MM-YYYY');
        const dayAfterTomorrow = moment().add(2, 'days').format('DD-MM-YYYY');
        const dateArray = [todaydate, tomorrow, dayAfterTomorrow];

        let checkArray = user?.longleaveabsentaprooveddate?.every((date) => !dateArray.includes(date));
        if (
            !pastThreeDaysISO?.includes(user?.doj) &&
            new Date(user.doj) > new Date(pastThreeDaysISO[pastThreeDaysISO.length - 1].split('-').reverse().join('-')) &&
            (userStatus === 'Long Absent' || userStatus === 'Long Leave') &&
            Array.isArray(user?.longleaveabsentaprooveddate) &&
            checkArray &&
            !user.role.includes('Manager')
        ) {
            return next(new ErrorHandler(`Login Restricted! You're in ${userStatus}, Please Contact Administrator`, 401));
        }

        controlcriteria = await ControlCriteria.find();
        const lastCriteria = controlcriteria?.[controlcriteria.length - 1];
        userCheckInControlCriteria = lastCriteria?.weekofftodos?.find((data) => data?.employeename === user?.companyname && data?.company === user?.company && data?.branch === user?.branch && data?.unit === user?.unit);
        const holidayWeekOffData = await HolidayWeekOffRestriction.findOne({ companyname: user?.companyname, date: moment().format('YYYY-MM-DD') });
        holidayWeekOffRestriction = holidayWeekOffData ? true : false;

        let adminTwofaswitch, loginswitch;
        if (overallsettings.length === 0) {
            adminTwofaswitch = true;
            loginswitch = true;
        } else {
            adminTwofaswitch = overallsettings[overallsettings.length - 1].overalltwofaswitch;
            loginswitch = overallsettings[overallsettings.length - 1].loginrestrictionswitch;
        }

        let loginapprestriction = user?.extramode ? user?.extramode : individualtwofaswitch ? individualtwofaswitch?.loginapprestriction : overallsettings[overallsettings.length - 1]?.loginapprestriction;
        let restrictionBtwShift = individualtwofaswitch ? individualtwofaswitch?.loginapprestriction : overallsettings[overallsettings.length - 1]?.loginapprestriction;

        let check = individualtwofaswitch ? individualtwofaswitch?.twofaswitch : adminTwofaswitch;
        let checkLogin = individualtwofaswitch ? individualtwofaswitch?.loginipswitch : loginswitch;

        const WorkStationShortName = await WorkStationShortNameGeneration();
        const checkWorkStationAccess = (matchedWorkStation, finalLoginByWorkStation) => {
            if (!finalLoginByWorkStation) return true; // Handle undefined/null case

            switch (matchedWorkStation) {
                case 'Work From Home':
                    return finalLoginByWorkStation?.wfh === true;
                case 'Secondary WorkStation':
                    return finalLoginByWorkStation?.secondary === true;
                case 'Primary WorkStation':
                    return finalLoginByWorkStation?.primary === true;
                case '':
                    return finalLoginByWorkStation?.unauthorized === true;
                default:
                    return false;
            }
        };

        const workStationFind = WorkStationShortName?.find((data) => data?.systemshortname === hostname);
        const workstationNames = user?.workstation;
        let matchedWorkStation = '';
        let matchedUserWorkStation = '';

        if (workstationNames[0] === `${workStationFind?.cabinname}(${workStationFind?.branch}-${workStationFind?.floor})`) {
            matchedUserWorkStation = user?.workstation?.find((data) => data === `${workStationFind?.cabinname}(${workStationFind?.branch}-${workStationFind?.floor})`);
            matchedWorkStation = 'Primary WorkStation';
        } else if (workstationNames?.slice(1, user?.workstation?.length).includes(`${workStationFind?.cabinname}(${workStationFind?.branch}-${workStationFind?.floor})`)) {
            matchedUserWorkStation = user?.workstation?.find((data) => data === `${workStationFind?.cabinname}(${workStationFind?.branch}-${workStationFind?.floor})`);
            matchedWorkStation = 'Secondary WorkStation';
        } else if (user?.workstationinput?.slice(0, 15) === hostname) {
            matchedUserWorkStation = user?.workstationinput;
            matchedWorkStation = 'Work From Home';
        }

        let loginByWorkStation = await checkWorkStationAccess(matchedWorkStation, finalLoginByWorkStation);

        if (req.body.macAddress !== 'none' && !user?.role?.includes('Manager') && !loginByWorkStation) {
            return next(new ErrorHandler(`This WorkStation Login Restricted!! Please Login Authorized WorkStation!!!`, 401));
        }

        MatchedNotMatched = ['Primary WorkStation', 'Secondary WorkStation', 'Work From Home'].includes(matchedWorkStation) ? 'Matched' : 'Not-Matched';
        const userSecondaryWorkStationCount = user?.loginUserStatus?.length > 0 ? user?.loginUserStatus?.filter((data) => data.matched === 'Secondary WorkStation') : [];
        const countWorStation = matchedWorkStation === 'Primary WorkStation' ? 1 : matchedWorkStation === 'Secondary WorkStation' ? 2 : 0;

        user['sigindate'] = moment().format('DD-MM-YYYY');
        const result = await user.save();
        if (user?.loginUserStatus?.length > 0 && hostname !== 'none' && macAddress !== 'none') {
            const remaining = user?.loginUserStatus?.map((data) => {
                if (data.macaddress === macAddress || data.hostname === hostname) {
                    (data['status'] = 'Active'),
                        // (data['date'] = PresenLoginUserDate),
                        (data['version'] = version),
                        (data['hostname'] = hostname),
                        (data['workstation'] = matchedUserWorkStation),
                        (data['matchedstatus'] = MatchedNotMatched),
                        (data['matched'] = matchedWorkStation),
                        (data['count'] = countWorStation);
                } else {
                    data['status'] = 'Inactive';
                }
                return data;
            });
            user['loginUserStatus'] = remaining;
            const resultloginUserStatus = await user.save();
        }

        var logincheck;
        if (clockinip?.length === 0) {
            logincheck = 'NOTSHOW';
        } else {
            logincheck = 'SHOW';
        }
        const isIpInData = clockinip?.some((entry) => entry.ipaddress.includes(publicIP));
        if (checkLogin && !user.role.includes('Manager') && logincheck === 'SHOW' && !isIpInData) {
            return next(new ErrorHandler('Login Restricted', 401));
        }
        const userMacTwoFatrue = user?.loginUserStatus?.some((data) => (data.macaddress === macAddress || data.hostname === hostname) && data?.twofaenabled === true);

        if (!userMacTwoFatrue && check && !user.role.includes('Manager')) {
            // authenticator.options = { step: 60 };
            const secret = authenticator.generateSecret();
            const uri = authenticator.keyuri(user?.companyname, 'HILIFE.AI', secret);
            const image = await qrcode.toDataURL(uri);
            if (user?.loginUserStatus?.length == 0 || user?.loginUserStatus === undefined) {
                user['loginUserStatus'] = {
                    macaddress: macAddress,
                    username: systemname,
                    localip: localIp,
                    status: 'Active',
                    twofatempsecret: secret,
                    hostname: hostname,
                    twofaenabled: false,
                    version: version,
                    workstation: matchedUserWorkStation,
                    matchedstatus: MatchedNotMatched,
                    matched: matchedWorkStation,
                    count: countWorStation,
                    date: PresenLoginUserDate,
                };
                const result = await user.save();
                return res.status(201).json({
                    generateqr: true,
                    image,
                    result,
                    loginapprestriction,
                    checkAutoLogoutTime,
                    checkAutoLogoutDate,
                    controlcriteria,
                    MatchedNotMatched,
                    resversion,
                    matchedWorkStation,
                    appUpdateCalculation,
                    restrictionBtwShift,
                    holidayWeekOffRestriction,
                    userCheckInControlCriteria,
                });
            } else if (user?.loginUserStatus?.length > 0) {
                const gesyscont = user?.loginUserStatus.filter((data) => {
                    return data.macaddress != 'none';
                });

                if (macAddress != 'none') {
                    if (Number(user?.employeecount) + Number(user?.wfhcount) === gesyscont?.length && !user?.loginUserStatus?.some((data) => data.macaddress === macAddress || data.hostname === hostname)) {
                        return next(new ErrorHandler('Reached Your System Count.Please Contact Administrator', 401));
                    } else {
                        const remaining = user?.loginUserStatus?.filter((data) => data.macaddress !== macAddress && data.hostname !== hostname)?.map((dar) => ({ ...dar, status: 'Inactive' }));

                        user['loginUserStatus'] = [
                            ...remaining,
                            {
                                macaddress: macAddress,

                                username: systemname,
                                localip: localIp,
                                status: 'Active',
                                hostname: hostname,
                                twofatempsecret: secret,
                                twofaenabled: false,
                                version: version,
                                workstation: matchedUserWorkStation,
                                matchedstatus: MatchedNotMatched,
                                matched: matchedWorkStation,
                                count: countWorStation,
                                // date: PresenLoginUserDate,
                            },
                        ];
                        const result = await user.save();
                        return res.status(201).json({
                            generateqr: true,
                            image,
                            result,
                            loginapprestriction,
                            checkAutoLogoutTime,
                            checkAutoLogoutDate,
                            controlcriteria,
                            MatchedNotMatched,
                            resversion,
                            matchedWorkStation,
                            appUpdateCalculation,
                            restrictionBtwShift,
                            holidayWeekOffRestriction,
                            userCheckInControlCriteria,
                        });
                    }
                } else {
                    if (macAddress != 'none') {
                        const remaining = user?.loginUserStatus?.filter((data) => data.macaddress !== macAddress || data.hostname !== hostname)?.map((dar) => ({ ...dar, status: 'Inactive' }));

                        user['loginUserStatus'] = [
                            ...remaining,
                            {
                                macaddress: macAddress,
                                username: systemname,
                                localip: localIp,
                                status: 'Active',
                                hostname: hostname,
                                twofatempsecret: secret,
                                twofaenabled: false,
                                version: version,
                                workstation: matchedUserWorkStation,
                                matchedstatus: MatchedNotMatched,
                                matched: matchedWorkStation,
                                count: countWorStation,
                                // date: PresenLoginUserDate,
                            },
                        ];

                        const result = await user.save();
                        return res.status(201).json({
                            generateqr: true,
                            image,
                            result,
                            loginapprestriction,
                            checkAutoLogoutTime,
                            checkAutoLogoutDate,
                            controlcriteria,
                            MatchedNotMatched,
                            resversion,
                            matchedWorkStation,
                            appUpdateCalculation,
                            restrictionBtwShift,
                            holidayWeekOffRestriction,
                            userCheckInControlCriteria,
                        });
                    } else {
                        const result = user;
                        return res.status(201).json({
                            generateqr: true,
                            image,

                            result,
                            loginapprestriction,
                            checkAutoLogoutTime,
                            checkAutoLogoutDate,
                            controlcriteria,
                            MatchedNotMatched,
                            resversion,
                            matchedWorkStation,
                            appUpdateCalculation,
                            restrictionBtwShift,
                            holidayWeekOffRestriction,
                            userCheckInControlCriteria,
                        });
                    }
                }
            }
        } else if (userMacTwoFatrue && check && !user.role.includes('Manager')) {
            if (!otp) {
                const remaining = user?.loginUserStatus?.filter((data) => data.macaddress !== macAddress)?.map((dar) => ({ ...dar, status: 'Inactive' }));

                return res.status(201).json({
                    otpneeded: true,
                    loginapprestriction,
                    checkAutoLogoutTime,
                    checkAutoLogoutDate,
                    controlcriteria,
                    MatchedNotMatched,
                    resversion,
                    matchedWorkStation,
                    appUpdateCalculation,
                    restrictionBtwShift,
                    holidayWeekOffRestriction,
                    userCheckInControlCriteria,
                });
            }

            const userMacTwoFaSecret = user?.loginUserStatus?.find((data) => (data.macaddress === macAddress || data.hostname === hostname) && data?.twofaenabled === true);

            if (hostname !== 'none' && macAddress !== 'none') {
                const remaining = user?.loginUserStatus?.map((data) => {
                    if (data.macaddress === macAddress || data.hostname === hostname) {
                        (data['status'] = 'Active')
                        // (data['date'] = PresenLoginUserDate);
                    } else {
                        data['status'] = 'Inactive';
                    }
                    return data;
                });
                user['loginUserStatus'] = remaining;
                const result = await user.save();
            }
            const verified = authenticator.check(otp, userMacTwoFaSecret.twofasecret);
            console.log(verified, 'verified');
            if (!verified) {
                return next(new ErrorHandler('Kindly check your WinAuth QR code! Invalid Otp', 401));
            }
            checksendToken(result, 200, res, loginapprestriction, checkAutoLogoutTime, checkAutoLogoutDate, controlcriteria, MatchedNotMatched, resversion, matchedWorkStation, appUpdateCalculation, restrictionBtwShift, holidayWeekOffRestriction, userCheckInControlCriteria);
        } else {
            const gesyscont = user?.loginUserStatus.filter((data) => {
                return data.macaddress != 'none';
            });
            if (user?.loginUserStatus?.find((data) => data.macaddress === macAddress || data.hostname === hostname)) {
                const result = await user.save();
                checksendToken(result, 200, res, loginapprestriction, checkAutoLogoutTime, checkAutoLogoutDate, controlcriteria, MatchedNotMatched, resversion, matchedWorkStation, appUpdateCalculation, restrictionBtwShift, holidayWeekOffRestriction, userCheckInControlCriteria);
            } else if (Number(user?.employeecount) + Number(user?.wfhcount) === gesyscont?.length && macAddress !== 'none' && hostname !== 'none' && !user?.loginUserStatus?.some((data) => data.macaddress === macAddress || data.hostname === hostname)) {
                return next(new ErrorHandler('Reached Your System Count.Please Contact Administrator', 401));
            } else {
                if (macAddress !== 'none') {
                    const remaining = user?.loginUserStatus?.map((dar) => ({
                        ...dar,
                        status: 'Inactive',
                    }));

                    user['loginUserStatus'] = [
                        ...remaining,
                        {
                            macaddress: macAddress,
                            username: systemname,
                            hostname: hostname,
                            localip: localIp,
                            status: 'Active',
                            version: version,
                            workstation: matchedUserWorkStation,
                            matchedstatus: MatchedNotMatched,
                            matched: matchedWorkStation,
                            count: countWorStation,
                            //   date: PresenLoginUserDate,
                        },
                    ];
                    // user["signintime"] = (todaydate && extraTime?.length > 0 && extraTime[0] === moment().format("YYYY-MM-DD")) ?
                    // moment(user?.signintime).format("DD-MM-YYYY")=== moment().format("DD-MM-YYYY") ? "" : todaydate : ''

                    const result = await user.save();
                    checksendToken(result, 200, res, loginapprestriction, checkAutoLogoutTime, checkAutoLogoutDate, controlcriteria, MatchedNotMatched, resversion, matchedWorkStation, appUpdateCalculation, restrictionBtwShift, holidayWeekOffRestriction, userCheckInControlCriteria);
                } else {
                    checksendToken(user, 200, res, loginapprestriction, checkAutoLogoutTime, checkAutoLogoutDate, controlcriteria, MatchedNotMatched, resversion, matchedWorkStation, appUpdateCalculation, restrictionBtwShift, holidayWeekOffRestriction, userCheckInControlCriteria);
                }
            }
        }
    } catch (err) {
        console.log(err, 'er11 users');
        return next(new ErrorHandler('User not found', 404));
    }
});

exports.authenticateUser = catchAsyncErrors(async (req, res, next) => {
    try {
        let resversion = false;
        let appUpdateCalculation = 7;
        // const PresenLoginUserDate = new Date();
        const {
            username,
            password,
            otp,
            publicIP,
            macAddress,
            systemname,
            localIp,
            hostname,
            version,
            applogin,
            currenturl, faceDescriptor
        } = req.body;
        let controlcriteria, user;
        const resonablestatusarray = [
            "Absconded",
            "Hold",
            "Terminate",
            "Releave Employee",
            "Not Joined",
            "Postponed",
            "Rejected",
            "Closed",
        ];

        // Ensure faceDescriptor is an array of numbers
        if (
            !Array.isArray(faceDescriptor) ||
            !faceDescriptor.every((num) => typeof num === "number")
        ) {
            throw new Error("Invalid face descriptor format.");
        }

        // Fetch all user face descriptors from MongoDB
        const allUsers = await User.find(
            {
                resonablestatus: {
                    $nin: [
                        "Not Joined",
                        "Postponed",
                        "Rejected",
                        "Closed",
                        "Releave Employee",
                        "Absconded",
                        "Hold",
                        "Terminate",
                    ],
                },
                faceDescriptor: { $exists: true, $not: { $size: 0 } }
            },
            { faceDescriptor: 1 }
        ).lean();

        let authenticated = false;

        // Compare face descriptors
        for (const suser of allUsers) {
            const storedDescriptor = suser?.faceDescriptor;

            if (
                Array.isArray(storedDescriptor) &&
                storedDescriptor.length === faceDescriptor.length
            ) {
                const distance = faceapi.euclideanDistance(
                    faceDescriptor,
                    storedDescriptor
                );

                if (distance < 0.4) {
                    authenticated = true;
                    user = await User.findOne({ _id: suser._id });
                    break; // Exit loop once authenticated
                }
            }
        }
        if (!user && !authenticated) {
            return next(new ErrorHandler("Face Not Detected", 401));
        }

        if (resonablestatusarray.includes(user?.resonablestatus)) {
            return next(new ErrorHandler("Login Restricted", 401));
        }

        const overallsettings = await AdminOverAllSettings.find();
        const clockinip = await ClockinIP.find({ branch: user?.branch });
        let individualsettings = await IndividualSettings.find({
            company: user?.company,
            branch: user?.branch,
            unit: user?.unit,
            team: user?.team,
            companyname: { $in: user?.companyname },
        });
        let individualtwofaswitch = individualsettings?.find((item) =>
            item.companyname.includes(user?.companyname)
        );

        let autoLogoutTime = await AutoLogout.aggregate([
            {
                $facet: {
                    matchedData: [
                        {
                            $unwind: "$todos"
                        },
                        {
                            $match: {
                                "todos.employeename":
                                    user.companyname
                            }
                        },
                        {
                            $project: {
                                autologoutmins:
                                    "$todos.autologoutmins"
                            }
                        }
                    ],
                    notMatched: [
                        {
                            $match: {
                                autologoutswitch: true
                            }
                        },
                        {
                            $project: {
                                autologoutmins: "$autologoutmins"
                            }
                        }
                    ]
                }
            },
            {
                $project: {
                    result: {
                        $cond: {
                            if: {
                                $gt: [{ $size: "$matchedData" }, 0]
                            },
                            then: "$matchedData",
                            else: "$notMatched"
                        }
                    }
                }
            }
        ])


        let checkAutoLogoutTime = autoLogoutTime[0].result?.length > 0 ? autoLogoutTime[0].result[0]?.autologoutmins : 5;

        const dateCheck = new Date();
        dateCheck.setMinutes(dateCheck.getMinutes() + Number(checkAutoLogoutTime));
        let checkAutoLogoutDate = req?.body?.checkautologout === "check" ? dateCheck : "none"

        let externalurl =
            overallsettings[overallsettings.length - 1]?.externalurl?.length > 0
                ? overallsettings[overallsettings.length - 1]?.externalurl?.map(
                    (item) => new URL(item).hostname
                )
                : [];
        let internalurl =
            overallsettings[overallsettings.length - 1]?.internalurl?.length > 0
                ? overallsettings[overallsettings.length - 1]?.internalurl?.map(
                    (item) => new URL(item)?.hostname
                )
                : [];

        let finalLoginMode = individualtwofaswitch
            ? individualtwofaswitch?.loginmode
            : overallsettings[overallsettings.length - 1]?.loginmode;

        if (internalurl?.length === 0 ||
            externalurl?.length === 0
        ) {

            return next(
                new ErrorHandler(`UnAuthorized Login, Contact Administrator`, 401)
            );
        }

        if (
            currenturl !== undefined &&
            finalLoginMode === "Internal Login" &&
            !internalurl?.includes(currenturl) &&
            !user.role?.includes("Manager")
        ) {

            return next(
                new ErrorHandler(`UnAuthorized Login 2, Contact Administrator`, 401)
            );
        } else if (
            currenturl !== undefined &&
            finalLoginMode === "External Login" &&
            !externalurl?.includes(currenturl) &&
            !user.role?.includes("Manager")
        ) {
            return next(
                new ErrorHandler(`UnAuthorized Login 3,Contact Administrator`, 401)
            );
        }
        else if (
            currenturl !== undefined &&
            finalLoginMode === "Both Login" &&
            (!externalurl?.includes(currenturl) &&
                !internalurl?.includes(currenturl)) &&
            !user.role?.includes("Manager")
        ) {
            return next(
                new ErrorHandler(`UnAuthorized Login ,Contact Administrator`, 401)
            );
        }

        //   if (!user.role.includes("Manager")) {
        const today = moment();
        const pastThreeAttendaysDays = [
            today.clone().format("DD-MM-YYYY"),
            today.clone().subtract(1, "days").format("DD-MM-YYYY"),
            today.clone().subtract(2, "days").format("DD-MM-YYYY"),
            today.clone().subtract(3, "days").format("DD-MM-YYYY"),
        ];
        const pastThreeLeaveDays = [
            today.clone().format("DD/MM/YYYY"),

            today.clone().subtract(1, "days").format("DD/MM/YYYY"),
            today.clone().subtract(2, "days").format("DD/MM/YYYY"),
            today.clone().subtract(3, "days").format("DD/MM/YYYY"),
        ];
        const pastThreeDaysISO = [
            today.clone().format("YYYY-MM-DD"),
            today.clone().subtract(1, "days").format("YYYY-MM-DD"),
            today.clone().subtract(2, "days").format("YYYY-MM-DD"),
            today.clone().subtract(3, "days").format("YYYY-MM-DD"),
        ];

        // Fetch relevant attendance records, leave records, and holidays for the specific user in parallel
        const [attendance, allLeaveStatus, holidays] = await Promise.all([
            // Fetch relevant attendance records for the past 3 days for the specific user
            Attendance.find(
                {
                    date: {
                        $in: pastThreeAttendaysDays,
                    },
                    userid: user._id,
                },
                { date: 1, userid: 1 }
            ).lean(),

            // Fetch relevant leave records for the specific user
            ApplyLeave.find(
                {
                    date: { $in: pastThreeLeaveDays },
                    employeeid: user.empcode,
                    employeename: user.companyname,
                    status: { $nin: ["Rejected"] },
                },
                { employeename: 1, employeeid: 1, date: 1 }
            ).lean(),

            // Fetch relevant holidays for the specific user
            Holiday.find(
                {
                    date: { $in: pastThreeDaysISO },
                    company: { $in: [user.company] }, // Checks if user's company is in the company array
                    applicablefor: { $in: [user.branch] }, // Checks if user's branch is in the applicablefor array
                    unit: { $in: [user.unit] }, // Checks if user's unit is in the unit array
                    team: { $in: [user.team] }, // Checks if user's team is in the team array
                    employee: { $in: [user.companyname, "ALL"] }, // This checks if 'user.companyname' or 'ALL' is in the employee array
                },
                { date: 1, employee: 1 }
            ).lean(),
        ]);

        // Continue with your logic

        // Create maps for attendance, leave, and holidays for quick lookup

        const attendanceMap = attendance.reduce((acc, item) => {
            const date = moment(item.date, "DD-MM-YYYY").format("DD/MM/YYYY");
            acc[date] = true;
            return acc;
        }, {});
        const myCheckList = await MyCheckList.find({ candidatename: { $in: [user.companyname] } }).lean();
        let leaveWithCheckList = allLeaveStatus.map((item) => {
            let foundData = myCheckList?.find(
                (dataNew) => dataNew.commonid == item._id
            );
            let areAllGroupsCompleted = foundData?.groups?.every(
                (itemNew) => (itemNew.data !== undefined && itemNew.data !== "") || itemNew.files !== undefined
            );

            if (areAllGroupsCompleted) {
                return {
                    ...item,
                    updatestatus: "Completed",
                };
            }
            return null;
        }).filter(item => item);
        const leaveMap = leaveWithCheckList.reduce((acc, item) => {
            item.date.forEach((date) => {
                acc[date] = true;
            });
            return acc;
        }, {});

        const holidayMap = holidays.reduce((acc, item) => {
            const date = moment(item.date).format("DD/MM/YYYY");
            acc[date] = true;
            return acc;
        }, {});

        // Function to check the status for the past 3 days
        // Function to check the status for the past 3 days
        const checkStatusForPast3Days = (weekOffDays) => {
            let absentDays = 0;
            let leaveDays = 0;
            let holidayDays = 0;

            for (let date of pastThreeLeaveDays) {
                // const dayOfWeek = moment(date, "DD/MM/YYYY").format("dddd"); // Get day of the week

                // if (weekOffDays.includes(dayOfWeek)) {
                //   continue; // Skip week off days
                // }
                if (attendanceMap[date]) {
                    // User was present on this date
                    continue;
                } else if (leaveMap[date]) {
                    // User was on leave on this date
                    leaveDays++;
                } else if (holidayMap[date]) {
                    // User had a holiday on this date

                    holidayDays++;
                } else {
                    // User was absent on this date
                    absentDays++;
                }
            }

            if (absentDays >= 4) {
                return "Long Absent";
            } else if (leaveDays >= 4) {
                return "Long Leave";
            } else if (holidayDays >= 4) {
                return null;
            } else {
                return null;
            }
        };

        // Function to determine the final status
        const determineStatus = (attendanceStatus, livestatus) => {
            if (attendanceStatus) {
                return attendanceStatus;
            } else if (livestatus) {
                return livestatus;
            } else {
                return "No Status";
            }
        };
        let weekOffDays = [];
        if (user.boardingLog && user.boardingLog.length > 0) {
            const lastBoardingLog = user.boardingLog[user.boardingLog.length - 1];
            weekOffDays = lastBoardingLog.weekoff || [];
        }
        // Determine the user's status
        const attendanceStatus = checkStatusForPast3Days(weekOffDays);
        const livestatus = !attendanceStatus ? "Live" : null;

        const userStatus = determineStatus(attendanceStatus, livestatus);

        const todaydate = moment().format("DD-MM-YYYY");
        const tomorrow = moment().add(1, "days").format("DD-MM-YYYY");
        const dayAfterTomorrow = moment().add(2, "days").format("DD-MM-YYYY");
        const dateArray = [todaydate, tomorrow, dayAfterTomorrow];

        let checkArray = user?.longleaveabsentaprooveddate?.every(
            (date) => !dateArray.includes(date)
        );
        if (
            !pastThreeDaysISO?.includes(user?.doj) &&
            (userStatus === "Long Absent" || userStatus === "Long Leave") &&
            Array.isArray(user?.longleaveabsentaprooveddate) &&
            checkArray &&
            !user.role.includes("Manager")
        ) {
            return next(
                new ErrorHandler(
                    `Login Restricted! You're in ${userStatus}, Please Contact Administrator`,
                    401
                )
            );
        }

        controlcriteria = await ControlCriteria.find();
        const lastCriteria = controlcriteria?.[controlcriteria.length - 1];
        userCheckInControlCriteria = lastCriteria?.weekofftodos?.find(data =>
            data?.employeename === user?.companyname &&
            data?.company === user?.company &&
            data?.branch === user?.branch &&
            data?.unit === user?.unit
        );
        const holidayWeekOffData = await HolidayWeekOffRestriction.findOne({ companyname: user?.companyname, date: moment().format("YYYY-MM-DD") });
        holidayWeekOffRestriction = holidayWeekOffData ? true : false;


        let adminTwofaswitch, loginswitch;
        if (overallsettings.length === 0) {
            adminTwofaswitch = true;
            loginswitch = true;
        } else {
            adminTwofaswitch =
                overallsettings[overallsettings.length - 1].overalltwofaswitch;
            loginswitch =
                overallsettings[overallsettings.length - 1].loginrestrictionswitch;
        }

        let loginapprestriction = user?.extramode
            ? user?.extramode
            : individualtwofaswitch
                ? individualtwofaswitch?.loginapprestriction
                : overallsettings[overallsettings.length - 1]?.loginapprestriction;
        let restrictionBtwShift = individualtwofaswitch
            ? individualtwofaswitch?.loginapprestriction
            : overallsettings[overallsettings.length - 1]?.loginapprestriction;

        let check = individualtwofaswitch
            ? individualtwofaswitch?.twofaswitch
            : adminTwofaswitch;
        let checkLogin = individualtwofaswitch
            ? individualtwofaswitch?.loginipswitch
            : loginswitch;

        const WorkStationShortName = await WorkStationShortNameGeneration();

        const workStationFind = WorkStationShortName?.find(data => data?.systemshortname === hostname)
        const workstationNames = user?.workstation;
        let matchedWorkStation = "";
        let matchedUserWorkStation = "";

        if (workstationNames[0] === `${workStationFind?.cabinname}(${workStationFind?.branch}-${workStationFind?.floor})`) {

            matchedUserWorkStation = user?.workstation?.find(data => data === `${workStationFind?.cabinname}(${workStationFind?.branch}-${workStationFind?.floor})`)
            matchedWorkStation = "Primary WorkStation";

        } else if (workstationNames?.slice(1, user?.workstation?.length).includes(`${workStationFind?.cabinname}(${workStationFind?.branch}-${workStationFind?.floor})`)) {

            matchedUserWorkStation = user?.workstation?.find(data => data === `${workStationFind?.cabinname}(${workStationFind?.branch}-${workStationFind?.floor})`)
            matchedWorkStation = "Secondary WorkStation";

        } else if (user?.workstationinput?.slice(0, 15) === hostname) {

            matchedUserWorkStation = user?.workstationinput
            matchedWorkStation = "Work From Home";
        }

        MatchedNotMatched = ["Primary WorkStation", "Secondary WorkStation", "Work From Home"].includes(matchedWorkStation) ? "Matched" : "Not-Matched";
        const userSecondaryWorkStationCount = user?.loginUserStatus?.length > 0 ? user?.loginUserStatus?.filter(data => data.matched === 'Secondary WorkStation') : []
        const countWorStation = matchedWorkStation === "Primary WorkStation" ?
            1 : matchedWorkStation === "Secondary WorkStation" ? 2 : 0

        user["sigindate"] = moment().format("DD-MM-YYYY");
        const result = await user.save();

        var logincheck;
        if (clockinip?.length === 0) {
            logincheck = "NOTSHOW";
        } else {
            logincheck = "SHOW";
        }
        const isIpInData = clockinip?.some((entry) =>
            entry.ipaddress.includes(publicIP)
        );
        if (
            checkLogin &&
            !user.role.includes("Manager") &&
            logincheck === "SHOW" &&
            !isIpInData
        ) {
            return next(new ErrorHandler("Login Restricted", 401));
        }
        const userMacTwoFatrue = user?.loginUserStatus?.some(
            (data) => (data.macaddress === macAddress || data.hostname === hostname) && data?.twofaenabled === true
        );


        if (!userMacTwoFatrue && check && !user.role.includes("Manager")) {

            // authenticator.options = { step: 60 };
            const secret = authenticator.generateSecret();
            const uri = authenticator.keyuri(user?.companyname, "HILIFE.AI", secret);
            const image = await qrcode.toDataURL(uri);
            if (
                user?.loginUserStatus?.length == 0 ||
                user?.loginUserStatus === undefined
            ) {

                user["loginUserStatus"] = {
                    macaddress: macAddress,
                    username: systemname,
                    localip: localIp,
                    status: "Active",
                    twofatempsecret: secret,
                    hostname: hostname,
                    twofaenabled: false,
                    version: version,
                    workstation: matchedUserWorkStation,
                    matchedstatus: MatchedNotMatched,
                    matched: matchedWorkStation,
                    count: countWorStation,
                    // date: PresenLoginUserDate

                };
                const result = await user.save();
                return res.status(201).json({
                    generateqr: true,
                    image,
                    result,
                    loginapprestriction,
                    checkAutoLogoutTime,
                    checkAutoLogoutDate,
                    controlcriteria,
                    MatchedNotMatched,
                    resversion,
                    matchedWorkStation,
                    appUpdateCalculation,
                    restrictionBtwShift,
                    holidayWeekOffRestriction,
                    userCheckInControlCriteria
                });
            } else if (user?.loginUserStatus?.length > 0) {
                const gesyscont = user?.loginUserStatus.filter((data) => {
                    return data.macaddress != "none";
                });

                if (macAddress != "none") {
                    if (
                        ((Number(user?.employeecount) + Number(user?.wfhcount)) === gesyscont?.length) &&
                        !user?.loginUserStatus?.some(
                            (data) => (data.macaddress === macAddress || data.hostname === hostname)
                        )
                    ) {
                        return next(
                            new ErrorHandler(
                                "Reached Your System Count.Please Contact Administrator",
                                401
                            )
                        );
                    } else {
                        const remaining = user?.loginUserStatus
                            ?.filter((data) => data.macaddress !== macAddress && data.hostname !== hostname)
                            ?.map((dar) => ({ ...dar, status: "Inactive" }));

                        user["loginUserStatus"] = [
                            ...remaining,
                            {
                                macaddress: macAddress,

                                username: systemname,
                                localip: localIp,
                                status: "Active",
                                hostname: hostname,
                                twofatempsecret: secret,
                                twofaenabled: false,
                                version: version,
                                workstation: matchedUserWorkStation,
                                matchedstatus: MatchedNotMatched,
                                matched: matchedWorkStation,
                                count: countWorStation,
                                // date: PresenLoginUserDate
                            },
                        ];
                        const result = await user.save();
                        return res.status(201).json({
                            generateqr: true,
                            image,
                            result,
                            loginapprestriction,
                            checkAutoLogoutTime,
                            checkAutoLogoutDate,
                            controlcriteria,
                            MatchedNotMatched,
                            resversion,
                            matchedWorkStation,
                            appUpdateCalculation,
                            restrictionBtwShift,
                            holidayWeekOffRestriction,
                            userCheckInControlCriteria
                        });
                    }
                } else {
                    if (macAddress != "none") {
                        const remaining = user?.loginUserStatus
                            ?.filter((data) => (data.macaddress !== macAddress || data.hostname !== hostname))
                            ?.map((dar) => ({ ...dar, status: "Inactive" }));

                        user["loginUserStatus"] = [
                            ...remaining,
                            {
                                macaddress: macAddress,
                                username: systemname,
                                localip: localIp,
                                status: "Active",
                                hostname: hostname,
                                twofatempsecret: secret,
                                twofaenabled: false,
                                version: version,
                                workstation: matchedUserWorkStation,
                                matchedstatus: MatchedNotMatched,
                                matched: matchedWorkStation,
                                count: countWorStation,
                                // date: PresenLoginUserDate
                            },
                        ];

                        const result = await user.save();
                        return res.status(201).json({
                            generateqr: true,
                            image,
                            result,
                            loginapprestriction,
                            checkAutoLogoutTime,
                            checkAutoLogoutDate,
                            controlcriteria,
                            MatchedNotMatched,
                            resversion,
                            matchedWorkStation,
                            appUpdateCalculation,
                            restrictionBtwShift,
                            holidayWeekOffRestriction,
                            userCheckInControlCriteria
                        });
                    } else {
                        const result = user;
                        return res.status(201).json({
                            generateqr: true,
                            image,

                            result,
                            loginapprestriction,
                            checkAutoLogoutTime,
                            checkAutoLogoutDate,
                            controlcriteria,
                            MatchedNotMatched,
                            resversion,
                            matchedWorkStation,
                            appUpdateCalculation,
                            restrictionBtwShift,
                            holidayWeekOffRestriction,
                            userCheckInControlCriteria
                        });
                    }
                }
            }
        } else if (userMacTwoFatrue && check && !user.role.includes("Manager")) {
            if (!otp) {
                const remaining = user?.loginUserStatus
                    ?.filter((data) => data.macaddress !== macAddress)
                    ?.map((dar) => ({ ...dar, status: "Inactive" }));

                return res.status(201).json({
                    otpneeded: true,
                    loginapprestriction,
                    checkAutoLogoutTime,
                    checkAutoLogoutDate,
                    controlcriteria,
                    MatchedNotMatched,
                    resversion,
                    matchedWorkStation,
                    appUpdateCalculation,
                    restrictionBtwShift,
                    holidayWeekOffRestriction,
                    userCheckInControlCriteria
                });
            }

            const userMacTwoFaSecret = user?.loginUserStatus?.find(
                (data) => (data.macaddress === macAddress || data.hostname === hostname) && data?.twofaenabled === true
            );
            const remaining = user?.loginUserStatus
                ?.map((data) => {
                    if (data.macaddress === macAddress || data.hostname === hostname) {
                        data['status'] = "Active",
                            data['date'] = new Date()

                    } else {
                        data['status'] = "Inactive"
                    }
                    return data
                }
                );

            user["loginUserStatus"] = remaining;
            const result = await user.save();
            const verified = authenticator.check(otp, userMacTwoFaSecret.twofasecret);

            if (!verified) {
                return next(new ErrorHandler("Kindly check your WinAuth QR code! Invalid Otp", 401));
            }
            checksendToken(result, 200, res, loginapprestriction, checkAutoLogoutTime,
                checkAutoLogoutDate, controlcriteria, MatchedNotMatched, resversion,
                matchedWorkStation, appUpdateCalculation, restrictionBtwShift, holidayWeekOffRestriction, userCheckInControlCriteria);
        } else {
            const gesyscont = user?.loginUserStatus.filter((data) => {
                return data.macaddress != "none";
            });
            if (
                user?.loginUserStatus?.find((data) =>
                    (data.macaddress === macAddress || data.hostname === hostname))
            ) {
                const result = await user.save();
                checksendToken(result, 200, res, loginapprestriction, checkAutoLogoutTime,
                    checkAutoLogoutDate, controlcriteria, MatchedNotMatched, resversion,
                    matchedWorkStation, appUpdateCalculation, restrictionBtwShift, holidayWeekOffRestriction, userCheckInControlCriteria);
            } else if (

                ((Number(user?.employeecount) + Number(user?.wfhcount)) === gesyscont?.length) &&
                macAddress !== "none" && hostname !== "none" &&
                !user?.loginUserStatus?.some((data) => (data.macaddress === macAddress || data.hostname === hostname))
            ) {
                return next(
                    new ErrorHandler(
                        "Reached Your System Count.Please Contact Administrator",
                        401
                    )
                );
            } else {
                if (macAddress !== "none") {
                    const remaining = user?.loginUserStatus?.map((dar) => ({
                        ...dar,
                        status: "Inactive",
                    }));

                    user["loginUserStatus"] = [
                        ...remaining,
                        {
                            macaddress: macAddress,
                            username: systemname,
                            hostname: hostname,
                            localip: localIp,
                            status: "Active",
                            version: version,
                            workstation: matchedUserWorkStation,
                            matchedstatus: MatchedNotMatched,
                            matched: matchedWorkStation,
                            count: countWorStation,
                            // date: PresenLoginUserDate
                        },
                    ];
                    // user["signintime"] = (todaydate && extraTime?.length > 0 && extraTime[0] === moment().format("YYYY-MM-DD")) ?
                    // moment(user?.signintime).format("DD-MM-YYYY")=== moment().format("DD-MM-YYYY") ? "" : todaydate : ''

                    const result = await user.save();
                    checksendToken(
                        result,
                        200,
                        res,
                        loginapprestriction,
                        checkAutoLogoutTime,
                        checkAutoLogoutDate,
                        controlcriteria,
                        MatchedNotMatched, resversion,
                        matchedWorkStation,
                        appUpdateCalculation,
                        restrictionBtwShift,
                        holidayWeekOffRestriction,
                        userCheckInControlCriteria
                    );
                } else {
                    checksendToken(user, 200, res, loginapprestriction, checkAutoLogoutTime,
                        checkAutoLogoutDate, controlcriteria, MatchedNotMatched, resversion,
                        matchedWorkStation, appUpdateCalculation, restrictionBtwShift, holidayWeekOffRestriction, userCheckInControlCriteria);
                }
            }
        }
    } catch (err) {
        return next(new ErrorHandler("Error Detecting Face", 404));
    }
});

// "/:id/verify/:token"
exports.verifyUserEmail = catchAsyncErrors(async (req, res, next) => {
    try {
        const user = await User.findOne({ _id: req.params.id });
        if (!user) {
            return next(new ErrorHandler("Invalid Link", 400));
        }

        const token = await Token.findOne({
            userId: user._id,
            token: req.params.token,
        });
        if (!token) {
            return next(new ErrorHandler("Invalid Link", 400));
        }
        const users = await User.findById({ _id: user._id });
        if (!users) {
            return next(new ErrorHandler("User not found!", 404));
        }
        users["emailverification"] = true;
        const result = await users.save();
        await Token.findByIdAndRemove({ _id: token._id });
        return res.status(200).json({
            success: true,
            message: "Email Verified Successfully",
        });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
});

// exports.verifytwofa = catchAsyncErrors(async (req, res, next) => {
//     try {
//         const { id, otp } = req.body;
//         const user = await User.findById(id);
//         if (!user) {
//             return next(new ErrorHandler("User not found!", 404));
//         }
//         const verified = authenticator.check(otp, user.twofatempsecret);
//         if (!verified) {
//             return next(new ErrorHandler("Kindly check your WinAuth QR code! Invalid Otp!", 404));
//         }
//         user["twofaenabled"] = true;
//         user["twofasecret"] = user.twofatempsecret;
//         const result = await user.save();

//         sendToken(result, 200, res);
//     } catch (err) {
//         return next(new ErrorHandler("Records not found!", 404));
//     }
// });

exports.verifytwofa = catchAsyncErrors(async (req, res, next) => {
    try {
        const { id, otp, macAddress } = req.body;
        const user = await User.findById(id);


        let userMacTwoFaSecret = user?.loginUserStatus?.find(data => data?.macaddress === macAddress && data?.twofaenabled === false)


        if (!user) {
            return next(new ErrorHandler("User not found!", 404));
        }
        const verified = authenticator.check(otp, userMacTwoFaSecret.twofatempsecret);
        if (!verified) {
            return next(new ErrorHandler("Kindly check your WinAuth QR code! Invalid Otp!", 404));
        }

        const loginUsernon = user?.loginUserStatus?.filter(data => data?.macaddress !== userMacTwoFaSecret?.macaddress)
        if (userMacTwoFaSecret) {
            userMacTwoFaSecret.twofasecret = userMacTwoFaSecret.twofatempsecret;
            userMacTwoFaSecret.twofaenabled = true;
        }

        // function updateOtp(user, newOtp) {
        //     return {
        //         ...user,
        //         twofasecret: newOtp,
        //         twofaenabled: true
        //     };
        // }
        // const updatedLogin = updateOtp(userMacTwoFaSecret , userMacTwoFaSecret.twofatempsecret);
        const loginUserUpdated = [...loginUsernon, userMacTwoFaSecret]
        user["loginUserStatus"] = loginUserUpdated;



        // user["twofaenabled"] = true;
        // user["twofasecret"] = user.twofatempsecret;
        const result = await user.save();

        checksendToken(result, 200, res);
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
});
// exports.verifychecktwofa = catchAsyncErrors(async (req, res, next) => {
//     try {
//         const { id, otp, macAddress } = req.body;
//         const user = await User.findById(id);


//         let userMacTwoFaSecret = user?.loginUserStatus?.find(data => data?.macaddress === macAddress && data?.twofaenabled === false)


//         if (!user) {
//             return next(new ErrorHandler("User not found!", 404));
//         }
//         const verified = authenticator.check(otp, userMacTwoFaSecret.twofatempsecret);
//         if (!verified) {
//             return next(new ErrorHandler("Kindly check your WinAuth QR code! Invalid Otp!", 404));
//         }

//         const loginUsernon = user?.loginUserStatus?.filter(data => data?.macaddress !== userMacTwoFaSecret?.macaddress)
//         if (userMacTwoFaSecret) {
//             userMacTwoFaSecret.twofasecret = userMacTwoFaSecret.twofatempsecret;
//             userMacTwoFaSecret.twofaenabled = true;
//         }

//         // function updateOtp(user, newOtp) {
//         //     return {
//         //         ...user,
//         //         twofasecret: newOtp,
//         //         twofaenabled: true
//         //     };
//         // }
//         // const updatedLogin = updateOtp(userMacTwoFaSecret , userMacTwoFaSecret.twofatempsecret);
//         const loginUserUpdated = [...loginUsernon, userMacTwoFaSecret]
//         user["loginUserStatus"] = loginUserUpdated;



//         // user["twofaenabled"] = true;
//         // user["twofasecret"] = user.twofatempsecret;
//         const result = await user.save();

//         checksendToken(result, 200, res);
//     } catch (err) {
//         return next(new ErrorHandler("User not found!", 404));
//     }
// });
exports.verifychecktwofa = catchAsyncErrors(async (req, res, next) => {
    try {
        const { id, otp, macAddress, hostname } = req.body;

        const user = await User.findById(id);
        const userMacTwoFaSecret = user?.loginUserStatus?.find(
            (data) => (data.macaddress === macAddress || data.hostname === hostname) && data?.twofaenabled === false
        );
        if (!user) {
            return next(new ErrorHandler("User not found!", 404));
        }
        // authenticator.options = { step: 60 };
        const verified = authenticator.check(otp, userMacTwoFaSecret.twofatempsecret);
        if (!verified) {
            return next(new ErrorHandler("Invalid Otp!", 404));
        }

        const loginUsernon = user?.loginUserStatus?.filter(data => data?.macaddress !== userMacTwoFaSecret?.macaddress)
        if (userMacTwoFaSecret) {
            userMacTwoFaSecret.twofasecret = userMacTwoFaSecret.twofatempsecret;
            userMacTwoFaSecret.twofaenabled = true;
        }

        // function updateOtp(user, newOtp) {
        //     return {
        //         ...user,
        //         twofasecret: newOtp,
        //         twofaenabled: true
        //     };
        // }
        // const updatedLogin = updateOtp(userMacTwoFaSecret , userMacTwoFaSecret.twofatempsecret);
        const loginUserUpdated = [...loginUsernon, userMacTwoFaSecret]
        user["loginUserStatus"] = loginUserUpdated;



        // user["twofaenabled"] = true;
        // user["twofasecret"] = user.twofatempsecret;
        const result = await user.save();

        checksendToken(result, 200, res);
    } catch (err) {
        return next(new ErrorHandler("User not found!", 404));
    }
});

// Logout user => api/authout
exports.loginOut = catchAsyncErrors(async (req, res, next) => {
    res.cookie("token", null, {
        expires: new Date(Date.now()),
        httpOnly: true,
    });

    res.status(200).json({
        success: true,
        message: "Logged out!",
    });
});

//  get overall delete functionality
exports.getAllUserCheck = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {
        let query = {
            company: req.body.checkuser,
        };
        users = await User.find(query, {
            username: 1,
            _id: 1,
        });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    if (!users) {
        return next(new ErrorHandler("User not found!", 404));
    }
    return res.status(200).json({
        users,
    });
});

exports.getAllUserBranch = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {
        let query = {
            branch: req.body.checkbranch,
        };
        users = await User.find(query, {
            username: 1,
            _id: 1,
        });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    if (!users) {
        return next(new ErrorHandler("User not found!", 404));
    }
    return res.status(200).json({
        users,
    });
});

exports.getAllUnitToUser = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {
        let query = {
            unit: req.body.checkunittouser,
        };
        users = await User.find(query, {
            username: 1,
            _id: 1,
        });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    if (!users) {
        return next(new ErrorHandler("User not found!", 404));
    }
    return res.status(200).json({
        users,
    });
});

exports.getAllFloorToUser = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {
        let query = {
            floor: req.body.checkfloortouser,
        };
        users = await User.find(query, {
            username: 1,
            _id: 1,
        });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    if (!users) {
        return next(new ErrorHandler("User not found!", 404));
    }
    return res.status(200).json({
        users,
    });
});

exports.getAllDepartmentToUser = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {
        let query = {
            department: req.body.checkdepartmenttouser,
        };
        users = await User.find(query, {
            username: 1,
            _id: 1,
        });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    if (!users) {
        return next(new ErrorHandler("User not found!", 404));
    }
    return res.status(200).json({
        users,
    });
});

exports.getAllTeamToUser = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {
        let query = {
            team: req.body.checkteamtouser,
        };
        users = await User.find(query, {
            username: 1,
            _id: 1,
        });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    if (!users) {
        return next(new ErrorHandler("User not found!", 404));
    }
    return res.status(200).json({
        users,
    });
});

exports.getAllDesigToUser = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {
        let query = {
            designation: req.body.checkdesigtouser,
        };
        users = await User.find(query, {
            username: 1,
            _id: 1,
        });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    if (!users) {
        return next(new ErrorHandler("User not found!", 404));
    }
    return res.status(200).json({
        users,
    });
});

exports.getAllQualToUser = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {
        const query = {
            eduTodo: {
                $elemMatch: {
                    qualification: req.body.checkqualtouser,
                },
            },
        };
        users = await User.find(query, {
            username: 1,
            _id: 1,
        });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    if (!users) {
        return next(new ErrorHandler("User not found!", 404));
    }
    return res.status(200).json({
        users,
    });
});

exports.getAllSkillToUser = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {
        const query = {
            addAddQuaTodo: {
                $elemMatch: {
                    addQual: req.body.checkskilltouser,
                },
            },
        };
        users = await User.find(query, {
            username: 1,
            _id: 1,
        });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    if (!users) {
        return next(new ErrorHandler("User not found!", 404));
    }
    return res.status(200).json({
        users,
    });
});

exports.getAllShiftToUser = catchAsyncErrors(async (req, res, next) => {

    let users;
    try {
        const query = {
            $or: [
                { 'boardingLog.shifttiming': req.body.checkshifttouser },
                { 'boardingLog': { $elemMatch: { 'todo.shifttiming': req.body.checkshifttouser } } }
            ]
        };
        users = await User.find(query, {
            username: 1,
            _id: 1,
        });

    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    if (!users) {
        return next(new ErrorHandler("User not found!", 404));
    }
    return res.status(200).json({
        users,
    });
});

exports.getAllShiftToUserBulkDelete = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {
        users = await User.aggregate([
            {
                $match: {
                    $or: [
                        { "boardingLog.shifttiming": { $in: req.body.checkshifttouser } },
                        { "boardingLog.todo.shifttiming": { $in: req.body.checkshifttouser } }
                    ]
                }
            },
            {
                $lookup: {
                    from: 'shifts',
                    localField: 'boardingLog.shifttiming',
                    foreignField: 'name',
                    as: 'matchedShifts'
                }
            },
            {
                $lookup: {
                    from: 'shifts',
                    localField: 'boardingLog.todo.shifttiming',
                    foreignField: 'name',
                    as: 'matchedTodoShifts'
                }
            },

            {
                "$project": {
                    "username": 1,
                    "_id": 1,
                    "combinedMatchedShifts": {
                        "$setUnion": [
                            {
                                "$map": {
                                    "input": "$matchedShifts",
                                    "as": "shift",
                                    "in": { "$toString": "$$shift._id" }
                                }
                            },
                            {
                                "$map": {
                                    "input": "$matchedTodoShifts",
                                    "as": "todoShift",
                                    "in": { "$toString": "$$todoShift._id" }
                                }
                            },

                        ]
                    }
                }
            }
        ])
    } catch (err) {
        return next({});
    }

    if (!users) {
        return next({});
    }
    return res.status(200).json({
        users,
    });
});

exports.getAllRoleToUser = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {
        let query = {
            role: req.body.checkroletouser,
        };
        users = await User.find(query, {
            username: 1,
            _id: 1,
        });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    if (!users) {
        return next(new ErrorHandler("User not found!", 404));
    }
    return res.status(200).json({
        users,
    });
});

// get Signle user => /api/auth/:id
exports.getSingleUser = catchAsyncErrors(async (req, res, next) => {
    const suser = await User.findById(req.params.id);

    if (!suser) {
        return next(new ErrorHandler("User not found", 404));
    }

    return res.status(200).json({
        success: true,
        suser,
    });
});

exports.updateUserPwd = catchAsyncErrors(async (req, res, next) => {
    try {
        const id = req.params.id;

        let updatedTeamsArray, updatedChannelArray;
        const { rocketchatid, rocketchatroles, rocketchatteamid, rocketchatemail, rocketchatchannelid, companyname, username } = req.body;
        const singleUserData = await User.findById(id);
        let rocketChatUserDetails = {
            rocketchatemail: singleUserData?.rocketchatemail ?? "",
            rocketchatroles: singleUserData?.rocketchatroles?.length ? singleUserData?.rocketchatroles : [],
        };
        let isRocketchatLive = await checkRocketChatHealth();
        if (rocketchatid && isRocketchatLive) {
            let singleRocketUserData = await getSingleUserData(rocketchatid)
            if (singleRocketUserData?.userExist) {
                const { rocketchatteamids, rocketchatchannelids } = await findRocketChatTeamChannelIds(req.body);
                const teamUpdateResult = await updateUserRocketchatTeams(rocketchatid, rocketchatroles, rocketchatteamid, rocketchatteamids);
                updatedTeamsArray = teamUpdateResult?.updatedTeamsArray
                const channelUpdateResult = await updateUserRocketchatChannels(rocketchatid, rocketchatchannelid, rocketchatchannelids);
                updatedChannelArray = channelUpdateResult?.updatedChannelArray
                const userDetailsUpdate = await updateRocketChatUserDetails(rocketchatid, companyname, rocketchatemail, false, username, rocketchatroles);
                rocketChatUserDetails.rocketchatemail = rocketchatemail;
                rocketChatUserDetails.rocketchatroles = userDetailsUpdate?.user?.roles;
            } else {
                await User.findByIdAndUpdate(id, {
                    ...req.body,
                    rocketchatid: "",
                    rocketchatemail: "",
                    rocketchatroles: [],
                    rocketchatteamid: [],
                    rocketchatchannelid: [],
                });
                return res.status(200).json({ message: "Updated successfully" });
            }
        }
        let rocketDetails = {};
        if (rocketchatid && isRocketchatLive) {
            rocketDetails = {
                rocketchatteamid: updatedTeamsArray,
                rocketchatchannelid: updatedChannelArray,
                rocketchatemail: rocketChatUserDetails?.rocketchatemail,
                rocketchatroles: rocketChatUserDetails?.rocketchatroles
            }
        }
        const upuserone = await User.findByIdAndUpdate(id, {
            ...req.body, ...rocketDetails,
        });

        if (!upuserone) {
            return next(new ErrorHandler("User not found", 404));
        }


        return res.status(200).json({ message: "Updated successfully!" });
    } catch (err) { return next(new ErrorHandler("Error Updating Data", 404)); }
});




exports.updateUser = catchAsyncErrors(async (req, res, next) => {
    const {
        rocketchatid,
        rocketchatemail,
        rocketchatroles,
        rocketchatteamid,
        rocketchatchannelid, passexpdate, newEmployeePassUpdateCheck,
        prefix,
        firstname, religion,
        lastname,
        legalname,
        callingname,
        fathername,
        mothername,
        gender,
        maritalstatus,
        dob,
        username,
        usernameautogenerate,
        workmode,
        password,
        autogeneratepassword,
        status,
        percentage,
        bloodgroup,
        profileimage,
        location,
        email,
        employeecount,
        systemmode,
        companyemail,
        resetstatus,
        extratime,
        extrastatus,
        extratimestatus,
        extradate,
        extraTimeStatus,
        contactpersonal,
        contactfamily,
        emergencyno,
        doj,
        dot,
        dom,
        referencetodo,
        contactno,
        details,
        companyname,
        addremoteworkmode,
        pdoorno,
        pstreet,
        parea,
        plandmark,
        ptaluk,
        ppost,
        ppincode,
        pcountry,
        pstate,
        unit,
        aadhar,
        panno,
        panstatus,
        panrefno,
        pcity,
        cdoorno,
        cstreet,
        carea,
        clandmark,
        ctaluk,
        cpost,
        cpincode,
        ccountry,
        cstate,
        ccity,
        branch,
        samesprmnt,
        floor,
        company,
        experience,
        addedby,
        updatedby,
        department,
        team,
        designation,
        shifttiming,
        shiftgrouping,
        //draft,
        reportingto,
        empcode,
        remark,
        accesslocation,
        workstation,
        weekoff,
        assignExpMode,
        assignExpvalue,
        assignExpDate,
        esideduction,
        pfdeduction,
        uan,
        pfmembername,
        insurancenumber,
        ipname,
        pfesifromdate,
        isenddate,
        pfesienddate,
        originalpassword,
        enquirystatus,
        area,
        enableworkstation,
        wordcheck,
        shiftallot,
        files,
        eduTodo,
        addAddQuaTodo,
        workhistTodo,
        modeOfInt,
        intDuration,
        intCourse,
        intStartDate,
        intEndDate,
        clickedGenerate,
        role,
        bankname,
        bankdetails,
        bankbranchname,
        accountholdername,
        accountnumber,
        ifsccode,
        assignExpLog,
        endexp,
        endtardate,
        endtar,
        assignEndExp,

        assignEndExpDate,
        assignEndTar,
        assignEndTarDate,
        process,
        processtype,
        processduration,
        date,
        time,

        grosssalary,
        timemins,
        shifttype,
        modeexperience,
        targetexperience,
        expval,
        expmode,
        targetpts,
        workstationofficestatus,
        workstationinput, faceDescriptor
    } = req.body;
    // encrypt password before saving
    const salt = await bcrypt.genSalt(10);
    const hashPassword = await bcrypt.hash(password, salt);
    let updatedTeamsArray, updatedChannelArray, singleRocketChatUserData;
    const id = req.params.id;
    const singleUserData = await User.findById(id);
    let rocketChatUserDetails = {
        rocketchatemail: singleUserData?.rocketchatemail ?? "",
        rocketchatroles: singleUserData?.rocketchatroles?.length ? singleUserData?.rocketchatroles : [],
    };

    let isRocketchatLive = await checkRocketChatHealth();
    if (rocketchatid && isRocketchatLive) {
        singleRocketChatUserData = await getSingleUserData(rocketchatid)
        if (singleRocketChatUserData?.userExist) {
            const { rocketchatteamids, rocketchatchannelids } = await findRocketChatTeamChannelIds(req.body);
            const teamUpdateResult = await updateUserRocketchatTeams(rocketchatid, rocketchatroles, rocketchatteamid, rocketchatteamids);
            updatedTeamsArray = teamUpdateResult?.updatedTeamsArray
            const channelUpdateResult = await updateUserRocketchatChannels(rocketchatid, rocketchatchannelid, rocketchatchannelids);
            updatedChannelArray = channelUpdateResult?.updatedChannelArray;
            const userDetailsUpdate = await updateRocketChatUserDetails(rocketchatid, companyname, rocketchatemail, password, username, rocketchatroles);
            rocketChatUserDetails.rocketchatemail = rocketchatemail;
            rocketChatUserDetails.rocketchatroles = userDetailsUpdate?.user?.roles;
        }
    }

    let rocketDetails = {};

    if (rocketchatid && isRocketchatLive) {
        rocketDetails = {
            rocketchatteamid: singleRocketChatUserData?.userExist ? updatedTeamsArray : [],
            rocketchatchannelid: singleRocketChatUserData?.userExist ? updatedChannelArray : [],
            rocketchatemail: singleRocketChatUserData?.userExist ? rocketChatUserDetails?.rocketchatemail : "",
            rocketchatroles: singleRocketChatUserData?.userExist ? rocketChatUserDetails?.rocketchatroles : "",
            rocketchatid: singleRocketChatUserData?.userExist ? singleRocketChatUserData?.singleUser?._id : "",
        }
    }

    const upuser = await User.findByIdAndUpdate(id, {
        ...rocketDetails,
        prefix,
        username,
        usernameautogenerate,
        workmode,
        lastname, religion,
        email,
        employeecount,
        systemmode,
        addremoteworkmode, passexpdate, newEmployeePassUpdateCheck,
        companyemail,
        resetstatus,
        extratime,
        extrastatus,
        extratimestatus,
        extradate,
        extraTimeStatus,
        firstname,
        legalname,
        callingname,
        fathername,
        mothername,
        gender,
        maritalstatus,
        dob,
        dom,
        bloodgroup,
        profileimage,
        location,
        email,
        employeecount,
        systemmode,
        companyemail,
        resetstatus,
        extratime,
        extrastatus,
        extratimestatus,
        extradate,
        extraTimeStatus,
        contactpersonal,
        contactfamily,
        emergencyno,
        doj,
        dot,
        referencetodo,
        status,
        percentage,
        contactno,
        details,
        companyname,
        pdoorno,
        pstreet,
        parea,
        plandmark,
        ptaluk,
        ppost,
        ppincode,
        pcountry,
        pstate,
        aadhar,
        panno,
        panstatus,
        panrefno,
        pcity,
        cdoorno,
        cstreet,
        carea,
        clandmark,
        ctaluk,
        cpost,
        cpincode,
        ccountry,
        cstate,
        ccity,
        branch,
        floor,
        experience,
        samesprmnt,
        unit,
        addedby,
        updatedby,
        department,
        team,
        designation,
        shifttiming,
        shiftgrouping,
        reportingto,
        //draft,
        empcode,
        remark,
        accesslocation,
        workstation,
        weekoff,
        assignExpMode,
        assignExpvalue,
        assignExpDate,
        esideduction,
        pfdeduction,
        uan,
        pfmembername,
        insurancenumber,
        ipname,
        pfesifromdate,
        isenddate,
        pfesienddate,
        originalpassword,
        enquirystatus,
        area,
        enableworkstation,
        wordcheck,
        shiftallot,
        files,
        eduTodo,
        company,
        addAddQuaTodo,
        workhistTodo,
        modeOfInt,
        intDuration,
        intCourse,
        intStartDate,
        intEndDate,
        clickedGenerate,
        role,
        bankname,
        bankdetails,
        bankbranchname,
        accountholdername,
        accountnumber,
        ifsccode,
        password: hashPassword,
        autogeneratepassword,
        assignExpLog,
        assignExpMode,
        assignExpvalue,
        assignExpDate,
        endexp,
        endtardate,
        endtar,
        assignEndExp,

        assignEndExpDate,
        assignEndTar,
        assignEndTarDate,
        process,
        processtype,
        processduration,
        date,
        time,

        grosssalary,
        timemins,
        shifttype,
        modeexperience,
        targetexperience,
        expval,
        expmode,
        targetpts,
        workstationofficestatus,
        workstationinput, faceDescriptor
    });

    if (!upuser) {
        return next(new ErrorHandler("User not found", 404));
    }

    return res.status(200).json({ message: "Updated successfully!", upuser });
});




// delete user by id => /api/auth/:id
exports.deleteUser = catchAsyncErrors(async (req, res, next) => {
    const id = req.params.id;

    const duser = await User.findByIdAndRemove(id);

    if (!duser) {
        return next(new ErrorHandler("User not found", 404));
    }

    res.status(200).json({ message: "Deleted successfully" });
});

// Shift Roaster functions
// Get Clock in time for the user
const checkGetClockInTime = (attendance, rowuserid, rowdate, rowshift, rowshiftmode) => {

    const attendanceRecord = attendance?.find((d) => d.userid === rowuserid && formatDateRemove(d.date) === rowdate && d.shiftmode === rowshiftmode);

    if (attendanceRecord) {

        return attendanceRecord.clockintime !== "" ? rowshift === 'Week Off' ? "00:00:00" : attendanceRecord.clockintime : "00:00:00";
    }
    // Return a default value if clockin time is not available
    return "00:00:00";

};

// Get Clock out time for the user
const checkGetClockOutTime = (attendance, rowuserid, rowdate, rowshift, rowshiftmode) => {

    const attendanceRecord = attendance.find((d) => d.userid === rowuserid && formatDateRemove(d.date) === rowdate && d.shiftmode === rowshiftmode);

    if (attendanceRecord) {
        return attendanceRecord.clockouttime !== "" ? rowshift === 'Week Off' ? "00:00:00" : attendanceRecord.clockouttime : "00:00:00";
    }
    // Return a default value if clockin time is not available
    return "00:00:00";

};
// Get Clock in date for the user
const checkGetClockInDate = (attendance, rowuserid, rowdate, rowshiftmode) => {

    const attendanceRecord = attendance?.find((d) => d.userid === rowuserid && formatDateRemove(d.date) === rowdate && d.shiftmode === rowshiftmode);

    if (attendanceRecord) {
        return attendanceRecord.date;
    }
    // Return a default value if clockin date is not available
    return "";

};

const checkGetClockInAutoStatus = (attendance, rowuserid, rowdate, rowshiftmode) => {

    const attendanceRecord = attendance?.find((d) => d.userid === rowuserid && formatDateRemove(d.date) === rowdate && d.shiftmode === rowshiftmode);

    if (attendanceRecord) {
        return attendanceRecord.autoclockout;
    }
    // Return a default value if clockin date is not available
    return "";

};

const getUserIp = (attendance, rowuserid, rowdate, rowshiftmode) => {
    // Find the attendance record for the given user id and date
    const attendanceRecord = attendance.find(
        (record) => record.userid === rowuserid && formatDateRemove(record.date) === rowdate && record.shiftmode === rowshiftmode
    );

    if (attendanceRecord) {
        return attendanceRecord.clockinipaddress;
    }

    // Return an empty string if no attendance record is found
    return "";
};

const checkClockInStatus = (clockintime, rowshift, graceTime, allLeaveStatus, holidays, clockindate, rowbranch, rowempcode, rowcompany, rowformattedDate, rowunit, rowteam, rowcompanyname,
    earlyClockInTime, lateClockInTime, afterLateClockInTime, leavetype, permission, clockouttime, rowshiftmode, weekoffpresentstatus) => {

    const totalFinalLeaveDaysApproved = allLeaveStatus?.filter((d) => d.employeeid === rowempcode && d.status === "Approved");
    const totalFinalLeaveDaysApplied = allLeaveStatus?.filter((d) => d.employeeid === rowempcode && d.status === "Applied");
    const totalFinalLeaveDaysRejected = allLeaveStatus?.filter((d) => d.employeeid === rowempcode && d.status === "Reject With Leave");

    const permissionApprovedWithoutComp = permission.filter((d) => d.employeeid === rowempcode && d.status === "Approved" && d.compensationstatus === '');
    const permissionAppliedWithoutComp = permission.filter((d) => d.employeeid === rowempcode && d.status === "Applied" && d.compensationstatus === '');
    const permissionRejectedWithoutComp = permission.filter((d) => d.employeeid === rowempcode && d.status === "Rejected" && d.compensationstatus === '');

    // const totalPermissionApprovedStart = permission.find((d) => d.employeeid === rowempcode && d.status === "Approved" && d.compensationstatus === 'Compensation');
    // const totalPermissionAppliedStart = permission.find((d) => d.employeeid === rowempcode && d.status === "Applied" && d.compensationstatus === 'Compensation');

    const totalPermissionApprovedStart = permission.filter((d) => d.employeeid === rowempcode && d.status === "Approved" && d.compensationstatus === 'Compensation');
    const totalPermissionAppliedStart = permission.filter((d) => d.employeeid === rowempcode && d.status === "Applied" && d.compensationstatus === 'Compensation');

    const holidayResults = holidays.filter((item) => moment(item.date, "YYYY-MM-DD").format("DD/MM/YYYY") === rowformattedDate)
    const isHoliday = holidayResults?.some(holiday =>
        holiday.company?.includes(rowcompany) &&
            holiday.applicablefor?.includes(rowbranch) &&
            holiday.unit?.includes(rowunit) &&
            holiday.team?.includes(rowteam) &&
            holiday.employee.includes('ALL') ? rowcompanyname : holiday.employee?.includes(rowcompanyname)
    );

    let leavestatusApproved = [];

    leavetype?.map((type) => {
        totalFinalLeaveDaysApproved && totalFinalLeaveDaysApproved.forEach((d) => {
            if (type.leavetype === d.leavetype) {
                d.usershifts.forEach((shift) => {
                    leavestatusApproved.push({
                        date: shift.formattedDate,
                        shiftmode: shift.shiftmode,
                        leavetype: d.leavetype,
                        status: d.status,
                        code: type.code,
                        tookleavecheckstatus: shift.tookleavecheckstatus,
                        leavestatus: shift.leavestatus,
                        shiftcount: shift.shiftcount,
                    });
                })
            }
        });
    });

    let leavestatusApplied = [];

    leavetype?.map((type) => {
        totalFinalLeaveDaysApplied && totalFinalLeaveDaysApplied.forEach((d) => {
            if (type.leavetype === d.leavetype) {
                d.usershifts.forEach((shift) => {
                    leavestatusApplied.push({
                        date: shift.formattedDate,
                        shiftmode: shift.shiftmode,
                        leavetype: d.leavetype,
                        status: d.status,
                        code: type.code,
                        tookleavecheckstatus: shift.tookleavecheckstatus,
                        leavestatus: shift.leavestatus,
                        shiftcount: shift.shiftcount,
                    });
                })
            }
        });
    });

    let leavestatusRejected = [];

    leavetype?.map((type) => {
        totalFinalLeaveDaysRejected && totalFinalLeaveDaysRejected.forEach((d) => {
            if (type.leavetype === d.leavetype) {
                d.usershifts.forEach((shift) => {
                    leavestatusRejected.push({
                        date: shift.formattedDate,
                        shiftmode: shift.shiftmode,
                        leavetype: d.leavetype,
                        status: d.status,
                        code: type.code,
                        tookleavecheckstatus: shift.tookleavecheckstatus,
                        leavestatus: shift.leavestatus,
                        shiftcount: shift.shiftcount,
                    });
                })
            }
        });
    });

    let leaveWithoutApproved = [];

    totalFinalLeaveDaysApproved && totalFinalLeaveDaysApproved.forEach((d) => {
        if (d.leavetype === 'Leave Without Pay (LWP)') {
            d.usershifts.forEach((shift) => {
                leaveWithoutApproved.push({
                    date: shift.formattedDate,
                    shiftmode: shift.shiftmode,
                    leavetype: d.leavetype,
                    status: d.status,
                    tookleavecheckstatus: shift.tookleavecheckstatus,
                    leavestatus: shift.leavestatus,
                    shiftcount: shift.shiftcount,
                });
            })
        }
    });

    let leaveWithoutApplied = [];

    totalFinalLeaveDaysApplied && totalFinalLeaveDaysApplied.forEach((d) => {
        if (d.leavetype === 'Leave Without Pay (LWP)') {
            d.usershifts.forEach((shift) => {
                leaveWithoutApplied.push({
                    date: shift.formattedDate,
                    shiftmode: shift.shiftmode,
                    leavetype: d.leavetype,
                    status: d.status,
                    tookleavecheckstatus: shift.tookleavecheckstatus,
                    leavestatus: shift.leavestatus,
                    shiftcount: shift.shiftcount,
                });
            })
        }
    });

    let leaveWithoutRejected = [];

    totalFinalLeaveDaysRejected && totalFinalLeaveDaysRejected.forEach((d) => {
        if (d.leavetype === 'Leave Without Pay (LWP)') {
            d.usershifts.forEach((shift) => {
                leaveWithoutRejected.push({
                    date: shift.formattedDate,
                    shiftmode: shift.shiftmode,
                    leavetype: d.leavetype,
                    status: d.status,
                    tookleavecheckstatus: shift.tookleavecheckstatus,
                    leavestatus: shift.leavestatus,
                    shiftcount: shift.shiftcount,
                });
            })
        }
    });

    const leaveOnDateApprovedSingleFL = leavestatusApproved.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'Shift');
    const leaveOnDateApprovedSingleHB = leavestatusApproved.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'Before Half Shift');
    const leaveOnDateApprovedSingleHA = leavestatusApproved.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'After Half Shift');

    const leaveOnDateApprovedDoubleFL = leavestatusApproved.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'Shift');
    const leaveOnDateApprovedDoubleHB = leavestatusApproved.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'Before Half Shift');
    const leaveOnDateApprovedDoubleHA = leavestatusApproved.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'After Half Shift');

    const leaveOnDateAppliedSingleFL = leavestatusApplied.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'Shift');
    const leaveOnDateAppliedSingleHB = leavestatusApplied.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'Before Half Shift');
    const leaveOnDateAppliedSingleHA = leavestatusApplied.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'After Half Shift');

    const leaveOnDateAppliedDoubleFL = leavestatusApplied.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'Shift');
    const leaveOnDateAppliedDoubleHB = leavestatusApplied.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'Before Half Shift');
    const leaveOnDateAppliedDoubleHA = leavestatusApplied.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'After Half Shift');

    const leaveOnDateRejectedSingleFL = leavestatusRejected.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'Shift');
    const leaveOnDateRejectedSingleHB = leavestatusRejected.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'Before Half Shift');
    const leaveOnDateRejectedSingleHA = leavestatusRejected.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'After Half Shift');

    const leaveOnDateRejectedDoubleFL = leavestatusRejected.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'Shift');
    const leaveOnDateRejectedDoubleHB = leavestatusRejected.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'Before Half Shift');
    const leaveOnDateRejectedDoubleHA = leavestatusRejected.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'After Half Shift');

    const leaveWithoutOnDateApprovedSingleFL = leaveWithoutApproved.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'Shift');
    const leaveWithoutOnDateApprovedSingleHB = leaveWithoutApproved.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'Before Half Shift');
    const leaveWithoutOnDateApprovedSingleHA = leaveWithoutApproved.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'After Half Shift');

    const leaveWithoutOnDateApprovedDoubleFL = leaveWithoutApproved.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'Shift');
    const leaveWithoutOnDateApprovedDoubleHB = leaveWithoutApproved.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'Before Half Shift');
    const leaveWithoutOnDateApprovedDoubleHA = leaveWithoutApproved.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'After Half Shift');

    const leaveWithoutOnDateAppliedSingleFL = leaveWithoutApplied.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'Shift');
    const leaveWithoutOnDateAppliedSingleHB = leaveWithoutApplied.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'Before Half Shift');
    const leaveWithoutOnDateAppliedSingleHA = leaveWithoutApplied.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'After Half Shift');

    const leaveWithoutOnDateAppliedDoubleFL = leaveWithoutApplied.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'Shift');
    const leaveWithoutOnDateAppliedDoubleHB = leaveWithoutApplied.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'Before Half Shift');
    const leaveWithoutOnDateAppliedDoubleHA = leaveWithoutApplied.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'After Half Shift');

    const leaveWithoutOnDateRejectedSingleFL = leaveWithoutRejected.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'Shift');
    const leaveWithoutOnDateRejectedSingleHB = leaveWithoutRejected.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'Before Half Shift');
    const leaveWithoutOnDateRejectedSingleHA = leaveWithoutRejected.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'After Half Shift');

    const leaveWithoutOnDateRejectedDoubleFL = leaveWithoutRejected.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'Shift');
    const leaveWithoutOnDateRejectedDoubleHB = leaveWithoutRejected.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'Before Half Shift');
    const leaveWithoutOnDateRejectedDoubleHA = leaveWithoutRejected.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'After Half Shift');

    if (leaveWithoutOnDateApprovedSingleFL) {
        return `LWP ${leaveWithoutOnDateApprovedSingleFL.status}`;
    }
    else if (leaveWithoutOnDateApprovedSingleHB) {
        return `HB - LWP ${leaveWithoutOnDateApprovedSingleHB.status}`;
    }
    else if (leaveWithoutOnDateApprovedSingleHA) {
        return `HA - LWP ${leaveWithoutOnDateApprovedSingleHA.status}`;
    }
    else if (leaveWithoutOnDateApprovedDoubleFL) {
        return `DL - LWP ${leaveWithoutOnDateApprovedDoubleFL.status}`;
    }
    else if (leaveWithoutOnDateApprovedDoubleHB) {
        return `DHB - LWP ${leaveWithoutOnDateApprovedDoubleHB.status}`;
    }
    else if (leaveWithoutOnDateApprovedDoubleHA) {
        return `DHA - LWP ${leaveWithoutOnDateApprovedDoubleHA.status}`;
    }
    else if (leaveWithoutOnDateAppliedSingleFL) {
        return `LWP ${leaveWithoutOnDateAppliedSingleFL.status}`;
    }
    else if (leaveWithoutOnDateAppliedSingleHB) {
        return `HB - LWP ${leaveWithoutOnDateAppliedSingleHB.status}`;
    }
    else if (leaveWithoutOnDateAppliedSingleHA) {
        return `HA - LWP ${leaveWithoutOnDateAppliedSingleHA.status}`;
    }
    else if (leaveWithoutOnDateAppliedDoubleFL) {
        return `DL - LWP ${leaveWithoutOnDateAppliedDoubleFL.status}`;
    }
    else if (leaveWithoutOnDateAppliedDoubleHB) {
        return `DHB - LWP ${leaveWithoutOnDateAppliedDoubleHB.status}`;
    }
    else if (leaveWithoutOnDateAppliedDoubleHA) {
        return `DHA - LWP ${leaveWithoutOnDateAppliedDoubleHA.status}`;
    }
    else if (leaveWithoutOnDateRejectedSingleFL) {
        return `LWP ${leaveWithoutOnDateRejectedSingleFL.status}`;
    }
    else if (leaveWithoutOnDateRejectedSingleHB) {
        return `HB - LWP ${leaveWithoutOnDateRejectedSingleHB.status}`;
    }
    else if (leaveWithoutOnDateRejectedSingleHA) {
        return `HA - LWP ${leaveWithoutOnDateRejectedSingleHA.status}`;
    }
    else if (leaveWithoutOnDateRejectedDoubleFL) {
        return `DL - LWP ${leaveWithoutOnDateRejectedDoubleFL.status}`;
    }
    else if (leaveWithoutOnDateRejectedDoubleHB) {
        return `DHB - LWP ${leaveWithoutOnDateRejectedDoubleHB.status}`;
    }
    else if (leaveWithoutOnDateRejectedDoubleHA) {
        return `DHA - LWP ${leaveWithoutOnDateRejectedDoubleHA.status}`;
    }


    if (permissionApprovedWithoutComp.find((d) => moment(d.date, "YYYY-MM-DD").format("DD/MM/YYYY").includes(rowformattedDate) && d.shiftmode === rowshiftmode)) {
        return "PERAPPR";
    }
    if (permissionAppliedWithoutComp.find((d) => moment(d.date, "YYYY-MM-DD").format("DD/MM/YYYY").includes(rowformattedDate) && d.shiftmode === rowshiftmode)) {
        return "PERAPPL";
    }
    if (permissionRejectedWithoutComp.find((d) => moment(d.date, "YYYY-MM-DD").format("DD/MM/YYYY").includes(rowformattedDate) && d.shiftmode === rowshiftmode)) {
        return "PERREJ";
    }
    if (totalPermissionApprovedStart.find((d) => moment(d.date, "YYYY-MM-DD").format("DD/MM/YYYY").includes(rowformattedDate) && d.shiftmode === rowshiftmode)) {
        return "COMP - PERAPPR";
    }
    if (totalPermissionAppliedStart.find((d) => moment(d.date, "YYYY-MM-DD").format("DD/MM/YYYY").includes(rowformattedDate) && d.shiftmode === rowshiftmode)) {
        return "COMP - PERAPPR";
    }

    // let clockInTime = parseTime(clockintime, rowformattedDate);
    // let startTime = parseTime(rowshift?.split('to')[0], rowformattedDate);
    // let startTimeWithPM = rowshift?.split('to')[0];
    // let endTime = parseTime(rowshift?.split('to')[1], rowformattedDate);

    // Get current date and time
    var now = new Date();
    var dd = String(now.getDate()).padStart(2, "0");
    var mm = String(now.getMonth() + 1).padStart(2, "0"); // January is 0!
    var yyyy = now.getFullYear();
    var today = dd + "/" + mm + "/" + yyyy;

    // Extract hours and minutes
    var hours = now.getHours();
    var minutes = now.getMinutes();

    // Format hours and minutes to always have two digits
    var formattedHours = String(hours).padStart(2, '0');
    var formattedMinutes = String(minutes).padStart(2, '0');

    // Combine hours and minutes into the desired format
    var currentTime = formattedHours + ":" + formattedMinutes;

    let clockInTime = parseTime(clockintime);
    let startTime = parseTime(rowshift?.split('to')[0]);
    let startTimeWithPM = rowshift?.split('to')[0];

    if (!startTime) {
        return rowshift === 'Not Allotted' ? 'Not Allotted' : rowshift === 'Pending...' ? 'Not Allotted' : (rowshift === 'Week Off' && clockintime === "00:00:00") ? 'Week Off' : 'Invalid start time';
    }

    if (startTimeWithPM.includes('PM')) {
        // early clockintime
        const earlyTimeInMilliseconds = earlyClockInTime * 60000;
        const startTimeWithEarly = new Date(startTime?.getTime() - earlyTimeInMilliseconds);

        // Add graceTime to the startTime
        const graceTimeInMilliseconds = graceTime * 60000; // Convert graceTime to milliseconds
        const startTimeWithGrace = new Date(startTime?.getTime() + graceTimeInMilliseconds);

        // late clockin 
        const lateTimeInMilliseconds = lateClockInTime * 60000;
        const startTimeWithLate = new Date(startTime.getTime() + graceTimeInMilliseconds + lateTimeInMilliseconds);

        // after late lop
        const halfLopTimeInMilliseconds = afterLateClockInTime * 60000;
        const startTimeWithHalfLop = new Date(startTime.getTime() + graceTimeInMilliseconds + lateTimeInMilliseconds + halfLopTimeInMilliseconds);

        // Adjust endTime if it's a night shift
        if (startTimeWithPM.includes('PM') && clockintime.includes('AM')) {
            clockInTime.setDate(clockInTime.getDate() + 1); // Move endTime to the next day
        }

        // Night Shift
        // Check if clockInTime is within the grace period
        if (isHoliday && rowshift !== "Week Off") {
            return 'Holiday';
        }
        else if (leaveOnDateApprovedSingleFL) {
            return `${leaveOnDateApprovedSingleFL.code} ${leaveOnDateApprovedSingleFL.status}`;
        }
        else if (leaveOnDateApprovedSingleHB) {
            return `HB - ${leaveOnDateApprovedSingleHB.code} ${leaveOnDateApprovedSingleHB.status}`;
        }
        else if (leaveOnDateApprovedSingleHA) {
            return `HA - ${leaveOnDateApprovedSingleHA.code} ${leaveOnDateApprovedSingleHA.status}`;
        }
        else if (leaveOnDateApprovedDoubleFL) {
            return `DL - ${leaveOnDateApprovedDoubleFL.code} ${leaveOnDateApprovedDoubleFL.status}`;
        }
        else if (leaveOnDateApprovedDoubleHB) {
            return `DHB - ${leaveOnDateApprovedDoubleHB.code} ${leaveOnDateApprovedDoubleHB.status}`;
        }
        else if (leaveOnDateApprovedDoubleHA) {
            return `DHA - ${leaveOnDateApprovedDoubleHA.code} ${leaveOnDateApprovedDoubleHA.status}`;
        }
        else if (leaveOnDateAppliedSingleFL) {
            return `${leaveOnDateAppliedSingleFL.code} ${leaveOnDateAppliedSingleFL.status}`;
        }
        else if (leaveOnDateAppliedSingleHB) {
            return `HB - ${leaveOnDateAppliedSingleHB.code} ${leaveOnDateAppliedSingleHB.status}`;
        }
        else if (leaveOnDateAppliedSingleHA) {
            return `HA - ${leaveOnDateAppliedSingleHA.code} ${leaveOnDateAppliedSingleHA.status}`;
        }
        else if (leaveOnDateAppliedDoubleFL) {
            return `DL - ${leaveOnDateAppliedDoubleFL.code} ${leaveOnDateAppliedDoubleFL.status}`;
        }
        else if (leaveOnDateAppliedDoubleHB) {
            return `DHB - ${leaveOnDateAppliedDoubleHB.code} ${leaveOnDateAppliedDoubleHB.status}`;
        }
        else if (leaveOnDateAppliedDoubleHA) {
            return `DHA - ${leaveOnDateAppliedDoubleHA.code} ${leaveOnDateAppliedDoubleHA.status}`;
        }
        else if (leaveOnDateRejectedSingleFL) {
            return `${leaveOnDateRejectedSingleFL.code} ${leaveOnDateRejectedSingleFL.status}`;
        }
        else if (leaveOnDateRejectedSingleHB) {
            return `HB - ${leaveOnDateRejectedSingleHB.code} ${leaveOnDateRejectedSingleHB.status}`;
        }
        else if (leaveOnDateRejectedSingleHA) {
            return `HA - ${leaveOnDateRejectedSingleHA.code} ${leaveOnDateRejectedSingleHA.status}`;
        }
        else if (leaveOnDateRejectedDoubleFL) {
            return `DL - ${leaveOnDateRejectedDoubleFL.code} ${leaveOnDateRejectedDoubleFL.status}`;
        }
        else if (leaveOnDateRejectedDoubleHB) {
            return `DHB - ${leaveOnDateRejectedDoubleHB.code} ${leaveOnDateRejectedDoubleHB.status}`;
        }
        else if (leaveOnDateRejectedDoubleHA) {
            return `DHA - ${leaveOnDateRejectedDoubleHA.code} ${leaveOnDateRejectedDoubleHA.status}`;
        }
        else if (rowshift === "Pending..." && clockintime !== "00:00:00") {
            return `Pending...`;
        }
        else if (rowshift === "Week Off" && clockintime === "00:00:00") {
            return `Week Off`;
        }
        else if (rowshift === "Not Allotted" && clockintime === "00:00:00") {
            return `Not Allotted`;
        }
        else if (weekoffpresentstatus === true) {
            return 'Week Off Present';
        }
        else if (clockintime === "00:00:00" && rowshift !== "Week Off" && today === rowformattedDate && new Date(2000, 0, 1, ...currentTime.split(':').map(Number)) < startTime) {
            return `Shift Not Started`;
        }
        else if (clockintime === "00:00:00" && rowshift !== "Week Off") {
            return `Absent`;
        }
        else if (clockInTime >= startTimeWithEarly && clockInTime <= startTime) {
            return `On - Present`;
        }
        else if (clockInTime >= startTimeWithGrace && clockInTime <= startTimeWithLate) {
            return `Late - ClockIn`;
        }
        else if (clockInTime >= startTimeWithLate && clockInTime <= startTimeWithHalfLop) {
            return `HBLOP`;
        }
        else if (clockInTime >= startTimeWithHalfLop) {
            return `FLOP`;
        }
        else if (clockInTime >= startTime && clockInTime <= startTimeWithGrace) {
            return `Grace - ClockIn`;
        }
        else if (clockInTime < startTimeWithEarly) {
            return `Early - ClockIn`;
        }
        else {
            return `Present`;
        }
    }
    else {
        // early clockintime
        const earlyTimeInMilliseconds = earlyClockInTime * 60000;
        const startTimeWithEarly = new Date(startTime?.getTime() - earlyTimeInMilliseconds);

        // Add graceTime to the startTime
        const graceTimeInMilliseconds = graceTime * 60000; // Convert graceTime to milliseconds
        const startTimeWithGrace = new Date(startTime?.getTime() + graceTimeInMilliseconds);

        // late clockin 
        const lateTimeInMilliseconds = lateClockInTime * 60000;
        const startTimeWithLate = new Date(startTime.getTime() + graceTimeInMilliseconds + lateTimeInMilliseconds);

        // after late lop
        const halfLopTimeInMilliseconds = afterLateClockInTime * 60000;
        const startTimeWithHalfLop = new Date(startTime.getTime() + graceTimeInMilliseconds + lateTimeInMilliseconds + halfLopTimeInMilliseconds);

        // Day Shift
        // Check if clockInTime is within the grace period
        if (isHoliday && rowshift !== "Week Off") {
            return 'Holiday';
        }
        // else if (leaveOnDateCasualApproved.length > 0 && rowshift !== "Week Off") {
        //     return 'Leave ';
        // }
        else if (leaveOnDateApprovedSingleFL) {
            return `${leaveOnDateApprovedSingleFL.code} ${leaveOnDateApprovedSingleFL.status}`;
        }
        else if (leaveOnDateApprovedSingleHB) {
            return `HB - ${leaveOnDateApprovedSingleHB.code} ${leaveOnDateApprovedSingleHB.status}`;
        }
        else if (leaveOnDateApprovedSingleHA) {
            return `HA - ${leaveOnDateApprovedSingleHA.code} ${leaveOnDateApprovedSingleHA.status}`;
        }
        else if (leaveOnDateApprovedDoubleFL) {
            return `DL - ${leaveOnDateApprovedDoubleFL.code} ${leaveOnDateApprovedDoubleFL.status}`;
        }
        else if (leaveOnDateApprovedDoubleHB) {
            return `DHB - ${leaveOnDateApprovedDoubleHB.code} ${leaveOnDateApprovedDoubleHB.status}`;
        }
        else if (leaveOnDateApprovedDoubleHA) {
            return `DHA - ${leaveOnDateApprovedDoubleHA.code} ${leaveOnDateApprovedDoubleHA.status}`;
        }
        else if (leaveOnDateAppliedSingleFL) {
            return `${leaveOnDateAppliedSingleFL.code} ${leaveOnDateAppliedSingleFL.status}`;
        }
        else if (leaveOnDateAppliedSingleHB) {
            return `HB - ${leaveOnDateAppliedSingleHB.code} ${leaveOnDateAppliedSingleHB.status}`;
        }
        else if (leaveOnDateAppliedSingleHA) {
            return `HA - ${leaveOnDateAppliedSingleHA.code} ${leaveOnDateAppliedSingleHA.status}`;
        }
        else if (leaveOnDateAppliedDoubleFL) {
            return `DL - ${leaveOnDateAppliedDoubleFL.code} ${leaveOnDateAppliedDoubleFL.status}`;
        }
        else if (leaveOnDateAppliedDoubleHB) {
            return `DHB - ${leaveOnDateAppliedDoubleHB.code} ${leaveOnDateAppliedDoubleHB.status}`;
        }
        else if (leaveOnDateAppliedDoubleHA) {
            return `DHA - ${leaveOnDateAppliedDoubleHA.code} ${leaveOnDateAppliedDoubleHA.status}`;
        }
        else if (leaveOnDateRejectedSingleFL) {
            return `${leaveOnDateRejectedSingleFL.code} ${leaveOnDateRejectedSingleFL.status}`;
        }
        else if (leaveOnDateRejectedSingleHB) {
            return `HB - ${leaveOnDateRejectedSingleHB.code} ${leaveOnDateRejectedSingleHB.status}`;
        }
        else if (leaveOnDateRejectedSingleHA) {
            return `HA - ${leaveOnDateRejectedSingleHA.code} ${leaveOnDateRejectedSingleHA.status}`;
        }
        else if (leaveOnDateRejectedDoubleFL) {
            return `DL - ${leaveOnDateRejectedDoubleFL.code} ${leaveOnDateRejectedDoubleFL.status}`;
        }
        else if (leaveOnDateRejectedDoubleHB) {
            return `DHB - ${leaveOnDateRejectedDoubleHB.code} ${leaveOnDateRejectedDoubleHB.status}`;
        }
        else if (leaveOnDateRejectedDoubleHA) {
            return `DHA - ${leaveOnDateRejectedDoubleHA.code} ${leaveOnDateRejectedDoubleHA.status}`;
        }
        else if (rowshift === "Pending..." && clockintime !== "00:00:00") {
            return `Pending...`;
        }
        else if (rowshift === "Week Off" && clockintime === "00:00:00") {
            return `Week Off`;
        }
        else if (rowshift === "Not Allotted" && clockintime === "00:00:00") {
            return `Not Allotted`;
        }
        else if (weekoffpresentstatus === true) {
            return 'Week Off Present';
        }
        else if (clockintime === "00:00:00" && rowshift !== "Week Off" && today === rowformattedDate && new Date(2000, 0, 1, ...currentTime.split(':').map(Number)) < startTime) {
            return `Shift Not Started`;
        }
        else if (clockintime === "00:00:00" && rowshift !== "Week Off") {
            return `Absent`;
        }
        else if (clockInTime >= startTimeWithEarly && clockInTime <= startTime) {
            return `On - Present`;
        }
        else if (clockInTime >= startTimeWithGrace && clockInTime <= startTimeWithLate) {
            return `Late - ClockIn`;
        }
        else if (clockInTime >= startTimeWithLate && clockInTime <= startTimeWithHalfLop) {
            return `HBLOP`;
        }
        else if (clockInTime >= startTimeWithHalfLop) {
            return `FLOP`;
        }
        else if (clockInTime >= startTime && clockInTime <= startTimeWithGrace) {
            return `Grace - ClockIn`;
        }
        else if (clockInTime < startTimeWithEarly) {
            return `Early - ClockIn`;
        }
        else {
            return `Present`;
        }
    }

};

const checkClockOutStatus = (clockouttime, clockintime, rowshift, clockOutHours, clockindate, allLeaveStatus, holidays, rowbranch, rowempcode, rowcompany, rowformattedDate, rowunit, rowteam, rowcompanyname, onClockOutTime,
    earlyClockOutTime, beforeEarlyClockOutTime, autoClockOutStatus, leavetype, permission, rowshiftmode, weekoffpresentstatus) => {

    const totalFinalLeaveDaysApproved = allLeaveStatus?.filter((d) => d.employeeid === rowempcode && d.status === "Approved");
    const totalFinalLeaveDaysApplied = allLeaveStatus?.filter((d) => d.employeeid === rowempcode && d.status === "Applied");
    const totalFinalLeaveDaysRejected = allLeaveStatus?.filter((d) => d.employeeid === rowempcode && d.status === "Reject With Leave");

    const permissionApprovedWithoutComp = permission.filter((d) => d.employeeid === rowempcode && d.status === "Approved" && d.compensationstatus === '');
    const permissionAppliedWithoutComp = permission.filter((d) => d.employeeid === rowempcode && d.status === "Applied" && d.compensationstatus === '');
    const permissionRejectedWithoutComp = permission.filter((d) => d.employeeid === rowempcode && d.status === "Rejected" && d.compensationstatus === '');

    const totalPermissionApprovedEnd = permission.filter((d) => d.employeeid === rowempcode && d.status === "Approved" && d.compensationstatus === 'Compensation');
    const totalPermissionAppliedEnd = permission.filter((d) => d.employeeid === rowempcode && d.status === "Applied" && d.compensationstatus === 'Compensation');

    const holidayResults = holidays.filter((item) => moment(item.date, "YYYY-MM-DD").format("DD/MM/YYYY") === rowformattedDate)

    const isHoliday = holidayResults.some(holiday =>
        holiday.company?.includes(rowcompany) &&
            holiday.applicablefor?.includes(rowbranch) &&
            holiday.unit?.includes(rowunit) &&
            holiday.team?.includes(rowteam) &&
            holiday.employee.includes('ALL') ? rowcompanyname : holiday.employee?.includes(rowcompanyname)
    );

    let leavestatusApproved = [];

    leavetype?.map((type) => {
        totalFinalLeaveDaysApproved && totalFinalLeaveDaysApproved.forEach((d) => {
            if (type.leavetype === d.leavetype) {
                d.usershifts.forEach((shift) => {
                    leavestatusApproved.push({
                        date: shift.formattedDate,
                        shiftmode: shift.shiftmode,
                        leavetype: d.leavetype,
                        status: d.status,
                        code: type.code,
                        tookleavecheckstatus: shift.tookleavecheckstatus,
                        leavestatus: shift.leavestatus,
                        shiftcount: shift.shiftcount,
                    });
                })
            }
        });
    });

    let leavestatusApplied = [];

    leavetype?.map((type) => {
        totalFinalLeaveDaysApplied && totalFinalLeaveDaysApplied.forEach((d) => {
            if (type.leavetype === d.leavetype) {
                d.usershifts.forEach((shift) => {
                    leavestatusApplied.push({
                        date: shift.formattedDate,
                        shiftmode: shift.shiftmode,
                        leavetype: d.leavetype,
                        status: d.status,
                        code: type.code,
                        tookleavecheckstatus: shift.tookleavecheckstatus,
                        leavestatus: shift.leavestatus,
                        shiftcount: shift.shiftcount,
                    });
                })
            }
        });
    });

    let leavestatusRejected = [];

    leavetype?.map((type) => {
        totalFinalLeaveDaysRejected && totalFinalLeaveDaysRejected.forEach((d) => {
            if (type.leavetype === d.leavetype) {
                d.usershifts.forEach((shift) => {
                    leavestatusRejected.push({
                        date: shift.formattedDate,
                        shiftmode: shift.shiftmode,
                        leavetype: d.leavetype,
                        status: d.status,
                        code: type.code,
                        tookleavecheckstatus: shift.tookleavecheckstatus,
                        leavestatus: shift.leavestatus,
                        shiftcount: shift.shiftcount,
                    });
                })
            }
        });
    });

    let leaveWithoutApproved = [];

    totalFinalLeaveDaysApproved && totalFinalLeaveDaysApproved.forEach((d) => {
        if (d.leavetype === 'Leave Without Pay (LWP)') {
            d.usershifts.forEach((shift) => {
                leaveWithoutApproved.push({
                    date: shift.formattedDate,
                    shiftmode: shift.shiftmode,
                    leavetype: d.leavetype,
                    status: d.status,
                    tookleavecheckstatus: shift.tookleavecheckstatus,
                    leavestatus: shift.leavestatus,
                    shiftcount: shift.shiftcount,
                });
            })
        }
    });

    let leaveWithoutApplied = [];

    totalFinalLeaveDaysApplied && totalFinalLeaveDaysApplied.forEach((d) => {
        if (d.leavetype === 'Leave Without Pay (LWP)') {
            d.usershifts.forEach((shift) => {
                leaveWithoutApplied.push({
                    date: shift.formattedDate,
                    shiftmode: shift.shiftmode,
                    leavetype: d.leavetype,
                    status: d.status,
                    tookleavecheckstatus: shift.tookleavecheckstatus,
                    leavestatus: shift.leavestatus,
                    shiftcount: shift.shiftcount,
                });
            })
        }
    });

    let leaveWithoutRejected = [];

    totalFinalLeaveDaysRejected && totalFinalLeaveDaysRejected.forEach((d) => {
        if (d.leavetype === 'Leave Without Pay (LWP)') {
            d.usershifts.forEach((shift) => {
                leaveWithoutRejected.push({
                    date: shift.formattedDate,
                    shiftmode: shift.shiftmode,
                    leavetype: d.leavetype,
                    status: d.status,
                    tookleavecheckstatus: shift.tookleavecheckstatus,
                    leavestatus: shift.leavestatus,
                    shiftcount: shift.shiftcount,
                });
            })
        }
    });

    const leaveOnDateApprovedSingleFL = leavestatusApproved.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'Shift');
    const leaveOnDateApprovedSingleHB = leavestatusApproved.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'Before Half Shift');
    const leaveOnDateApprovedSingleHA = leavestatusApproved.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'After Half Shift');

    const leaveOnDateApprovedDoubleFL = leavestatusApproved.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'Shift');
    const leaveOnDateApprovedDoubleHB = leavestatusApproved.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'Before Half Shift');
    const leaveOnDateApprovedDoubleHA = leavestatusApproved.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'After Half Shift');

    const leaveOnDateAppliedSingleFL = leavestatusApplied.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'Shift');
    const leaveOnDateAppliedSingleHB = leavestatusApplied.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'Before Half Shift');
    const leaveOnDateAppliedSingleHA = leavestatusApplied.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'After Half Shift');

    const leaveOnDateAppliedDoubleFL = leavestatusApplied.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'Shift');
    const leaveOnDateAppliedDoubleHB = leavestatusApplied.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'Before Half Shift');
    const leaveOnDateAppliedDoubleHA = leavestatusApplied.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'After Half Shift');

    const leaveOnDateRejectedSingleFL = leavestatusRejected.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'Shift');
    const leaveOnDateRejectedSingleHB = leavestatusRejected.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'Before Half Shift');
    const leaveOnDateRejectedSingleHA = leavestatusRejected.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'After Half Shift');

    const leaveOnDateRejectedDoubleFL = leavestatusRejected.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'Shift');
    const leaveOnDateRejectedDoubleHB = leavestatusRejected.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'Before Half Shift');
    const leaveOnDateRejectedDoubleHA = leavestatusRejected.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'After Half Shift');

    const leaveWithoutOnDateApprovedSingleFL = leaveWithoutApproved.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'Shift');
    const leaveWithoutOnDateApprovedSingleHB = leaveWithoutApproved.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'Before Half Shift');
    const leaveWithoutOnDateApprovedSingleHA = leaveWithoutApproved.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'After Half Shift');

    const leaveWithoutOnDateApprovedDoubleFL = leaveWithoutApproved.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'Shift');
    const leaveWithoutOnDateApprovedDoubleHB = leaveWithoutApproved.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'Before Half Shift');
    const leaveWithoutOnDateApprovedDoubleHA = leaveWithoutApproved.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'After Half Shift');

    const leaveWithoutOnDateAppliedSingleFL = leaveWithoutApplied.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'Shift');
    const leaveWithoutOnDateAppliedSingleHB = leaveWithoutApplied.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'Before Half Shift');
    const leaveWithoutOnDateAppliedSingleHA = leaveWithoutApplied.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'After Half Shift');

    const leaveWithoutOnDateAppliedDoubleFL = leaveWithoutApplied.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'Shift');
    const leaveWithoutOnDateAppliedDoubleHB = leaveWithoutApplied.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'Before Half Shift');
    const leaveWithoutOnDateAppliedDoubleHA = leaveWithoutApplied.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'After Half Shift');

    const leaveWithoutOnDateRejectedSingleFL = leaveWithoutRejected.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'Shift');
    const leaveWithoutOnDateRejectedSingleHB = leaveWithoutRejected.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'Before Half Shift');
    const leaveWithoutOnDateRejectedSingleHA = leaveWithoutRejected.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Single' && d.leavestatus === 'After Half Shift');

    const leaveWithoutOnDateRejectedDoubleFL = leaveWithoutRejected.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'Shift');
    const leaveWithoutOnDateRejectedDoubleHB = leaveWithoutRejected.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'Before Half Shift');
    const leaveWithoutOnDateRejectedDoubleHA = leaveWithoutRejected.find((d) => d.date === rowformattedDate && d.shiftmode === rowshiftmode && d.tookleavecheckstatus === 'Double' && d.leavestatus === 'After Half Shift');

    if (leaveOnDateApprovedSingleFL) {
        return `${leaveOnDateApprovedSingleFL.code} ${leaveOnDateApprovedSingleFL.status}`;
    }
    else if (leaveOnDateApprovedSingleHB) {
        return `HB - ${leaveOnDateApprovedSingleHB.code} ${leaveOnDateApprovedSingleHB.status}`;
    }
    else if (leaveOnDateApprovedSingleHA) {
        return `HA - ${leaveOnDateApprovedSingleHA.code} ${leaveOnDateApprovedSingleHA.status}`;
    }
    else if (leaveOnDateApprovedDoubleFL) {
        return `DL - ${leaveOnDateApprovedDoubleFL.code} ${leaveOnDateApprovedDoubleFL.status}`;
    }
    else if (leaveOnDateApprovedDoubleHB) {
        return `DHB - ${leaveOnDateApprovedDoubleHB.code} ${leaveOnDateApprovedDoubleHB.status}`;
    }
    else if (leaveOnDateApprovedDoubleHA) {
        return `DHA - ${leaveOnDateApprovedDoubleHA.code} ${leaveOnDateApprovedDoubleHA.status}`;
    }
    else if (leaveOnDateAppliedSingleFL) {
        return `${leaveOnDateAppliedSingleFL.code} ${leaveOnDateAppliedSingleFL.status}`;
    }
    else if (leaveOnDateAppliedSingleHB) {
        return `HB - ${leaveOnDateAppliedSingleHB.code} ${leaveOnDateAppliedSingleHB.status}`;
    }
    else if (leaveOnDateAppliedSingleHA) {
        return `HA - ${leaveOnDateAppliedSingleHA.code} ${leaveOnDateAppliedSingleHA.status}`;
    }
    else if (leaveOnDateAppliedDoubleFL) {
        return `DL - ${leaveOnDateAppliedDoubleFL.code} ${leaveOnDateAppliedDoubleFL.status}`;
    }
    else if (leaveOnDateAppliedDoubleHB) {
        return `DHB - ${leaveOnDateAppliedDoubleHB.code} ${leaveOnDateAppliedDoubleHB.status}`;
    }
    else if (leaveOnDateAppliedDoubleHA) {
        return `DHA - ${leaveOnDateAppliedDoubleHA.code} ${leaveOnDateAppliedDoubleHA.status}`;
    }
    else if (leaveOnDateRejectedSingleFL) {
        return `${leaveOnDateRejectedSingleFL.code} ${leaveOnDateRejectedSingleFL.status}`;
    }
    else if (leaveOnDateRejectedSingleHB) {
        return `HB - ${leaveOnDateRejectedSingleHB.code} ${leaveOnDateRejectedSingleHB.status}`;
    }
    else if (leaveOnDateRejectedSingleHA) {
        return `HA - ${leaveOnDateRejectedSingleHA.code} ${leaveOnDateRejectedSingleHA.status}`;
    }
    else if (leaveOnDateRejectedDoubleFL) {
        return `DL - ${leaveOnDateRejectedDoubleFL.code} ${leaveOnDateRejectedDoubleFL.status}`;
    }
    else if (leaveOnDateRejectedDoubleHB) {
        return `DHB - ${leaveOnDateRejectedDoubleHB.code} ${leaveOnDateRejectedDoubleHB.status}`;
    }
    else if (leaveOnDateRejectedDoubleHA) {
        return `DHA - ${leaveOnDateRejectedDoubleHA.code} ${leaveOnDateRejectedDoubleHA.status}`;
    }
    else if (leaveWithoutOnDateApprovedSingleFL) {
        return `LWP ${leaveWithoutOnDateApprovedSingleFL.status}`;
    }
    else if (leaveWithoutOnDateApprovedSingleHB) {
        return `HB - LWP ${leaveWithoutOnDateApprovedSingleHB.status}`;
    }
    else if (leaveWithoutOnDateApprovedSingleHA) {
        return `HA - LWP ${leaveWithoutOnDateApprovedSingleHA.status}`;
    }
    else if (leaveWithoutOnDateApprovedDoubleFL) {
        return `DL - LWP ${leaveWithoutOnDateApprovedDoubleFL.status}`;
    }
    else if (leaveWithoutOnDateApprovedDoubleHB) {
        return `DHB - LWP ${leaveWithoutOnDateApprovedDoubleHB.status}`;
    }
    else if (leaveWithoutOnDateApprovedDoubleHA) {
        return `DHA - LWP ${leaveWithoutOnDateApprovedDoubleHA.status}`;
    }
    else if (leaveWithoutOnDateAppliedSingleFL) {
        return `LWP ${leaveWithoutOnDateAppliedSingleFL.status}`;
    }
    else if (leaveWithoutOnDateAppliedSingleHB) {
        return `HB - LWP ${leaveWithoutOnDateAppliedSingleHB.status}`;
    }
    else if (leaveWithoutOnDateAppliedSingleHA) {
        return `HA - LWP ${leaveWithoutOnDateAppliedSingleHA.status}`;
    }
    else if (leaveWithoutOnDateAppliedDoubleFL) {
        return `DL - LWP ${leaveWithoutOnDateAppliedDoubleFL.status}`;
    }
    else if (leaveWithoutOnDateAppliedDoubleHB) {
        return `DHB - LWP ${leaveWithoutOnDateAppliedDoubleHB.status}`;
    }
    else if (leaveWithoutOnDateAppliedDoubleHA) {
        return `DHA - LWP ${leaveWithoutOnDateAppliedDoubleHA.status}`;
    }
    else if (leaveWithoutOnDateRejectedSingleFL) {
        return `LWP ${leaveWithoutOnDateRejectedSingleFL.status}`;
    }
    else if (leaveWithoutOnDateRejectedSingleHB) {
        return `HB - LWP ${leaveWithoutOnDateRejectedSingleHB.status}`;
    }
    else if (leaveWithoutOnDateRejectedSingleHA) {
        return `HA - LWP ${leaveWithoutOnDateRejectedSingleHA.status}`;
    }
    else if (leaveWithoutOnDateRejectedDoubleFL) {
        return `DL - LWP ${leaveWithoutOnDateRejectedDoubleFL.status}`;
    }
    else if (leaveWithoutOnDateRejectedDoubleHB) {
        return `DHB - LWP ${leaveWithoutOnDateRejectedDoubleHB.status}`;
    }
    else if (leaveWithoutOnDateRejectedDoubleHA) {
        return `DHA - LWP ${leaveWithoutOnDateRejectedDoubleHA.status}`;
    }



    if (permissionApprovedWithoutComp.find((d) => moment(d.date, "YYYY-MM-DD").format("DD/MM/YYYY").includes(rowformattedDate) && d.shiftmode === rowshiftmode)) {
        return "PERAPPR";
    }
    if (permissionAppliedWithoutComp.find((d) => moment(d.date, "YYYY-MM-DD").format("DD/MM/YYYY").includes(rowformattedDate) && d.shiftmode === rowshiftmode)) {
        return "PERAPPL";
    }
    if (permissionRejectedWithoutComp.find((d) => moment(d.date, "YYYY-MM-DD").format("DD/MM/YYYY").includes(rowformattedDate) && d.shiftmode === rowshiftmode)) {
        return "PERREJ";
    }
    if (totalPermissionApprovedEnd.find((d) => moment(d.date, "YYYY-MM-DD").format("DD/MM/YYYY").includes(rowformattedDate) && d.shiftmode === rowshiftmode)) {
        return "COMP - PERAPPR";
    }
    if (totalPermissionAppliedEnd.find((d) => moment(d.date, "YYYY-MM-DD").format("DD/MM/YYYY").includes(rowformattedDate) && d.shiftmode === rowshiftmode)) {
        return "COMP - PERAPPR";
    }
    if (weekoffpresentstatus === true) {
        return 'Week Off Present';
    }

    // Get current date and time
    var now = new Date();
    var dd = String(now.getDate()).padStart(2, "0");
    var mm = String(now.getMonth() + 1).padStart(2, "0"); // January is 0!
    var yyyy = now.getFullYear();
    var today = dd + "/" + mm + "/" + yyyy;

    // Extract hours and minutes
    var hours = now.getHours();
    var minutes = now.getMinutes();

    // Format hours and minutes to always have two digits
    var formattedHours = String(hours).padStart(2, '0');
    var formattedMinutes = String(minutes).padStart(2, '0');

    // Combine hours and minutes into the desired format
    var currentTime = formattedHours + ":" + formattedMinutes;

    let clockOutTime = parseTime(clockouttime);
    let startTime = parseTime(rowshift?.split('to')[0]);
    let startTimeWithPM = rowshift?.split('to')[0];

    let endTime = parseTime(rowshift?.split('to')[1]);

    if (!startTime) {
        return rowshift === 'Not Allotted' ? 'Not Allotted' : (rowshift === 'Week Off' && clockintime === "00:00:00") ? 'Week Off' : 'Invalid start time';
    }

    if (!endTime) {
        return rowshift === 'Not Allotted' ? 'Not Allotted' : (rowshift === 'Week Off' && clockouttime === "00:00:00") ? 'Week Off' : (rowshift === 'Pending...' && clockouttime !== "00:00:00") ? 'Pending...' : 'Invalid end time';
    }

    // Determine if it's a night shift
    const isNightShift = startTime.getHours() >= 12;

    // Compare clockouttime based on shift type
    if (startTimeWithPM.includes('PM')) {

        // Adjust endTime if it's a night shift
        if (startTimeWithPM.includes('PM') && clockouttime.includes('AM')) {
            // Check if endTime is before startTime (indicating the shift crosses midnight)        
            if (endTime < startTime) {
                endTime.setDate(endTime.getDate() + 1); // Move endTime to the next day
                clockOutTime.setDate(clockOutTime.getDate() + 1);
            }
        }
        else if (startTimeWithPM.includes('PM') && clockouttime.includes('PM')) {
            if (endTime < startTime) {
                endTime.setDate(endTime.getDate() + 1);
                clockOutTime.setDate(clockOutTime.getDate() - 1);
            }
        }

        // Add onClockOutTime to the endTime
        const onClockOutMilliseconds = onClockOutTime * 60000; // Convert onClockOutTime to milliseconds
        const endTimeWithGrace = new Date(endTime?.getTime() + onClockOutMilliseconds);

        // subtract earlyClockOutTime to the endTime
        const earlyClockOutMilliseconds = earlyClockOutTime * 60000;
        const endTimeWithEarly = new Date(endTime?.getTime() - earlyClockOutMilliseconds);

        // subtract earlyClockOutTime to the endTime
        const beforeEarlyClockOutMilliseconds = beforeEarlyClockOutTime * 60000;
        const endTimeWithBeforeEarly = new Date(endTime?.getTime() - earlyClockOutMilliseconds - beforeEarlyClockOutMilliseconds);

        const [rowday, rowmonth, rowyear] = rowformattedDate.split('/');
        const addrowday = Number(rowday) + 1;
        const endRowDayAdd = String(addrowday).padStart(2, '0');

        const currentDate = new Date();
        const curyear = currentDate.getFullYear();
        const curmonth = String(currentDate.getMonth() + 1).padStart(2, '0'); // Add 1 to month as it's zero-based
        const curday = String(currentDate.getDate()).padStart(2, '0');
        const hours = String(currentDate.getHours()).padStart(2, '0');
        const minutes = String(currentDate.getMinutes()).padStart(2, '0');
        const seconds = String(currentDate.getSeconds()).padStart(2, '0');

        const endHoursN8 = String(endTime?.getHours()).padStart(2, '0');
        const endMinutesN8 = String(endTime?.getMinutes()).padStart(2, '0');
        const endSecondsN8 = String(endTime?.getSeconds()).padStart(2, '0');

        const currentDateTimeString = `${curyear}-${curmonth}-${curday} ${hours}:${minutes}:${seconds}`;
        const getEndTimeForNight = `${rowyear}-${rowmonth}-${endRowDayAdd} ${endHoursN8}:${endMinutesN8}:${endSecondsN8}`;




        // Night shift
        if (isHoliday && rowshift !== "Week Off") {
            return 'Holiday';
        }
        else if (clockintime === "00:00:00" && rowshift !== "Week Off" && today === rowformattedDate && new Date(2000, 0, 1, ...currentTime.split(':').map(Number)) < startTime) {
            return `Shift Not Started`;
        }
        else if (clockintime === "00:00:00" && clockouttime === "00:00:00" && rowshift !== "Week Off") {
            return `Absent`;
        }
        else if (rowshift === "Pending..." && clockouttime !== "00:00:00") {
            return `Pending...`;
        }
        else if (rowshift === "Week Off" && clockouttime === "00:00:00") {
            return `Week Off`;
        }
        else if (rowshift === "Not Allotted" && clockouttime === "00:00:00") {
            return `Not Allotted`;
        }
        else if (autoClockOutStatus === true && clockouttime !== "00:00:00") {
            return `Auto Mis - ClockOut`;
        }
        else if (clockouttime !== "00:00:00" && clockOutTime >= endTimeWithEarly && clockOutTime < endTime) {
            return `Early - ClockOut`;
        }
        else if (clockouttime !== "00:00:00" && clockOutTime >= endTimeWithBeforeEarly && clockOutTime < endTimeWithEarly) {
            return `HALOP`;
        }
        else if (clockouttime !== "00:00:00" && clockOutTime < endTimeWithBeforeEarly) {
            return `FLOP`;
        }
        else if (clockOutTime >= endTime && clockOutTime <= endTimeWithGrace) {
            return `On - ClockOut`;
        }
        else if (clockouttime !== "00:00:00" && clockOutTime > endTimeWithGrace) {
            return `Over - ClockOut`;
        }
        else if (clockintime !== "00:00:00" && clockouttime === "00:00:00" && currentDateTimeString <= getEndTimeForNight) {
            return `Pending`;
        }
        else if (clockouttime === "00:00:00") {
            return `Mis - ClockOut`;
        }
    } else {

        // Parse the clock in date
        const [day, month, year] = clockindate.split('-');
        const shiftStartDate = new Date(Number(year), Number(month) - 1, Number(day));
        const shiftEndDate = new Date(Number(year), Number(month) - 1, Number(day));

        // If endTime is before startTime, it indicates the shift crosses midnight
        // Adjust endTime accordingly
        if (endTime < startTime) {
            shiftEndDate.setDate(shiftEndDate.getDate() + 1); // Adjust shiftEndDate to the next day
        }

        const [rowday, rowmonth, rowyear] = rowformattedDate.split('/');
        const addrowday = Number(rowday) + 1;
        const endRowDayAdd = String(addrowday).padStart(2, '0');

        const currentDate = new Date();
        const curyear = currentDate.getFullYear();
        const curmonth = String(currentDate.getMonth() + 1).padStart(2, '0'); // Add 1 to month as it's zero-based
        const curday = String(currentDate.getDate()).padStart(2, '0');
        const hours = String(currentDate.getHours()).padStart(2, '0');
        const minutes = String(currentDate.getMinutes()).padStart(2, '0');
        const seconds = String(currentDate.getSeconds()).padStart(2, '0');

        const endHoursN8 = String(endTime?.getHours()).padStart(2, '0');
        const endMinutesN8 = String(endTime?.getMinutes()).padStart(2, '0');
        const endSecondsN8 = String(endTime?.getSeconds()).padStart(2, '0');


        const currentDateTimeString = `${curyear}-${curmonth}-${curday} ${hours}:${minutes}:${seconds}`;
        const getEndTimeForNight = `${rowyear}-${rowmonth}-${endRowDayAdd} ${endHoursN8}:${endMinutesN8}:${endSecondsN8}`;


        // Add onClockOutTime to the endTime
        const onClockOutMilliseconds = onClockOutTime * 60000; // Convert onClockOutTime to milliseconds
        const endTimeWithGrace = new Date(endTime.getTime() + onClockOutMilliseconds);

        // subtract earlyClockOutTime to the endTime
        const earlyClockOutMilliseconds = earlyClockOutTime * 60000;
        const endTimeWithEarly = new Date(endTime.getTime() - earlyClockOutMilliseconds);

        // subtract earlyClockOutTime to the endTime
        const beforeEarlyClockOutMilliseconds = beforeEarlyClockOutTime * 60000;
        const endTimeWithBeforeEarly = new Date(endTime.getTime() - earlyClockOutMilliseconds - beforeEarlyClockOutMilliseconds);




        // Day shift
        if (isHoliday && rowshift !== "Week Off") {
            return 'Holiday';
        }
        else if (clockintime === "00:00:00" && rowshift !== "Week Off" && today === rowformattedDate && new Date(2000, 0, 1, ...currentTime.split(':').map(Number)) < startTime) {
            return `Shift Not Started`;
        }
        else if (clockintime === "00:00:00" && clockouttime === "00:00:00" && rowshift !== "Week Off") {
            return `Absent`;
        }
        else if (rowshift === "Pending..." && clockouttime !== "00:00:00") {
            return `Pending...`;
        }
        else if (rowshift === "Week Off" && clockouttime === "00:00:00") {
            return `Week Off`;
        }
        else if (rowshift === "Not Allotted" && clockouttime === "00:00:00") {
            return `Not Allotted`;
        }
        else if (autoClockOutStatus === true && clockouttime !== "00:00:00") {
            return `Auto Mis - ClockOut`;
        }
        else if (clockouttime !== "00:00:00" && clockOutTime >= endTimeWithEarly && clockOutTime < endTime) {
            return `Early - ClockOut`;
        }
        else if (clockouttime !== "00:00:00" && clockOutTime >= endTimeWithBeforeEarly && clockOutTime < endTimeWithEarly) {
            return `HALOP`;
        }
        else if (clockouttime !== "00:00:00" && clockOutTime < endTimeWithBeforeEarly) {
            return `FLOP`;
        }
        else if (clockOutTime >= endTime && clockOutTime <= endTimeWithGrace) {
            return `On - ClockOut`;
        }
        else if (clockintime !== "00:00:00" && clockOutTime > endTimeWithGrace) {
            return `Over - ClockOut`;
        }
        else if (clockintime !== "00:00:00" && clockouttime === "00:00:00" && currentDateTimeString <= getEndTimeForNight) {
            return `Pending`;
        }
        else if (clockouttime === "00:00:00") {
            return `Mis - ClockOut`;
        }
    }
};

function getWeekNumberInMonth(date) {
    const firstDayOfMonth = new Date(date.getFullYear(), date.getMonth(), 1);
    const dayOfWeek = firstDayOfMonth.getDay(); // 0 (Sunday) to 6 (Saturday)

    // If the first day of the month is not Monday (1), calculate the adjustment
    const adjustment = dayOfWeek === 0 ? 6 : dayOfWeek - 1;

    // Calculate the day of the month adjusted for the starting day of the week
    const dayOfMonthAdjusted = date.getDate() + adjustment;

    // Calculate the week number based on the adjusted day of the month
    const weekNumber = Math.ceil(dayOfMonthAdjusted / 7);

    return weekNumber;
}

const getShiftForDateProdDay = (column, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, boardingLog, isWeekOff, matchingDoubleShiftItem, department, overAllDepartment, matchingRemovedItem, matchingAssignShiftItem) => {
    // const selectedDateIndex = createdUserDates.findIndex(dateObj => dateObj.formattedDate === column.formattedDate);

    // if (selectedDateIndex === -1) {
    //     return !isWeekOff ? actualShiftTiming : "Week Off";
    // }

    // if (matchingItem && matchingItem?._doc?.adjstatus === 'Adjustment') {
    //     return `${matchingItem?._doc?.selectedShifTime.split(' - ')[0]}to${matchingItem?._doc?.selectedShifTime.split(' - ')[1]}`;
    // }
    // else
    if (matchingDoubleShiftItem && matchingDoubleShiftItem?._doc?.adjstatus === 'Approved' && matchingDoubleShiftItem && matchingDoubleShiftItem?._doc?.adjustmenttype === 'Shift Weekoff Swap') {
        return matchingDoubleShiftItem?._doc?.todateshiftmode;
    }
    else if (matchingDoubleShiftItem && matchingDoubleShiftItem?._doc?.adjstatus === 'Approved' && matchingDoubleShiftItem && matchingDoubleShiftItem?._doc?.adjustmenttype === 'WeekOff Adjustment') {
        return matchingDoubleShiftItem?._doc?.todateshiftmode;
    }
    else if (matchingDoubleShiftItem && matchingDoubleShiftItem?._doc?.adjstatus === 'Approved' && matchingDoubleShiftItem && matchingDoubleShiftItem?._doc?.adjustmenttype === 'Shift Adjustment') {
        if (matchingAssignShiftItem && matchingDoubleShiftItem?._doc?.todate === matchingAssignShiftItem?._doc?.adjdate) {
            return `${matchingDoubleShiftItem?._doc?.adjchangeshiftime.split(' - ')[0]}to${matchingDoubleShiftItem?._doc?.adjchangeshiftime.split(' - ')[1]}`;
        } else {
            return 'Not Allotted';
        }
    }
    else if (matchingRemovedItem && matchingRemovedItem?._doc?.adjstatus === 'Not Allotted') {
        return 'Not Allotted';
    }
    else if (matchingItem && matchingItem?._doc?.adjstatus === 'Approved') {
        if (matchingItem?._doc?.adjustmenttype === "Add On Shift" || matchingItem?._doc?.adjustmenttype === 'Shift Adjustment' || matchingItem?._doc?.adjustmenttype === 'Shift Weekoff Swap') {
            if (column.shiftMode === 'Main Shift') {
                return `${matchingItem?._doc?.adjchangeshiftime.split(' - ')[0]}to${matchingItem?._doc?.adjchangeshiftime.split(' - ')[1]}`
            } else if (column.shiftMode === 'Second Shift') {
                return `${matchingItem?._doc?.pluseshift.split(' - ')[0]}to${matchingItem?._doc?.pluseshift.split(' - ')[1]}`
            }
        }
        else {
            return (isWeekOffWithAdjustment ? (`${matchingItem?._doc?.adjchangeshiftime.split(' - ')[0]}to${matchingItem?._doc?.adjchangeshiftime.split(' - ')[1]}`) : (`${matchingItem?._doc?.adjchangeshiftime.split(' - ')[0]}to${matchingItem?._doc?.adjchangeshiftime.split(' - ')[1]}`));
        }
    }
    else if (matchingItemAllot && matchingItemAllot?._doc?.status === "Manual") {
        return isWeekOffWithManual ? (`${matchingItemAllot._doc?.firstshift.split(' - ')[0]}to${matchingItemAllot?._doc?.firstshift.split(' - ')[1]} `) :
            (`${matchingItemAllot?._doc?.firstshift.split(' - ')[0]}to${matchingItemAllot?._doc?.firstshift.split(' - ')[1]} `);
    }
    else if (matchingItemAllot && matchingItemAllot?._doc?.status === "Week Off") {
        return 'Week Off';
    }
    else if (matchingItem && matchingItem?._doc?.adjstatus === 'Reject' && isWeekOff) {
        // If the adjustment status is 'Reject' and it's a week off, return 'Week Off'
        return 'Week Off';
    }
    // before add shifttype condition working code
    // else if (boardingLog?.length > 0) {

    //     const [columnDay, columnMonth, columnYear] = column.formattedDate?.split('/');
    //     const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

    //     // Filter boardingLog entries for the same start date
    //     const entriesForDate = boardingLog.filter(log => log.startdate === finalDate);

    //     // If there are entries for the date, return the shift timing of the second entry
    //     if (entriesForDate.length > 1) {
    //         return entriesForDate[1].shifttiming;
    //     }

    //     // Find the most recent boarding log entry that is less than or equal to the selected date
    //     const recentLogEntry = boardingLog
    //         .filter(log => log.startdate < finalDate)
    //         .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

    //     // If a recent log entry is found, return its shift timing
    //     if (recentLogEntry) {
    //         return !isWeekOff ? recentLogEntry.shifttiming : "Week Off";
    //     } else {
    //         // If no relevant boarding log entry is found, return the previous shift timing or 'Week Off' if it's a week off
    //         return !isWeekOff ? actualShiftTiming : "Week Off";
    //     }
    // } 
    else if (boardingLog.length > 0) {
        // Remove duplicate entries with recent entry
        const uniqueEntries = {};
        boardingLog.forEach(entry => {
            const key = entry.startdate;
            if (!(key in uniqueEntries) || uniqueEntries[key].time <= entry.time) {
                uniqueEntries[key] = entry;
            }
        });
        const uniqueBoardingLog = Object.values(uniqueEntries);

        const [columnDay, columnMonth, columnYear] = column.formattedDate?.split('/');
        const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

        // Find the relevant log entry for the given date     
        const relevantLogEntry = uniqueBoardingLog
            .filter(log => log.startdate <= finalDate)
            .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

        const logWeekOff = relevantLogEntry && relevantLogEntry.weekoff.includes(column.dayName)

        if (relevantLogEntry) {

            // Daily
            if (relevantLogEntry.shifttype === 'Standard' || relevantLogEntry.shifttype === undefined) {
                // If shift type is 'Daily', return the same shift timing for each day
                //    return !isWeekOff ? relevantLogEntry.shifttiming : 'Week Off';
                return !logWeekOff ? relevantLogEntry.shifttiming : 'Week Off';
            }

            // 1 Week Rotation 2nd try working code
            if (relevantLogEntry.shifttype === 'Daily') {
                for (const data of relevantLogEntry.todo) {
                    const columnWeek = (column.weekNumberInMonth === '2nd Week' ? '1st Week' : column.weekNumberInMonth === '3rd Week' ? '1st Week' : column.weekNumberInMonth === '4th Week' ? '1st Week' : column.weekNumberInMonth === '5th Week' ? '1st Week' : '1st Week');
                    if (data.week === columnWeek && data.day === column.dayName) {
                        return data.shiftmode === 'Shift' ? data.shifttiming : 'Week Off';
                    }
                }
            }

            // 2 Week Rotation 2nd try working code  
            if (relevantLogEntry.shifttype === '1 Week Rotation') {
                const startDate = new Date(relevantLogEntry.startdate); // Get the start date

                // Get the day name of the start date
                const startDayName = startDate.toLocaleDateString('en-US', { weekday: 'long' });

                // Calculate the day count until the next Sunday
                let dayCount = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'].indexOf(startDayName);

                // Calculate the week number based on the day count
                let weekNumber = Math.ceil((7 - dayCount) / 7);

                // Adjust the week number considering the two-week rotation
                const logStartDate = new Date(relevantLogEntry.startdate);
                const currentDate = new Date(finalDate);

                const diffTime = Math.abs(currentDate - logStartDate);
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

                weekNumber += Math.floor((diffDays - (7 - dayCount)) / 7); // Adjust for complete 2-week cycles passed

                // Determine the final week based on the calculated week number                    
                const finalWeek = (weekNumber % 2 === 0) ? '1st Week' : '2nd Week';

                for (const data of relevantLogEntry.todo) {
                    // Check if the adjusted week matches the column week and day
                    if (data.week === finalWeek && data.day === column.dayName) {
                        return data.shiftmode === 'Shift' ? data.shifttiming : 'Week Off';
                    }
                }
            }

            //just 2wk rotation
            if (relevantLogEntry.shifttype === '2 Week Rotation') {

                const matchingDepartment = overAllDepartment.find(
                    (dep) =>
                        dep.department === department &&
                        new Date(dep.fromdate) <= new Date(relevantLogEntry.startdate) &&
                        new Date(relevantLogEntry.startdate) <= new Date(dep.todate)
                );

                // Use the fromdate of the matching department as the startDate
                let startDate = matchingDepartment
                    ? new Date(matchingDepartment.fromdate)
                    : new Date(relevantLogEntry.startdate);

                // Calculate month lengths
                const monthLengths = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

                // Function to determine if a year is a leap year
                const isLeapYear = (year) => {
                    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
                };

                const currentDate = new Date(finalDate);

                // Determine the effective month for the start date
                let effectiveMonth = startDate.getMonth();
                if (startDate.getDate() > 15) {
                    // Consider the next month if the start date is after the 15th
                    effectiveMonth = (effectiveMonth + 1) % 12;
                }

                // Calculate total days for 1-month rotation based on the effective month
                let totalDays = monthLengths[effectiveMonth];

                // Set the initial endDate by adding totalDays to the startDate
                let endDate = new Date(startDate);
                endDate.setDate(endDate.getDate() + totalDays - 1); // Subtract 1 to account for zero-indexing

                // Adjust February for leap years
                if (isLeapYear(endDate.getFullYear())) {
                    monthLengths[1] = 29;
                }

                // Adjust startDate and endDate if the currentDate is beyond the initial endDate
                while (currentDate > endDate) {
                    // Set startDate to the next matchingDepartment.fromdate for each cycle
                    startDate = new Date(endDate);
                    startDate.setDate(startDate.getDate() + 1); // Move to the next day

                    // Determine the new effective month for the next cycle
                    effectiveMonth = startDate.getMonth();
                    if (startDate.getDate() > 15) {
                        effectiveMonth = (effectiveMonth + 1) % 12;
                    }

                    totalDays = monthLengths[effectiveMonth];

                    // Set the new endDate by adding totalDays to the new startDate
                    endDate = new Date(startDate);
                    endDate.setDate(endDate.getDate() + totalDays - 1); // Include entire period

                    // Adjust February for leap years
                    if (isLeapYear(endDate.getFullYear())) {
                        monthLengths[1] = 29;
                    }
                }

                // Calculate the difference in days correctly
                const diffTime = Math.abs(currentDate.getTime() - startDate.getTime());
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1; // Add 1 to include start date

                // Determine the start day of the first week
                let startDayOfWeek = startDate.getDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday

                // Adjust the start day so that Monday is considered the start of the week
                let startDayOffset = startDayOfWeek === 0 ? 6 : startDayOfWeek - 1;

                // Calculate the week number based on Monday to Sunday cycle
                let adjustedDiffDays = diffDays + startDayOffset; // Adjust diffDays to account for start day                                      

                // Calculate the week number within the rotation month based on 7-day intervals from start date
                // const weekNumber = Math.ceil(diffDays / 7);
                let weekNumber = Math.floor((adjustedDiffDays - 1) / 7) + 1; // Divide by 7 to get the week count

                const weekNames = [
                    "1st Week",
                    "2nd Week",
                    "3rd Week",
                    "4th Week",
                    "5th Week",
                    "6th Week",
                    "7th Week",
                    "8th Week",
                    "9th Week",
                ];
                const finalWeek = weekNames[(weekNumber - 1) % weekNames.length];

                for (const data of relevantLogEntry.todo) {
                    if (data.week === finalWeek && data.day === column.dayName) {
                        return data.shiftmode === "Shift" ? data.shifttiming : "Week Off";
                    }
                }
            }

            //just 1mont rota updated          
            if (relevantLogEntry.shifttype === '1 Month Rotation') {

                const matchingDepartment = overAllDepartment.find(
                    (dep) =>
                        dep.department === department &&
                        new Date(dep.fromdate) <= new Date(relevantLogEntry.startdate) &&
                        new Date(relevantLogEntry.startdate) <= new Date(dep.todate)
                );

                // Use the fromdate of the matching department as the startDate
                let startDate = matchingDepartment
                    ? new Date(matchingDepartment.fromdate)
                    : new Date(relevantLogEntry.startdate);

                const currentDate = new Date(finalDate);

                // Function to determine if a year is a leap year
                const isLeapYear = (year) => {
                    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
                };

                // Calculate month lengths with leap year check for a given year
                const calculateMonthLengths = (year) => {
                    return [31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
                };

                // Determine the effective month and year for the start date
                let effectiveMonth = startDate.getMonth();
                let effectiveYear = startDate.getFullYear();
                if (startDate.getDate() > 15) {
                    // Consider the next month if the start date is after the 15th
                    effectiveMonth = (effectiveMonth + 1) % 12;
                    if (effectiveMonth === 0) {
                        effectiveYear += 1; // Move to the next year if month resets
                    }
                }

                // Calculate total days for the current two-month cycle
                let totalDays = 0;
                for (let i = 0; i < 2; i++) {
                    const monthIndex = (effectiveMonth + i) % 12;
                    const yearAdjustment = Math.floor((effectiveMonth + i) / 12);
                    const currentYear = effectiveYear + yearAdjustment;
                    const monthLengthsForYear = calculateMonthLengths(currentYear);
                    totalDays += monthLengthsForYear[monthIndex];
                }

                // Set the endDate by adding totalDays to the startDate
                let endDate = new Date(startDate);
                endDate.setDate(endDate.getDate() + totalDays - 1); // Include entire period

                // Recalculate if currentDate is beyond the initial endDate
                while (currentDate > endDate) {
                    startDate = new Date(endDate);
                    startDate.setDate(startDate.getDate() + 1); // Move to the next day

                    // Determine the new effective month and year for the next cycle
                    effectiveMonth = startDate.getMonth();
                    effectiveYear = startDate.getFullYear();
                    if (startDate.getDate() > 15) {
                        effectiveMonth = (effectiveMonth + 1) % 12;
                        if (effectiveMonth === 0) {
                            effectiveYear += 1;
                        }
                    }

                    totalDays = 0;
                    for (let i = 0; i < 2; i++) {
                        const monthIndex = (effectiveMonth + i) % 12;
                        const yearAdjustment = Math.floor((effectiveMonth + i) / 12);
                        const currentYear = effectiveYear + yearAdjustment;
                        const monthLengthsForYear = calculateMonthLengths(currentYear);
                        totalDays += monthLengthsForYear[monthIndex];
                    }

                    // Set the new endDate by adding totalDays to the new startDate
                    endDate = new Date(startDate);
                    endDate.setDate(endDate.getDate() + totalDays - 1); // Include entire period
                }

                // Calculate the difference in days including the start date
                const diffTime = Math.abs(currentDate.getTime() - startDate.getTime());
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1; // Add 1 to include the start date

                // Determine the start day of the first week
                let startDayOfWeek = startDate.getDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday

                // Adjust the start day so that Monday is considered the start of the week
                let startDayOffset = startDayOfWeek === 0 ? 6 : startDayOfWeek - 1;

                // Calculate the week number based on Monday to Sunday cycle
                let adjustedDiffDays = diffDays - 1 + startDayOffset; // Adjust diffDays to account for start day
                let weekNumber = Math.floor(adjustedDiffDays / 7) + 1; // Divide by 7 to get the week count

                // Define week names for first and second month of the cycle
                const weekNamesFirstMonth = [
                    "1st Week",
                    "2nd Week",
                    "3rd Week",
                    "4th Week",
                    "5th Week",
                    "6th Week"
                ];

                const weekNamesSecondMonth = [
                    "7th Week",
                    "8th Week",
                    "9th Week",
                    "10th Week",
                    "11th Week",
                    "12th Week"
                ];

                // Determine which month we are in
                const daysInFirstMonth = calculateMonthLengths(startDate.getFullYear())[effectiveMonth];
                let finalWeek;

                if (diffDays <= daysInFirstMonth) {
                    // We're in the first month of the cycle
                    weekNumber = (weekNumber - 1) % weekNamesFirstMonth.length + 1;
                    finalWeek = weekNamesFirstMonth[weekNumber - 1];
                } else {
                    // We're in the second month of the cycle
                    const secondMonthDay = diffDays - daysInFirstMonth;

                    // Calculate week number based on Monday-Sunday for the second month
                    const secondMonthStartDayOffset = new Date(startDate.getTime() + daysInFirstMonth * 24 * 60 * 60 * 1000).getDay();
                    const secondMonthStartOffset = secondMonthStartDayOffset === 0 ? 6 : secondMonthStartDayOffset - 1;
                    const secondMonthAdjustedDays = secondMonthDay - 1 + secondMonthStartOffset;
                    const secondMonthWeekNumber = Math.floor(secondMonthAdjustedDays / 7) + 1;

                    finalWeek = weekNamesSecondMonth[secondMonthWeekNumber - 1];
                }

                for (const data of relevantLogEntry.todo) {
                    if (data.week === finalWeek && data.day === column.dayName) {
                        return data.shiftmode === "Shift" ? data.shifttiming : "Week Off";
                    }
                }
            }
        }
    }

};

const getShiftForDateDayShift = (column, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, boardingLog, isWeekOff, matchingDoubleShiftItem, department, overAllDepartment, matchingRemovedItem, matchingAssignShiftItem) => {
    // const selectedDateIndex = createdUserDates.findIndex(dateObj => dateObj.formattedDate === column.formattedDate);

    // if (selectedDateIndex === -1) {
    //     return !isWeekOff ? actualShiftTiming : "Week Off";
    // }

    // if (matchingItem && matchingItem?._doc?.adjstatus === 'Adjustment') {
    //     return `${matchingItem?._doc?.selectedShifTime.split(' - ')[0]}to${matchingItem?._doc?.selectedShifTime.split(' - ')[1]}`;
    // }
    // else
    if (matchingDoubleShiftItem && matchingDoubleShiftItem?._doc?.adjstatus === 'Approved' && matchingDoubleShiftItem && matchingDoubleShiftItem?._doc?.adjustmenttype === 'Shift Weekoff Swap') {
        return matchingDoubleShiftItem?._doc?.todateshiftmode;
    }
    else if (matchingDoubleShiftItem && matchingDoubleShiftItem?._doc?.adjstatus === 'Approved' && matchingDoubleShiftItem && matchingDoubleShiftItem?._doc?.adjustmenttype === 'WeekOff Adjustment') {
        return matchingDoubleShiftItem?._doc?.todateshiftmode;
    }
    else if (matchingDoubleShiftItem && matchingDoubleShiftItem?._doc?.adjstatus === 'Approved' && matchingDoubleShiftItem && matchingDoubleShiftItem?._doc?.adjustmenttype === 'Shift Adjustment') {
        if (matchingAssignShiftItem && matchingDoubleShiftItem?._doc?.todate === matchingAssignShiftItem?._doc?.adjdate) {
            return `${matchingDoubleShiftItem?._doc?.adjchangeshiftime.split(' - ')[0]}to${matchingDoubleShiftItem?._doc?.adjchangeshiftime.split(' - ')[1]}`;
        } else {
            return 'Not Allotted';
        }
    }
    else if (matchingRemovedItem && matchingRemovedItem?._doc?.adjstatus === 'Not Allotted') {
        return 'Not Allotted';
    }
    else if (matchingItem && matchingItem?._doc?.adjstatus === 'Approved') {
        if (matchingItem?._doc?.adjustmenttype === "Add On Shift" || matchingItem?._doc?.adjustmenttype === 'Shift Adjustment' || matchingItem?._doc?.adjustmenttype === 'Shift Weekoff Swap') {
            if (column.shiftMode === 'Main Shift') {
                return `${matchingItem?._doc?.adjchangeshiftime.split(' - ')[0]}to${matchingItem?._doc?.adjchangeshiftime.split(' - ')[1]}`
            } else if (column.shiftMode === 'Second Shift') {
                return `${matchingItem?._doc?.pluseshift.split(' - ')[0]}to${matchingItem?._doc?.pluseshift.split(' - ')[1]}`
            }
        }
        else {
            return (isWeekOffWithAdjustment ? (`${matchingItem?._doc?.adjchangeshiftime.split(' - ')[0]}to${matchingItem?._doc?.adjchangeshiftime.split(' - ')[1]}`) : (`${matchingItem?._doc?.adjchangeshiftime.split(' - ')[0]}to${matchingItem?._doc?.adjchangeshiftime.split(' - ')[1]}`));
        }
    }
    else if (matchingItemAllot && matchingItemAllot?._doc?.status === "Manual") {
        return isWeekOffWithManual ? (`${matchingItemAllot._doc?.firstshift.split(' - ')[0]}to${matchingItemAllot?._doc?.firstshift.split(' - ')[1]} `) :
            (`${matchingItemAllot?._doc?.firstshift.split(' - ')[0]}to${matchingItemAllot?._doc?.firstshift.split(' - ')[1]} `);
    }
    else if (matchingItemAllot && matchingItemAllot?._doc?.status === "Week Off") {
        return 'Week Off';
    }
    else if (matchingItem && matchingItem?._doc?.adjstatus === 'Reject' && isWeekOff) {
        // If the adjustment status is 'Reject' and it's a week off, return 'Week Off'
        return 'Week Off';
    }
    // before add shifttype condition working code
    // else if (boardingLog?.length > 0) {

    //     const [columnDay, columnMonth, columnYear] = column.formattedDate?.split('/');
    //     const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

    //     // Filter boardingLog entries for the same start date
    //     const entriesForDate = boardingLog.filter(log => log.startdate === finalDate);

    //     // If there are entries for the date, return the shift timing of the second entry
    //     if (entriesForDate.length > 1) {
    //         return entriesForDate[1].shifttiming;
    //     }

    //     // Find the most recent boarding log entry that is less than or equal to the selected date
    //     const recentLogEntry = boardingLog
    //         .filter(log => log.startdate < finalDate)
    //         .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

    //     // If a recent log entry is found, return its shift timing
    //     if (recentLogEntry) {
    //         return !isWeekOff ? recentLogEntry.shifttiming : "Week Off";
    //     } else {
    //         // If no relevant boarding log entry is found, return the previous shift timing or 'Week Off' if it's a week off
    //         return !isWeekOff ? actualShiftTiming : "Week Off";
    //     }
    // } 
    else if (boardingLog.length > 0) {
        // Remove duplicate entries with recent entry
        const uniqueEntries = {};
        boardingLog.forEach(entry => {
            const key = entry.startdate;
            if (!(key in uniqueEntries) || uniqueEntries[key].time <= entry.time) {
                uniqueEntries[key] = entry;
            }
        });
        const uniqueBoardingLog = Object.values(uniqueEntries);

        const [columnDay, columnMonth, columnYear] = column.formattedDate?.split('/');
        const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

        // Find the relevant log entry for the given date     
        const relevantLogEntry = uniqueBoardingLog
            .filter(log => log.startdate <= finalDate)
            .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

        const logWeekOff = relevantLogEntry && relevantLogEntry.weekoff.includes(column.dayName)

        if (relevantLogEntry) {

            // Daily
            if (relevantLogEntry.shifttype === 'Standard' || relevantLogEntry.shifttype === undefined) {
                // If shift type is 'Daily', return the same shift timing for each day
                //    return !isWeekOff ? relevantLogEntry.shifttiming : 'Week Off';
                return !logWeekOff ? relevantLogEntry.shifttiming : 'Week Off';
            }

            // 1 Week Rotation 2nd try working code
            if (relevantLogEntry.shifttype === 'Daily') {
                for (const data of relevantLogEntry.todo) {
                    const columnWeek = (column.weekNumberInMonth === '2nd Week' ? '1st Week' : column.weekNumberInMonth === '3rd Week' ? '1st Week' : column.weekNumberInMonth === '4th Week' ? '1st Week' : column.weekNumberInMonth === '5th Week' ? '1st Week' : '1st Week');
                    if (data.week === columnWeek && data.day === column.dayName) {
                        return data.shiftmode === 'Shift' ? data.shifttiming : 'Week Off';
                    }
                }
            }

            // 2 Week Rotation 2nd try working code  
            if (relevantLogEntry.shifttype === '1 Week Rotation') {
                const startDate = new Date(relevantLogEntry.startdate); // Get the start date

                // Get the day name of the start date
                const startDayName = startDate.toLocaleDateString('en-US', { weekday: 'long' });

                // Calculate the day count until the next Sunday
                let dayCount = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'].indexOf(startDayName);

                // Calculate the week number based on the day count
                let weekNumber = Math.ceil((7 - dayCount) / 7);

                // Adjust the week number considering the two-week rotation
                const logStartDate = new Date(relevantLogEntry.startdate);
                const currentDate = new Date(finalDate);

                const diffTime = Math.abs(currentDate - logStartDate);
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

                weekNumber += Math.floor((diffDays - (7 - dayCount)) / 7); // Adjust for complete 2-week cycles passed

                // Determine the final week based on the calculated week number                    
                const finalWeek = (weekNumber % 2 === 0) ? '1st Week' : '2nd Week';

                for (const data of relevantLogEntry.todo) {
                    // Check if the adjusted week matches the column week and day
                    if (data.week === finalWeek && data.day === column.dayName) {
                        return data.shiftmode === 'Shift' ? data.shifttiming : 'Week Off';
                    }
                }
            }

            //just 2wk rotation
            if (relevantLogEntry.shifttype === '2 Week Rotation') {

                const matchingDepartment = overAllDepartment.find(
                    (dep) =>
                        dep.department === department &&
                        new Date(dep.fromdate) <= new Date(relevantLogEntry.startdate) &&
                        new Date(relevantLogEntry.startdate) <= new Date(dep.todate)
                );

                // Use the fromdate of the matching department as the startDate
                let startDate = matchingDepartment
                    ? new Date(matchingDepartment.fromdate)
                    : new Date(relevantLogEntry.startdate);

                // Calculate month lengths
                const monthLengths = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

                // Function to determine if a year is a leap year
                const isLeapYear = (year) => {
                    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
                };

                const currentDate = new Date(finalDate);

                // Determine the effective month for the start date
                let effectiveMonth = startDate.getMonth();
                if (startDate.getDate() > 15) {
                    // Consider the next month if the start date is after the 15th
                    effectiveMonth = (effectiveMonth + 1) % 12;
                }

                // Calculate total days for 1-month rotation based on the effective month
                let totalDays = monthLengths[effectiveMonth];

                // Set the initial endDate by adding totalDays to the startDate
                let endDate = new Date(startDate);
                endDate.setDate(endDate.getDate() + totalDays - 1); // Subtract 1 to account for zero-indexing

                // Adjust February for leap years
                if (isLeapYear(endDate.getFullYear())) {
                    monthLengths[1] = 29;
                }

                // Adjust startDate and endDate if the currentDate is beyond the initial endDate
                while (currentDate > endDate) {
                    // Set startDate to the next matchingDepartment.fromdate for each cycle
                    startDate = new Date(endDate);
                    startDate.setDate(startDate.getDate() + 1); // Move to the next day

                    // Determine the new effective month for the next cycle
                    effectiveMonth = startDate.getMonth();
                    if (startDate.getDate() > 15) {
                        effectiveMonth = (effectiveMonth + 1) % 12;
                    }

                    totalDays = monthLengths[effectiveMonth];

                    // Set the new endDate by adding totalDays to the new startDate
                    endDate = new Date(startDate);
                    endDate.setDate(endDate.getDate() + totalDays - 1); // Include entire period

                    // Adjust February for leap years
                    if (isLeapYear(endDate.getFullYear())) {
                        monthLengths[1] = 29;
                    }
                }

                // Calculate the difference in days correctly
                const diffTime = Math.abs(currentDate.getTime() - startDate.getTime());
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1; // Add 1 to include start date

                // Determine the start day of the first week
                let startDayOfWeek = startDate.getDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday

                // Adjust the start day so that Monday is considered the start of the week
                let startDayOffset = startDayOfWeek === 0 ? 6 : startDayOfWeek - 1;

                // Calculate the week number based on Monday to Sunday cycle
                let adjustedDiffDays = diffDays + startDayOffset; // Adjust diffDays to account for start day                                      

                // Calculate the week number within the rotation month based on 7-day intervals from start date
                // const weekNumber = Math.ceil(diffDays / 7);
                let weekNumber = Math.floor((adjustedDiffDays - 1) / 7) + 1; // Divide by 7 to get the week count

                const weekNames = [
                    "1st Week",
                    "2nd Week",
                    "3rd Week",
                    "4th Week",
                    "5th Week",
                    "6th Week",
                    "7th Week",
                    "8th Week",
                    "9th Week",
                ];
                const finalWeek = weekNames[(weekNumber - 1) % weekNames.length];

                for (const data of relevantLogEntry.todo) {
                    if (data.week === finalWeek && data.day === column.dayName) {
                        return data.shiftmode === "Shift" ? data.shifttiming : "Week Off";
                    }
                }
            }

            //just 1mont rota updated          
            if (relevantLogEntry.shifttype === '1 Month Rotation') {

                const matchingDepartment = overAllDepartment.find(
                    (dep) =>
                        dep.department === department &&
                        new Date(dep.fromdate) <= new Date(relevantLogEntry.startdate) &&
                        new Date(relevantLogEntry.startdate) <= new Date(dep.todate)
                );

                // Use the fromdate of the matching department as the startDate
                let startDate = matchingDepartment
                    ? new Date(matchingDepartment.fromdate)
                    : new Date(relevantLogEntry.startdate);

                const currentDate = new Date(finalDate);

                // Function to determine if a year is a leap year
                const isLeapYear = (year) => {
                    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
                };

                // Calculate month lengths with leap year check for a given year
                const calculateMonthLengths = (year) => {
                    return [31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
                };

                // Determine the effective month and year for the start date
                let effectiveMonth = startDate.getMonth();
                let effectiveYear = startDate.getFullYear();
                if (startDate.getDate() > 15) {
                    // Consider the next month if the start date is after the 15th
                    effectiveMonth = (effectiveMonth + 1) % 12;
                    if (effectiveMonth === 0) {
                        effectiveYear += 1; // Move to the next year if month resets
                    }
                }

                // Calculate total days for the current two-month cycle
                let totalDays = 0;
                for (let i = 0; i < 2; i++) {
                    const monthIndex = (effectiveMonth + i) % 12;
                    const yearAdjustment = Math.floor((effectiveMonth + i) / 12);
                    const currentYear = effectiveYear + yearAdjustment;
                    const monthLengthsForYear = calculateMonthLengths(currentYear);
                    totalDays += monthLengthsForYear[monthIndex];
                }

                // Set the endDate by adding totalDays to the startDate
                let endDate = new Date(startDate);
                endDate.setDate(endDate.getDate() + totalDays - 1); // Include entire period

                // Recalculate if currentDate is beyond the initial endDate
                while (currentDate > endDate) {
                    startDate = new Date(endDate);
                    startDate.setDate(startDate.getDate() + 1); // Move to the next day

                    // Determine the new effective month and year for the next cycle
                    effectiveMonth = startDate.getMonth();
                    effectiveYear = startDate.getFullYear();
                    if (startDate.getDate() > 15) {
                        effectiveMonth = (effectiveMonth + 1) % 12;
                        if (effectiveMonth === 0) {
                            effectiveYear += 1;
                        }
                    }

                    totalDays = 0;
                    for (let i = 0; i < 2; i++) {
                        const monthIndex = (effectiveMonth + i) % 12;
                        const yearAdjustment = Math.floor((effectiveMonth + i) / 12);
                        const currentYear = effectiveYear + yearAdjustment;
                        const monthLengthsForYear = calculateMonthLengths(currentYear);
                        totalDays += monthLengthsForYear[monthIndex];
                    }

                    // Set the new endDate by adding totalDays to the new startDate
                    endDate = new Date(startDate);
                    endDate.setDate(endDate.getDate() + totalDays - 1); // Include entire period
                }

                // Calculate the difference in days including the start date
                const diffTime = Math.abs(currentDate.getTime() - startDate.getTime());
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1; // Add 1 to include the start date

                // Determine the start day of the first week
                let startDayOfWeek = startDate.getDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday

                // Adjust the start day so that Monday is considered the start of the week
                let startDayOffset = startDayOfWeek === 0 ? 6 : startDayOfWeek - 1;

                // Calculate the week number based on Monday to Sunday cycle
                let adjustedDiffDays = diffDays - 1 + startDayOffset; // Adjust diffDays to account for start day
                let weekNumber = Math.floor(adjustedDiffDays / 7) + 1; // Divide by 7 to get the week count

                // Define week names for first and second month of the cycle
                const weekNamesFirstMonth = [
                    "1st Week",
                    "2nd Week",
                    "3rd Week",
                    "4th Week",
                    "5th Week",
                    "6th Week"
                ];

                const weekNamesSecondMonth = [
                    "7th Week",
                    "8th Week",
                    "9th Week",
                    "10th Week",
                    "11th Week",
                    "12th Week"
                ];

                // Determine which month we are in
                const daysInFirstMonth = calculateMonthLengths(startDate.getFullYear())[effectiveMonth];
                let finalWeek;

                if (diffDays <= daysInFirstMonth) {
                    // We're in the first month of the cycle
                    weekNumber = (weekNumber - 1) % weekNamesFirstMonth.length + 1;
                    finalWeek = weekNamesFirstMonth[weekNumber - 1];
                } else {
                    // We're in the second month of the cycle
                    const secondMonthDay = diffDays - daysInFirstMonth;

                    // Calculate week number based on Monday-Sunday for the second month
                    const secondMonthStartDayOffset = new Date(startDate.getTime() + daysInFirstMonth * 24 * 60 * 60 * 1000).getDay();
                    const secondMonthStartOffset = secondMonthStartDayOffset === 0 ? 6 : secondMonthStartDayOffset - 1;
                    const secondMonthAdjustedDays = secondMonthDay - 1 + secondMonthStartOffset;
                    const secondMonthWeekNumber = Math.floor(secondMonthAdjustedDays / 7) + 1;

                    finalWeek = weekNamesSecondMonth[secondMonthWeekNumber - 1];
                }

                for (const data of relevantLogEntry.todo) {
                    if (data.week === finalWeek && data.day === column.dayName) {
                        return data.shiftmode === "Shift" ? data.shifttiming : "Week Off";
                    }
                }
            }
        }
    }

};

const getShiftForDate = (column, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, boardingLog, isWeekOff, matchingDoubleShiftItem, department, overAllDepartment, matchingRemovedItem, matchingAssignShiftItem) => {

    // const selectedDateIndex = createdUserDates.findIndex(dateObj => dateObj.formattedDate === column.formattedDate);

    // if (selectedDateIndex === -1) {
    //     return !isWeekOff ? actualShiftTiming : "Week Off";
    // }

    //if (matchingItem && matchingItem?._doc?.adjstatus === 'Adjustment') {
    //  return 'Pending...'
    //}
    //    else 
    if (matchingDoubleShiftItem && matchingDoubleShiftItem?._doc?.adjstatus === 'Approved' && matchingDoubleShiftItem && matchingDoubleShiftItem?._doc?.adjustmenttype === 'Shift Weekoff Swap') {
        return matchingDoubleShiftItem?._doc?.todateshiftmode;
    }
    else if (matchingDoubleShiftItem && matchingDoubleShiftItem?._doc?.adjstatus === 'Approved' && matchingDoubleShiftItem && matchingDoubleShiftItem?._doc?.adjustmenttype === 'WeekOff Adjustment') {
        return matchingDoubleShiftItem?._doc?.todateshiftmode;
    }
    else if (matchingDoubleShiftItem && matchingDoubleShiftItem?._doc?.adjstatus === 'Approved' && matchingDoubleShiftItem && matchingDoubleShiftItem?._doc?.adjustmenttype === 'Shift Adjustment') {
        if (matchingAssignShiftItem && matchingDoubleShiftItem?._doc?.todate === matchingAssignShiftItem?._doc?.adjdate) {
            return `${matchingDoubleShiftItem?._doc?.adjchangeshiftime.split(' - ')[0]}to${matchingDoubleShiftItem?._doc?.adjchangeshiftime.split(' - ')[1]}`;
        } else {
            return 'Not Allotted';
        }
    }
    else if (matchingRemovedItem && matchingRemovedItem?._doc?.adjstatus === 'Not Allotted') {
        return 'Not Allotted';
    }
    else if (matchingItem && matchingItem?._doc?.adjstatus === 'Approved') {

        if (matchingItem?._doc?.adjustmenttype === "Add On Shift" || matchingItem?._doc?.adjustmenttype === 'Shift Adjustment' || matchingItem?._doc?.adjustmenttype === 'Shift Weekoff Swap') {
            if (column.shiftMode === 'Main Shift') {
                return `${matchingItem?._doc?.adjchangeshiftime.split(' - ')[0]}to${matchingItem?._doc?.adjchangeshiftime.split(' - ')[1]}`
            } else if (column.shiftMode === 'Second Shift') {
                return `${matchingItem?._doc?.pluseshift.split(' - ')[0]}to${matchingItem?._doc?.pluseshift.split(' - ')[1]}`
            }
        }
        else {
            return (isWeekOffWithAdjustment ? (`${matchingItem?._doc?.adjchangeshiftime.split(' - ')[0]}to${matchingItem?._doc?.adjchangeshiftime.split(' - ')[1]}`) : (`${matchingItem?._doc?.adjchangeshiftime.split(' - ')[0]}to${matchingItem?._doc?.adjchangeshiftime.split(' - ')[1]}`));
        }
    }
    else if (matchingItemAllot && matchingItemAllot?._doc?.status === "Manual") {
        return isWeekOffWithManual ? (`${matchingItemAllot._doc?.firstshift.split(' - ')[0]}to${matchingItemAllot?._doc?.firstshift.split(' - ')[1]} `) :
            (`${matchingItemAllot?._doc?.firstshift.split(' - ')[0]}to${matchingItemAllot?._doc?.firstshift.split(' - ')[1]} `);
    }
    else if (matchingItemAllot && matchingItemAllot?._doc?.status === "Week Off") {
        return 'Week Off';
    }
    else if (matchingItem && matchingItem?._doc?.adjstatus === 'Reject' && isWeekOff) {
        // If the adjustment status is 'Reject' and it's a week off, return 'Week Off'
        return 'Week Off';
    }
    // before add shifttype condition working code
    // else if (boardingLog?.length > 0) {

    //     const [columnDay, columnMonth, columnYear] = column.formattedDate?.split('/');
    //     const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

    //     // Filter boardingLog entries for the same start date
    //     const entriesForDate = boardingLog.filter(log => log.startdate === finalDate);

    //     // If there are entries for the date, return the shift timing of the second entry
    //     if (entriesForDate.length > 1) {
    //         return entriesForDate[1].shifttiming;
    //     }

    //     // Find the most recent boarding log entry that is less than or equal to the selected date
    //     const recentLogEntry = boardingLog
    //         .filter(log => log.startdate < finalDate)
    //         .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

    //     // If a recent log entry is found, return its shift timing
    //     if (recentLogEntry) {
    //         return !isWeekOff ? recentLogEntry.shifttiming : "Week Off";
    //     } else {
    //         // If no relevant boarding log entry is found, return the previous shift timing or 'Week Off' if it's a week off
    //         return !isWeekOff ? actualShiftTiming : "Week Off";
    //     }
    // } 
    else if (boardingLog.length > 0) {
        // Remove duplicate entries with recent entry
        const uniqueEntries = {};
        boardingLog.forEach(entry => {
            const key = entry.startdate;
            if (!(key in uniqueEntries) || uniqueEntries[key].time <= entry.time) {
                uniqueEntries[key] = entry;
            }
        });
        const uniqueBoardingLog = Object.values(uniqueEntries);

        const [columnDay, columnMonth, columnYear] = column.formattedDate?.split('/');
        const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

        // Find the relevant log entry for the given date     
        const relevantLogEntry = uniqueBoardingLog
            .filter(log => log.startdate <= finalDate)
            .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

        const logWeekOff = relevantLogEntry && relevantLogEntry.weekoff.includes(column.dayName)

        if (relevantLogEntry) {

            // Daily
            if (relevantLogEntry.shifttype === 'Standard' || relevantLogEntry.shifttype === undefined) {
                // If shift type is 'Daily', return the same shift timing for each day
                //    return !isWeekOff ? relevantLogEntry.shifttiming : 'Week Off';
                return !logWeekOff ? relevantLogEntry.shifttiming : 'Week Off';
            }

            // 1 Week Rotation 2nd try working code
            if (relevantLogEntry.shifttype === 'Daily') {
                for (const data of relevantLogEntry.todo) {
                    const columnWeek = (column.weekNumberInMonth === '2nd Week' ? '1st Week' : column.weekNumberInMonth === '3rd Week' ? '1st Week' : column.weekNumberInMonth === '4th Week' ? '1st Week' : column.weekNumberInMonth === '5th Week' ? '1st Week' : '1st Week');
                    if (data.week === columnWeek && data.day === column.dayName) {
                        return data.shiftmode === 'Shift' ? data.shifttiming : 'Week Off';
                    }
                }
            }

            // 2 Week Rotation 2nd try working code  
            if (relevantLogEntry.shifttype === '1 Week Rotation') {
                const startDate = new Date(relevantLogEntry.startdate); // Get the start date

                // Get the day name of the start date
                const startDayName = startDate.toLocaleDateString('en-US', { weekday: 'long' });

                // Calculate the day count until the next Sunday
                let dayCount = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'].indexOf(startDayName);

                // Calculate the week number based on the day count
                let weekNumber = Math.ceil((7 - dayCount) / 7);

                // Adjust the week number considering the two-week rotation
                const logStartDate = new Date(relevantLogEntry.startdate);
                const currentDate = new Date(finalDate);

                const diffTime = Math.abs(currentDate - logStartDate);
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

                weekNumber += Math.floor((diffDays - (7 - dayCount)) / 7); // Adjust for complete 2-week cycles passed

                // Determine the final week based on the calculated week number                    
                const finalWeek = (weekNumber % 2 === 0) ? '1st Week' : '2nd Week';

                for (const data of relevantLogEntry.todo) {
                    // Check if the adjusted week matches the column week and day
                    if (data.week === finalWeek && data.day === column.dayName) {
                        return data.shiftmode === 'Shift' ? data.shifttiming : 'Week Off';
                    }
                }
            }

            //just 2wk rotation
            if (relevantLogEntry.shifttype === '2 Week Rotation') {

                const matchingDepartment = overAllDepartment.find(
                    (dep) =>
                        dep.department === department &&
                        new Date(dep.fromdate) <= new Date(relevantLogEntry.startdate) &&
                        new Date(relevantLogEntry.startdate) <= new Date(dep.todate)
                );

                // Use the fromdate of the matching department as the startDate
                let startDate = matchingDepartment
                    ? new Date(matchingDepartment.fromdate)
                    : new Date(relevantLogEntry.startdate);

                // Calculate month lengths
                const monthLengths = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

                // Function to determine if a year is a leap year
                const isLeapYear = (year) => {
                    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
                };

                const currentDate = new Date(finalDate);

                // Determine the effective month for the start date
                let effectiveMonth = startDate.getMonth();
                if (startDate.getDate() > 15) {
                    // Consider the next month if the start date is after the 15th
                    effectiveMonth = (effectiveMonth + 1) % 12;
                }

                // Calculate total days for 1-month rotation based on the effective month
                let totalDays = monthLengths[effectiveMonth];

                // Set the initial endDate by adding totalDays to the startDate
                let endDate = new Date(startDate);
                endDate.setDate(endDate.getDate() + totalDays - 1); // Subtract 1 to account for zero-indexing

                // Adjust February for leap years
                if (isLeapYear(endDate.getFullYear())) {
                    monthLengths[1] = 29;
                }

                // Adjust startDate and endDate if the currentDate is beyond the initial endDate
                while (currentDate > endDate) {
                    // Set startDate to the next matchingDepartment.fromdate for each cycle
                    startDate = new Date(endDate);
                    startDate.setDate(startDate.getDate() + 1); // Move to the next day

                    // Determine the new effective month for the next cycle
                    effectiveMonth = startDate.getMonth();
                    if (startDate.getDate() > 15) {
                        effectiveMonth = (effectiveMonth + 1) % 12;
                    }

                    totalDays = monthLengths[effectiveMonth];

                    // Set the new endDate by adding totalDays to the new startDate
                    endDate = new Date(startDate);
                    endDate.setDate(endDate.getDate() + totalDays - 1); // Include entire period

                    // Adjust February for leap years
                    if (isLeapYear(endDate.getFullYear())) {
                        monthLengths[1] = 29;
                    }
                }

                // Calculate the difference in days correctly
                const diffTime = Math.abs(currentDate.getTime() - startDate.getTime());
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1; // Add 1 to include start date

                // Determine the start day of the first week
                let startDayOfWeek = startDate.getDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday

                // Adjust the start day so that Monday is considered the start of the week
                let startDayOffset = startDayOfWeek === 0 ? 6 : startDayOfWeek - 1;

                // Calculate the week number based on Monday to Sunday cycle
                let adjustedDiffDays = diffDays + startDayOffset; // Adjust diffDays to account for start day                                      

                // Calculate the week number within the rotation month based on 7-day intervals from start date
                // const weekNumber = Math.ceil(diffDays / 7);
                let weekNumber = Math.floor((adjustedDiffDays - 1) / 7) + 1; // Divide by 7 to get the week count

                const weekNames = [
                    "1st Week",
                    "2nd Week",
                    "3rd Week",
                    "4th Week",
                    "5th Week",
                    "6th Week",
                    "7th Week",
                    "8th Week",
                    "9th Week",
                ];
                const finalWeek = weekNames[(weekNumber - 1) % weekNames.length];

                for (const data of relevantLogEntry.todo) {
                    if (data.week === finalWeek && data.day === column.dayName) {
                        return data.shiftmode === "Shift" ? data.shifttiming : "Week Off";
                    }
                }
            }

            //just 1mont rota updated          
            if (relevantLogEntry.shifttype === '1 Month Rotation') {

                const matchingDepartment = overAllDepartment.find(
                    (dep) =>
                        dep.department === department &&
                        new Date(dep.fromdate) <= new Date(relevantLogEntry.startdate) &&
                        new Date(relevantLogEntry.startdate) <= new Date(dep.todate)
                );

                // Use the fromdate of the matching department as the startDate
                let startDate = matchingDepartment
                    ? new Date(matchingDepartment.fromdate)
                    : new Date(relevantLogEntry.startdate);

                const currentDate = new Date(finalDate);

                // Function to determine if a year is a leap year
                const isLeapYear = (year) => {
                    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
                };

                // Calculate month lengths with leap year check for a given year
                const calculateMonthLengths = (year) => {
                    return [31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
                };

                // Determine the effective month and year for the start date
                let effectiveMonth = startDate.getMonth();
                let effectiveYear = startDate.getFullYear();
                if (startDate.getDate() > 15) {
                    // Consider the next month if the start date is after the 15th
                    effectiveMonth = (effectiveMonth + 1) % 12;
                    if (effectiveMonth === 0) {
                        effectiveYear += 1; // Move to the next year if month resets
                    }
                }

                // Calculate total days for the current two-month cycle
                let totalDays = 0;
                for (let i = 0; i < 2; i++) {
                    const monthIndex = (effectiveMonth + i) % 12;
                    const yearAdjustment = Math.floor((effectiveMonth + i) / 12);
                    const currentYear = effectiveYear + yearAdjustment;
                    const monthLengthsForYear = calculateMonthLengths(currentYear);
                    totalDays += monthLengthsForYear[monthIndex];
                }

                // Set the endDate by adding totalDays to the startDate
                let endDate = new Date(startDate);
                endDate.setDate(endDate.getDate() + totalDays - 1); // Include entire period

                // Recalculate if currentDate is beyond the initial endDate
                while (currentDate > endDate) {
                    startDate = new Date(endDate);
                    startDate.setDate(startDate.getDate() + 1); // Move to the next day

                    // Determine the new effective month and year for the next cycle
                    effectiveMonth = startDate.getMonth();
                    effectiveYear = startDate.getFullYear();
                    if (startDate.getDate() > 15) {
                        effectiveMonth = (effectiveMonth + 1) % 12;
                        if (effectiveMonth === 0) {
                            effectiveYear += 1;
                        }
                    }

                    totalDays = 0;
                    for (let i = 0; i < 2; i++) {
                        const monthIndex = (effectiveMonth + i) % 12;
                        const yearAdjustment = Math.floor((effectiveMonth + i) / 12);
                        const currentYear = effectiveYear + yearAdjustment;
                        const monthLengthsForYear = calculateMonthLengths(currentYear);
                        totalDays += monthLengthsForYear[monthIndex];
                    }

                    // Set the new endDate by adding totalDays to the new startDate
                    endDate = new Date(startDate);
                    endDate.setDate(endDate.getDate() + totalDays - 1); // Include entire period
                }

                // Calculate the difference in days including the start date
                const diffTime = Math.abs(currentDate.getTime() - startDate.getTime());
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1; // Add 1 to include the start date

                // Determine the start day of the first week
                let startDayOfWeek = startDate.getDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday

                // Adjust the start day so that Monday is considered the start of the week
                let startDayOffset = startDayOfWeek === 0 ? 6 : startDayOfWeek - 1;

                // Calculate the week number based on Monday to Sunday cycle
                let adjustedDiffDays = diffDays - 1 + startDayOffset; // Adjust diffDays to account for start day
                let weekNumber = Math.floor(adjustedDiffDays / 7) + 1; // Divide by 7 to get the week count

                // Define week names for first and second month of the cycle
                const weekNamesFirstMonth = [
                    "1st Week",
                    "2nd Week",
                    "3rd Week",
                    "4th Week",
                    "5th Week",
                    "6th Week"
                ];

                const weekNamesSecondMonth = [
                    "7th Week",
                    "8th Week",
                    "9th Week",
                    "10th Week",
                    "11th Week",
                    "12th Week"
                ];

                // Determine which month we are in
                const daysInFirstMonth = calculateMonthLengths(startDate.getFullYear())[effectiveMonth];
                let finalWeek;

                if (diffDays <= daysInFirstMonth) {
                    // We're in the first month of the cycle
                    weekNumber = (weekNumber - 1) % weekNamesFirstMonth.length + 1;
                    finalWeek = weekNamesFirstMonth[weekNumber - 1];
                } else {
                    // We're in the second month of the cycle
                    const secondMonthDay = diffDays - daysInFirstMonth;

                    // Calculate week number based on Monday-Sunday for the second month
                    const secondMonthStartDayOffset = new Date(startDate.getTime() + daysInFirstMonth * 24 * 60 * 60 * 1000).getDay();
                    const secondMonthStartOffset = secondMonthStartDayOffset === 0 ? 6 : secondMonthStartDayOffset - 1;
                    const secondMonthAdjustedDays = secondMonthDay - 1 + secondMonthStartOffset;
                    const secondMonthWeekNumber = Math.floor(secondMonthAdjustedDays / 7) + 1;

                    finalWeek = weekNamesSecondMonth[secondMonthWeekNumber - 1];
                }

                for (const data of relevantLogEntry.todo) {
                    if (data.week === finalWeek && data.day === column.dayName) {
                        return data.shiftmode === "Shift" ? data.shifttiming : "Week Off";
                    }
                }
            }
        }
    }

};

const getShiftForDateProdDayShift = (column, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, boardingLog, isWeekOff, matchingDoubleShiftItem, department, overAllDepartment) => {

    // const selectedDateIndex = createdUserDates.findIndex(dateObj => dateObj.formattedDate === column.formattedDate);

    // if (selectedDateIndex === -1) {
    //     return !isWeekOff ? actualShiftTiming : "Week Off";
    // }

    // if (matchingItem && matchingItem?._doc?.adjstatus === 'Adjustment') {
    //     return 'Pending...'
    // }
    // else
    if (matchingDoubleShiftItem && matchingDoubleShiftItem?._doc?.adjstatus === 'Approved' && matchingDoubleShiftItem && matchingDoubleShiftItem?._doc?.adjustmenttype === 'Shift Weekoff Swap') {
        return matchingDoubleShiftItem?._doc?.todateshiftmode;
    }
    else if (matchingDoubleShiftItem && matchingDoubleShiftItem?._doc?.adjstatus === 'Approved' && matchingDoubleShiftItem && matchingDoubleShiftItem?._doc?.adjustmenttype === 'WeekOff Adjustment') {
        return matchingDoubleShiftItem?._doc?.todateshiftmode;
    }
    else if (matchingItem && matchingItem?._doc?.adjstatus === 'Approved') {

        if (matchingItem?._doc?.adjustmenttype === "Add On Shift" || matchingItem?._doc?.adjustmenttype === 'Shift Adjustment' || matchingItem?._doc?.adjustmenttype === 'Shift Weekoff Swap') {
            if (column.shiftMode === 'Main Shift') {
                return `${matchingItem?._doc?.adjchangeshiftime.split(' - ')[0]}to${matchingItem?._doc?.adjchangeshiftime.split(' - ')[1]}`
            } else if (column.shiftMode === 'Second Shift') {
                return `${matchingItem?._doc?.pluseshift.split(' - ')[0]}to${matchingItem?._doc?.pluseshift.split(' - ')[1]}`
            }
        }
        else {
            return (isWeekOffWithAdjustment ? (`${matchingItem?._doc?.adjchangeshiftime.split(' - ')[0]}to${matchingItem?._doc?.adjchangeshiftime.split(' - ')[1]}`) : (`${matchingItem?._doc?.adjchangeshiftime.split(' - ')[0]}to${matchingItem?._doc?.adjchangeshiftime.split(' - ')[1]}`));
        }
    }
    else if (matchingItemAllot && matchingItemAllot?._doc?.status === "Manual") {
        return isWeekOffWithManual ? (`${matchingItemAllot._doc?.firstshift.split(' - ')[0]}to${matchingItemAllot?._doc?.firstshift.split(' - ')[1]} `) :
            (`${matchingItemAllot?._doc?.firstshift.split(' - ')[0]}to${matchingItemAllot?._doc?.firstshift.split(' - ')[1]} `);
    }
    else if (matchingItemAllot && matchingItemAllot?._doc?.status === "Week Off") {
        return 'Week Off';
    }
    else if (matchingItem && matchingItem?._doc?.adjstatus === 'Reject' && isWeekOff) {
        // If the adjustment status is 'Reject' and it's a week off, return 'Week Off'
        return 'Week Off';
    }
    // before add shifttype condition working code
    // else if (boardingLog?.length > 0) {

    //     const [columnDay, columnMonth, columnYear] = column.formattedDate?.split('/');
    //     const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

    //     // Filter boardingLog entries for the same start date
    //     const entriesForDate = boardingLog.filter(log => log.startdate === finalDate);

    //     // If there are entries for the date, return the shift timing of the second entry
    //     if (entriesForDate.length > 1) {
    //         return entriesForDate[1].shifttiming;
    //     }

    //     // Find the most recent boarding log entry that is less than or equal to the selected date
    //     const recentLogEntry = boardingLog
    //         .filter(log => log.startdate < finalDate)
    //         .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

    //     // If a recent log entry is found, return its shift timing
    //     if (recentLogEntry) {
    //         return !isWeekOff ? recentLogEntry.shifttiming : "Week Off";
    //     } else {
    //         // If no relevant boarding log entry is found, return the previous shift timing or 'Week Off' if it's a week off
    //         return !isWeekOff ? actualShiftTiming : "Week Off";
    //     }
    // } 
    else if (boardingLog.length > 0) {
        // Remove duplicate entries with recent entry
        const uniqueEntries = {};
        boardingLog.forEach(entry => {
            const key = entry.startdate;
            if (!(key in uniqueEntries) || uniqueEntries[key].time <= entry.time) {
                uniqueEntries[key] = entry;
            }
        });
        const uniqueBoardingLog = Object.values(uniqueEntries);

        const [columnDay, columnMonth, columnYear] = column.formattedDate?.split('/');
        const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

        // Find the relevant log entry for the given date     
        const relevantLogEntry = uniqueBoardingLog
            .filter(log => log.startdate <= finalDate)
            .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

        const logWeekOff = relevantLogEntry && relevantLogEntry.weekoff.includes(column.dayName)

        if (relevantLogEntry) {

            // Daily
            if (relevantLogEntry.shifttype === 'Standard' || relevantLogEntry.shifttype === undefined) {
                // If shift type is 'Daily', return the same shift timing for each day
                //    return !isWeekOff ? relevantLogEntry.shifttiming : 'Week Off';
                return !logWeekOff ? relevantLogEntry.shifttiming : 'Week Off';
            }

            // 1 Week Rotation 2nd try working code
            if (relevantLogEntry.shifttype === 'Daily') {
                for (const data of relevantLogEntry.todo) {
                    const columnWeek = (column.weekNumberInMonth === '2nd Week' ? '1st Week' : column.weekNumberInMonth === '3rd Week' ? '1st Week' : column.weekNumberInMonth === '4th Week' ? '1st Week' : column.weekNumberInMonth === '5th Week' ? '1st Week' : '1st Week');
                    if (data.week === columnWeek && data.day === column.dayName) {
                        return data.shiftmode === 'Shift' ? data.shifttiming : 'Week Off';
                    }
                }
            }

            // 2 Week Rotation 2nd try working code  
            if (relevantLogEntry.shifttype === '1 Week Rotation') {
                const startDate = new Date(relevantLogEntry.startdate); // Get the start date

                // Get the day name of the start date
                const startDayName = startDate.toLocaleDateString('en-US', { weekday: 'long' });

                // Calculate the day count until the next Sunday
                let dayCount = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'].indexOf(startDayName);

                // Calculate the week number based on the day count
                let weekNumber = Math.ceil((7 - dayCount) / 7);

                // Adjust the week number considering the two-week rotation
                const logStartDate = new Date(relevantLogEntry.startdate);
                const currentDate = new Date(finalDate);

                const diffTime = Math.abs(currentDate - logStartDate);
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

                weekNumber += Math.floor((diffDays - (7 - dayCount)) / 7); // Adjust for complete 2-week cycles passed

                // Determine the final week based on the calculated week number                    
                const finalWeek = (weekNumber % 2 === 0) ? '1st Week' : '2nd Week';

                for (const data of relevantLogEntry.todo) {
                    // Check if the adjusted week matches the column week and day
                    if (data.week === finalWeek && data.day === column.dayName) {
                        return data.shiftmode === 'Shift' ? data.shifttiming : 'Week Off';
                    }
                }
            }

            //just 2wk rotation
            if (relevantLogEntry.shifttype === '2 Week Rotation') {

                const matchingDepartment = overAllDepartment.find(
                    (dep) =>
                        dep.department === department &&
                        new Date(dep.fromdate) <= new Date(relevantLogEntry.startdate) &&
                        new Date(relevantLogEntry.startdate) <= new Date(dep.todate)
                );

                // Use the fromdate of the matching department as the startDate
                let startDate = matchingDepartment
                    ? new Date(matchingDepartment.fromdate)
                    : new Date(relevantLogEntry.startdate);

                // Calculate month lengths
                const monthLengths = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

                // Function to determine if a year is a leap year
                const isLeapYear = (year) => {
                    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
                };

                const currentDate = new Date(finalDate);

                // Determine the effective month for the start date
                let effectiveMonth = startDate.getMonth();
                if (startDate.getDate() > 15) {
                    // Consider the next month if the start date is after the 15th
                    effectiveMonth = (effectiveMonth + 1) % 12;
                }

                // Calculate total days for 1-month rotation based on the effective month
                let totalDays = monthLengths[effectiveMonth];

                // Set the initial endDate by adding totalDays to the startDate
                let endDate = new Date(startDate);
                endDate.setDate(endDate.getDate() + totalDays - 1); // Subtract 1 to account for zero-indexing

                // Adjust February for leap years
                if (isLeapYear(endDate.getFullYear())) {
                    monthLengths[1] = 29;
                }

                // Adjust startDate and endDate if the currentDate is beyond the initial endDate
                while (currentDate > endDate) {
                    // Set startDate to the next matchingDepartment.fromdate for each cycle
                    startDate = new Date(endDate);
                    startDate.setDate(startDate.getDate() + 1); // Move to the next day

                    // Determine the new effective month for the next cycle
                    effectiveMonth = startDate.getMonth();
                    if (startDate.getDate() > 15) {
                        effectiveMonth = (effectiveMonth + 1) % 12;
                    }

                    totalDays = monthLengths[effectiveMonth];

                    // Set the new endDate by adding totalDays to the new startDate
                    endDate = new Date(startDate);
                    endDate.setDate(endDate.getDate() + totalDays - 1); // Include entire period

                    // Adjust February for leap years
                    if (isLeapYear(endDate.getFullYear())) {
                        monthLengths[1] = 29;
                    }
                }

                // Calculate the difference in days correctly
                const diffTime = Math.abs(currentDate.getTime() - startDate.getTime());
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1; // Add 1 to include start date

                // Determine the start day of the first week
                let startDayOfWeek = startDate.getDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday

                // Adjust the start day so that Monday is considered the start of the week
                let startDayOffset = startDayOfWeek === 0 ? 6 : startDayOfWeek - 1;

                // Calculate the week number based on Monday to Sunday cycle
                let adjustedDiffDays = diffDays + startDayOffset; // Adjust diffDays to account for start day                                      

                // Calculate the week number within the rotation month based on 7-day intervals from start date
                // const weekNumber = Math.ceil(diffDays / 7);
                let weekNumber = Math.floor((adjustedDiffDays - 1) / 7) + 1; // Divide by 7 to get the week count

                const weekNames = [
                    "1st Week",
                    "2nd Week",
                    "3rd Week",
                    "4th Week",
                    "5th Week",
                    "6th Week",
                    "7th Week",
                    "8th Week",
                    "9th Week",
                ];
                const finalWeek = weekNames[(weekNumber - 1) % weekNames.length];

                for (const data of relevantLogEntry.todo) {
                    if (data.week === finalWeek && data.day === column.dayName) {
                        return data.shiftmode === "Shift" ? data.shifttiming : "Week Off";
                    }
                }
            }

            //just 1mont rota updated          
            if (relevantLogEntry.shifttype === '1 Month Rotation') {

                const matchingDepartment = overAllDepartment.find(
                    (dep) =>
                        dep.department === department &&
                        new Date(dep.fromdate) <= new Date(relevantLogEntry.startdate) &&
                        new Date(relevantLogEntry.startdate) <= new Date(dep.todate)
                );

                // Use the fromdate of the matching department as the startDate
                let startDate = matchingDepartment
                    ? new Date(matchingDepartment.fromdate)
                    : new Date(relevantLogEntry.startdate);

                const currentDate = new Date(finalDate);

                // Function to determine if a year is a leap year
                const isLeapYear = (year) => {
                    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
                };

                // Calculate month lengths with leap year check for a given year
                const calculateMonthLengths = (year) => {
                    return [31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
                };

                // Determine the effective month and year for the start date
                let effectiveMonth = startDate.getMonth();
                let effectiveYear = startDate.getFullYear();
                if (startDate.getDate() > 15) {
                    // Consider the next month if the start date is after the 15th
                    effectiveMonth = (effectiveMonth + 1) % 12;
                    if (effectiveMonth === 0) {
                        effectiveYear += 1; // Move to the next year if month resets
                    }
                }

                // Calculate total days for the current two-month cycle
                let totalDays = 0;
                for (let i = 0; i < 2; i++) {
                    const monthIndex = (effectiveMonth + i) % 12;
                    const yearAdjustment = Math.floor((effectiveMonth + i) / 12);
                    const currentYear = effectiveYear + yearAdjustment;
                    const monthLengthsForYear = calculateMonthLengths(currentYear);
                    totalDays += monthLengthsForYear[monthIndex];
                }

                // Set the endDate by adding totalDays to the startDate
                let endDate = new Date(startDate);
                endDate.setDate(endDate.getDate() + totalDays - 1); // Include entire period

                // Recalculate if currentDate is beyond the initial endDate
                while (currentDate > endDate) {
                    startDate = new Date(endDate);
                    startDate.setDate(startDate.getDate() + 1); // Move to the next day

                    // Determine the new effective month and year for the next cycle
                    effectiveMonth = startDate.getMonth();
                    effectiveYear = startDate.getFullYear();
                    if (startDate.getDate() > 15) {
                        effectiveMonth = (effectiveMonth + 1) % 12;
                        if (effectiveMonth === 0) {
                            effectiveYear += 1;
                        }
                    }

                    totalDays = 0;
                    for (let i = 0; i < 2; i++) {
                        const monthIndex = (effectiveMonth + i) % 12;
                        const yearAdjustment = Math.floor((effectiveMonth + i) / 12);
                        const currentYear = effectiveYear + yearAdjustment;
                        const monthLengthsForYear = calculateMonthLengths(currentYear);
                        totalDays += monthLengthsForYear[monthIndex];
                    }

                    // Set the new endDate by adding totalDays to the new startDate
                    endDate = new Date(startDate);
                    endDate.setDate(endDate.getDate() + totalDays - 1); // Include entire period
                }

                // Calculate the difference in days including the start date
                const diffTime = Math.abs(currentDate.getTime() - startDate.getTime());
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1; // Add 1 to include the start date

                // Determine the start day of the first week
                let startDayOfWeek = startDate.getDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday

                // Adjust the start day so that Monday is considered the start of the week
                let startDayOffset = startDayOfWeek === 0 ? 6 : startDayOfWeek - 1;

                // Calculate the week number based on Monday to Sunday cycle
                let adjustedDiffDays = diffDays - 1 + startDayOffset; // Adjust diffDays to account for start day
                let weekNumber = Math.floor(adjustedDiffDays / 7) + 1; // Divide by 7 to get the week count

                // Define week names for first and second month of the cycle
                const weekNamesFirstMonth = [
                    "1st Week",
                    "2nd Week",
                    "3rd Week",
                    "4th Week",
                    "5th Week",
                    "6th Week"
                ];

                const weekNamesSecondMonth = [
                    "7th Week",
                    "8th Week",
                    "9th Week",
                    "10th Week",
                    "11th Week",
                    "12th Week"
                ];

                // Determine which month we are in
                const daysInFirstMonth = calculateMonthLengths(startDate.getFullYear())[effectiveMonth];
                let finalWeek;

                if (diffDays <= daysInFirstMonth) {
                    // We're in the first month of the cycle
                    weekNumber = (weekNumber - 1) % weekNamesFirstMonth.length + 1;
                    finalWeek = weekNamesFirstMonth[weekNumber - 1];
                } else {
                    // We're in the second month of the cycle
                    const secondMonthDay = diffDays - daysInFirstMonth;

                    // Calculate week number based on Monday-Sunday for the second month
                    const secondMonthStartDayOffset = new Date(startDate.getTime() + daysInFirstMonth * 24 * 60 * 60 * 1000).getDay();
                    const secondMonthStartOffset = secondMonthStartDayOffset === 0 ? 6 : secondMonthStartDayOffset - 1;
                    const secondMonthAdjustedDays = secondMonthDay - 1 + secondMonthStartOffset;
                    const secondMonthWeekNumber = Math.floor(secondMonthAdjustedDays / 7) + 1;

                    finalWeek = weekNamesSecondMonth[secondMonthWeekNumber - 1];
                }

                for (const data of relevantLogEntry.todo) {
                    if (data.week === finalWeek && data.day === column.dayName) {
                        return data.shiftmode === "Shift" ? data.shifttiming : "Week Off";
                    }
                }
            }
        }
    }

};

const getTotalMonthDaysUser = (rowdepartment, depMonthSet, ismonth, isyear) => {
    const monthNames = ["January", "February", "March", "April", "May", "June",
        "July", "August", "September", "October", "November", "December"
    ];

    const totalDaysInMonth = new Date(isyear, ismonth, 0).getDate();

    // const depdays = depMonthSet && depMonthSet?.find((d) => d.department === rowdepartment && Number(d.month) === ismonth && Number(d.year) === isyear);
    const depdays = depMonthSet && depMonthSet?.find((d) => d.department === rowdepartment && d.monthname === monthNames[ismonth - 1] && Number(d.year) === isyear);

    if (depdays) {
        return depdays.totaldays;
    }

    return totalDaysInMonth;
};

// get total working days from dep month set
const getTotalMonthDaysForEmpUser = (rowdoj, rowdepartment, depMonthSet, ismonth, isyear) => {
    const monthNames = ["January", "February", "March", "April", "May", "June",
        "July", "August", "September", "October", "November", "December"
    ];

    if (!rowdoj) {
        return "";
    }

    const [year, month, day] = rowdoj.split('-').map(Number);
    const joiningDate = new Date(year, month - 1, day);

    let totalDays = 0;

    // const depdays = depMonthSet && depMonthSet?.filter((d) => d.department === rowdepartment && Number(d.month) === ismonth && Number(d.year) === isyear);
    const depdays = depMonthSet && depMonthSet?.filter((d) => d.department === rowdepartment && d.monthname === monthNames[ismonth - 1] && Number(d.year) === isyear);

    if (depdays && depdays.length > 0) {
        depdays.forEach((dep) => {
            const fromDate = new Date(dep.fromdate);
            const toDate = new Date(dep.todate);
            if (joiningDate < fromDate) {
                // If the joining date is before the department's fromdate
                // const daysToFromdate = Math.ceil((fromDate - joiningDate) / (1000 * 60 * 60 * 24)) + 1; // Add 1 to include the starting day
                // const daysInDepartment = Math.ceil((toDate - fromDate) / (1000 * 60 * 60 * 24)) + 1; // Add 1 to include the ending day
                // totalDays += Math.min(daysToFromdate, daysInDepartment);
                const daysInDepartment = Math.ceil((toDate - fromDate) / (1000 * 60 * 60 * 24)); // Add 1 to include the ending day
                totalDays += daysInDepartment + (dep.todate === rowdoj ? 0 : 1);

            } else {
                // If the joining date is after the department's fromdate
                // totalDays += Math.ceil((toDate - joiningDate) / (1000 * 60 * 60 * 24)); // Add 1 to include the ending day
                const daysInDepartment = Math.ceil((toDate - joiningDate) / (1000 * 60 * 60 * 24)); // Add 1 to include the ending day
                totalDays += daysInDepartment + (dep.todate === rowdoj ? 0 : 0);
            }
        });
    } else {
        // Logic to handle when no department data is found for the current month
        // Calculate total days based on the current month's start and end dates
        const startDateOfMonth = new Date(isyear, ismonth - 1, 1);
        const endDateOfMonth = new Date(isyear, ismonth, 0);
        if (joiningDate < startDateOfMonth) {
            // If the joining date is before the department's fromdate
            // const daysToFromdate = Math.ceil((startDateOfMonth - joiningDate) / (1000 * 60 * 60 * 24)) + 1; // Add 1 to include the starting day
            // const daysInDepartment = Math.ceil((endDateOfMonth - startDateOfMonth) / (1000 * 60 * 60 * 24)) + 1; // Add 1 to include the ending day
            // totalDays += Math.min(daysToFromdate, daysInDepartment);
            const daysInDepartment = Math.ceil((endDateOfMonth - startDateOfMonth) / (1000 * 60 * 60 * 24)); // Add 1 to include the ending day
            totalDays += daysInDepartment + (endDateOfMonth === joiningDate ? 0 : 1);
        }
        else {
            // totalDays += Math.ceil((endDateOfMonth - startDateOfMonth) / (1000 * 60 * 60 * 24)) + 1; // Add 1 to include the ending day
            const daysInDepartment = Math.ceil((endDateOfMonth - joiningDate) / (1000 * 60 * 60 * 24)); // Add 1 to include the ending day
            totalDays += daysInDepartment + (endDateOfMonth === joiningDate ? 0 : 1);
        }
    }

    return Math.max(0, totalDays); // Ensure totalDays is not negative
};

// get till date count based on the dep month and joining date till current date of enddate
const getTotalMonthsCurrentDateCountUser = (rowdoj, rowdepartment, depMonthSet, ismonth, isyear) => {
    if (!rowdoj) {
        return "";
    }

    const [year, month, day] = rowdoj?.split('-').map(Number);
    const joiningDate = new Date(year, month - 1, day);
    const currentDate = new Date(isyear, ismonth - 1);

    let totalDays = 0;
    const monthNames = ["January", "February", "March", "April", "May", "June",
        "July", "August", "September", "October", "November", "December"
    ];

    // const depdays = depMonthSet?.filter((d) => d.department === rowdepartment && Number(d.month) === ismonth && Number(d.year) === isyear);

    const depdays = depMonthSet?.filter((d) => d.department === rowdepartment && d.monthname === monthNames[ismonth - 1] && Number(d.year) === isyear);

    if (depdays && depdays.length > 0) {
        depdays.forEach((dep) => {

            const fromDate = new Date(dep.fromdate);
            const toDate = new Date(dep.todate);

            // Adjust the time to midnight for joiningDate and toDate
            joiningDate.setHours(0, 0, 0, 0);
            toDate.setHours(0, 0, 0, 0);
            fromDate.setHours(0, 0, 0, 0);

            if (joiningDate < fromDate) {
                if (toDate >= currentDateAttStatus) {
                    // If the joining date is before the department's fromdate
                    const daysInDepartment = Math.ceil((currentDateAttStatus - fromDate) / (1000 * 60 * 60 * 24)); // Add 1 to include the ending day
                    totalDays += daysInDepartment;

                } else if (toDate <= currentDateAttStatus) {
                    // If the joining date is before the department's fromdate
                    const daysInDepartment = Math.ceil((toDate - fromDate) / (1000 * 60 * 60 * 24)); // Add 1 to include the ending day
                    totalDays += daysInDepartment + 1;
                }
            }
            else {
                if (toDate >= currentDateAttStatus) {
                    // If the joining date is after or on the department's fromdate and toDate is greater than or equal to currentDate
                    const daysInDepartment = Math.ceil((currentDateAttStatus - joiningDate) / (1000 * 60 * 60 * 24)); // Add 1 to include the ending day
                    totalDays += daysInDepartment;
                } else if (toDate <= currentDateAttStatus) {
                    // If the joining date is after or on the department's fromdate and toDate is less than or equal to currentDate
                    const daysInDepartment = Math.ceil((toDate - joiningDate) / (1000 * 60 * 60 * 24)); // Add 1 to include the ending day
                    totalDays += daysInDepartment + (toDate === joiningDate ? 0 : 1);
                }
            }
        });
    } else {
        // Calculate the start date of the month based on the selected month
        const monthfromDate = new Date(isyear, ismonth - 1, 1);
        const monthEndDate = new Date(monthfromDate);
        monthEndDate.setMonth(monthEndDate.getMonth() + 1);
        monthEndDate.setDate(monthEndDate.getDate() - 1);

        if (joiningDate < monthfromDate) {
            if (monthEndDate >= currentDateAttStatus) {
                // If the joining date is before the department's fromdate
                const daysInDepartment = Math.ceil((currentDateAttStatus - monthfromDate) / (1000 * 60 * 60 * 24)); // Add 1 to include the ending day
                totalDays += daysInDepartment;
            } else if (monthEndDate <= currentDateAttStatus) {
                // If the joining date is before the department's fromdate
                const daysInDepartment = Math.ceil((monthEndDate - monthfromDate) / (1000 * 60 * 60 * 24)) + 1; // Add 1 to include the ending day
                totalDays += daysInDepartment;
            }
        } else {
            if (monthEndDate >= currentDateAttStatus) {
                // If the joining date is after or on the department's fromdate and toDate is greater than or equal to currentDate
                const daysInDepartment = Math.ceil((currentDateAttStatus - joiningDate) / (1000 * 60 * 60 * 24)); // Add 1 to include the ending day
                totalDays += daysInDepartment;
            } else if (monthEndDate <= currentDateAttStatus) {
                // If the joining date is after or on the department's fromdate and toDate is less than or equal to currentDate
                const daysInDepartment = Math.ceil((monthEndDate - joiningDate) / (1000 * 60 * 60 * 24)); // Add 1 to include the ending day
                totalDays += daysInDepartment;
            }
        }
    }

    // Check if totalDays is negative and return 0 in that case
    return totalDays < 0 ? 0 : totalDays;
};

const getTotalShiftHoursUser = (rowuserid, userDates, attendance) => {
    let totalShiftCount = 0;

    const totalShiftDays = attendance?.filter((d) => d.userid === rowuserid && d.status === true);
    if (totalShiftDays) {
        // Maintain a set to keep track of unique dates
        const countedDates = new Set();

        userDates && userDates?.forEach((date) => {
            totalShiftDays.find((att) => {
                if (att.date === moment(date.formattedDate, "DD/MM/YYYY").format("DD-MM-YYYY") && !countedDates.has(att.date)) {

                    // If the date matches and it's not already counted, increment totalShiftCount
                    totalShiftCount++;
                    countedDates.add(att.date); // Add the date to the set to mark it as counted
                }
            });
        });
    }

    return totalShiftCount;
};

//attendance checklist
const checkAttendanceStatus = (attendance, rowuserid, rowdate, rowshiftmode) => {
    const attendanceRecord = attendance?.find(
        (d) => d.userid === rowuserid && formatDateRemove(d.date) === rowdate && d.shiftmode === rowshiftmode
    );

    // Check if attendanceRecord exists and its attendancestatus is not undefined
    if (attendanceRecord && attendanceRecord.attendancestatus !== undefined) {
        return attendanceRecord.attendancestatus;
    }
    // Return a default value if attendanceRecord or attendancestatus is not available
    return "";
};

//attendance weekoff present
const checkWeekOffPresentStatus = (attendance, rowuserid, rowdate, rowshiftmode) => {
    const attendanceRecord = attendance?.find(
        (d) => d.userid === rowuserid && formatDateRemove(d.date) === rowdate && d.shiftmode === rowshiftmode && d.weekoffpresentstatus === true
    );

    // Check if attendanceRecord exists and its attendancestatus is not undefined
    if (attendanceRecord && attendanceRecord.weekoffpresentstatus !== undefined) {
        return attendanceRecord.weekoffpresentstatus;
    }
    // Return a default value if attendanceRecord or attendancestatus is not available
    return "";
};

exports.getAllUserClockinAndClockoutStatus = catchAsyncErrors(async (req, res, next) => {

    let allLeaveStatus;
    let permission;
    let resultshiftallot = [];
    let graceTime;
    let clockOutHours;
    let lateclockincount;
    let earlyclockoutcount;
    let onclockout;
    let earlyclockin;
    let earlyclockout;
    let lateclockin;
    let afterlateclockin;
    let beforeearlyclockout;
    let finaluser = [];
    const { userDates, } = req.body;

    const formattedUserDates = userDates.map((data) => moment(data.formattedDate, "DD/MM/YYYY").format("DD-MM-YYYY"));

    let query = {
        enquirystatus: {
            $nin: ["Enquiry Purpose"],
        },
        $or: [
            { reasondate: { $exists: false } },
            { reasondate: "" },
            { reasondate: { $gte: req.body.fromdate } }
        ]
    };

    try {
        const [users, depMonthSet, controlcriteria, attendance, holidays, leavetype] = await Promise.all([
            User.find(query
                , {
                    company: 1,
                    branch: 1,
                    unit: 1,
                    team: 1,
                    department: 1,
                    doj: 1,
                    empcode: 1,
                    companyname: 1,
                    team: 1,
                    floor: 1,
                    username: 1,
                    designation: 1,
                    weekoff: 1,
                    shiftallot: 1,
                    shifttiming: 1,
                    boardingLog: 1,
                    attendancemode: 1,
                    reasondate: 1,
                    departmentlog: 1,
                }
            ),
            DepartmentMonth.find({}, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 }),
            ControlCriteria.find(),
            Attendance.find({
                date: { $in: formattedUserDates },
            }),
            Holiday.find({}, { date: 1, company: 1, applicablefor: 1, unit: 1, team: 1, employee: 1, noofdays: 1 }),
            Leavetype.find({}, { leavetype: 1, code: 1 })
        ])
        const userCds = users.map(user => user.companyname);
        allLeaveStatus = await ApplyLeave.find({ employeename: { $in: userCds } });
        permission = await Permission.find({ employeename: { $in: userCds } }, { employeeid: 1, date: 1, status: 1, applytype: 1, compensationstatus: 1, compensationapplytype: 1, requesthours: 1, shiftmode: 1, });

        // graceTime = controlcriteria[0].gracetime;
        clockOutHours = controlcriteria[0].clockout;
        lateclockincount = controlcriteria[0].lateclockincount;
        earlyclockoutcount = controlcriteria[0].earlyclockoutcount;
        onclockout = controlcriteria[0].onclockout;
        earlyclockin = controlcriteria[0].earlyclockin;
        lateclockin = controlcriteria[0].lateclockin;
        earlyclockout = controlcriteria[0].earlyclockout;
        afterlateclockin = controlcriteria[0].afterlateclockin;
        beforeearlyclockout = controlcriteria[0].afterlateclockin;

        finaluser = users?.flatMap((item, index) => {

            let isEmployeeGrace = controlcriteria[0].todos && controlcriteria[0].todos.find(d => d.company === item.company &&
                d.branch === item.branch && d.unit === item.unit && d.team === item.team &&
                d.employeename === item.companyname
            )

            if (isEmployeeGrace) {
                graceTime = isEmployeeGrace.employeegracetime;
            }
            else {
                graceTime = controlcriteria[0].gracetime;
            }

            item.shiftallot?.map(allot => {
                resultshiftallot.push({ ...allot })
            })

            const filteredMatchingDoubleShiftItem = resultshiftallot?.filter(val => val && val?._doc?.empcode === item?._doc?.empcode && val?._doc?.adjstatus === 'Approved');
            const dojDate = item?._doc?.boardingLog.length > 0 ?
                item?._doc?.boardingLog[0].startdate
                : item?._doc?.doj;

            // Filter out the dates that have matching 'Shift Adjustment' todates
            let removedUserDates = userDates.filter(date => {
                // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
                const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem.find(item => item && item?._doc?.todate === date.formattedDate && item?._doc?.adjustmenttype === 'Shift Adjustment');

                // If there is no matching 'Shift Adjustment', keep the date
                return !matchingShiftAdjustmentToDate;
            });

            // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
            let uniqueEntries = new Set();

            // Iterate over removedUserDates and add unique entries to the Set
            userDates.forEach(date => {
                uniqueEntries.add(JSON.stringify({
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    shiftMode: 'Main Shift',
                    weekNumberInMonth: date.weekNumberInMonth,
                }));
            });

            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach(item => {
                const [day, month, year] = item._doc.adjdate?.split('/')
                let newFormattedDate = new Date(`${year}-${month}-${day}`);

                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(JSON.stringify({
                        formattedDate: item._doc.adjdate,
                        dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
                        dayCount: parseInt(moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")),
                        shiftMode: 'Second Shift',
                        weekNumberInMonth: (getWeekNumberInMonth(newFormattedDate) === 1 ? `${getWeekNumberInMonth(newFormattedDate)}st Week` :
                            getWeekNumberInMonth(newFormattedDate) === 2 ? `${getWeekNumberInMonth(newFormattedDate)}nd Week` :
                                getWeekNumberInMonth(newFormattedDate) === 3 ? `${getWeekNumberInMonth(newFormattedDate)}rd Week` :
                                    getWeekNumberInMonth(newFormattedDate) > 3 ? `${getWeekNumberInMonth(newFormattedDate)}th Week` : '')
                    }));
                }
            });

            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries).map(entry => JSON.parse(entry));

            function sortUserDates(dates) {
                return dates.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);
            const createdUserDates = sortedCreatedUserDates?.filter(d => {
                const filterData = userDates.some(val => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date) => {
                let filteredRowData = resultshiftallot?.filter((val) => val?._doc?.empcode == item?._doc?.empcode);
                const matchingItem = filteredRowData?.find(item => item && item?._doc?.adjdate == date.formattedDate);
                const matchingItemAllot = filteredRowData?.find(item => item && formatDate(item?._doc?.date) == date.formattedDate);
                const matchingDoubleShiftItem = filteredRowData?.find(item => item && item?._doc?.todate === date.formattedDate);
                const matchingRemovedItem = filteredRowData?.find(item => item?._doc?.removedshiftdate === date.formattedDate);
                const matchingAssignShiftItem = filteredRowData?.find(item => item?._doc?.adjdate === date.formattedDate && item?._doc?.adjstatus === 'Approved' && item?._doc?.adjustmenttype === 'Assign Shift');

                const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                    // return item;
                });

                // Remove duplicate entries with the most recent entry
                const uniqueEntriesDep = {};
                item?._doc?.departmentlog?.forEach(entry => {
                    const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                    const key = entry.startdate;
                    if (!(key in uniqueEntriesDep)) {
                        uniqueEntriesDep[key] = entry;
                    }
                });

                const uniqueDepLog = Object.values(uniqueEntriesDep);
                const [columnDay, columnMonth, columnYear] = date.formattedDate?.split('/');
                const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

                // Find the relevant log entry for the given date     
                const relevantDepLogEntry = uniqueDepLog
                    .filter(log => log.startdate <= finalDate)
                    .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item?._doc?.weekoff?.includes(date.dayName);
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet) === "Week Off" ? true : false;

                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                const row = {
                    id: `${item?._doc?._id.toString()}_${date.formattedDate}_${date.shiftMode}`,
                    userid: item?._doc?._id.toString(),
                    company: item?._doc?.company,
                    branch: item?._doc?.branch,
                    unit: item?._doc?.unit,
                    team: item?._doc?.team,
                    department: relevantDepLogEntry && relevantDepLogEntry?.department,
                    username: item?._doc?.companyname,
                    empcode: item?._doc?.empcode,
                    weekoff: item?._doc?.weekoff,
                    boardingLog: item?._doc?.boardingLog,
                    shiftallot: item?._doc?.shiftallot,
                    doj: dojDate,
                    shift: getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                    date: `${date.formattedDate} ${date.dayName} ${date.dayCount}`,
                    rowformattedDate: date.formattedDate,
                    dayName: date.dayName,
                    shiftMode: date.shiftMode,
                    reasondate: item?._doc?.reasondate,
                    clockin: checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        date.shiftMode,
                    ),
                    clockout: checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        date.shiftMode,
                    ),
                    clockinstatus: checkClockInStatus(
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        graceTime, allLeaveStatus, holidays,
                        checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,), item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname,
                        earlyclockin, lateclockin, afterlateclockin, leavetype, permission,
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    clockoutstatus: checkClockOutStatus(
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        clockOutHours, checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        allLeaveStatus, holidays, item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname, onclockout,
                        earlyclockout, beforeearlyclockout,
                        checkGetClockInAutoStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        leavetype, permission, date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    attendanceautostatus: checkAttendanceStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    lateclockincount: lateclockincount,
                    earlyclockoutcount: earlyclockoutcount,
                    weekoffpresentstatus: checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                };

                return row;
            });

            return userRows;

        });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finaluser) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ finaluser });
});

exports.getAllUserClockinAndClockoutStatusFilter = catchAsyncErrors(async (req, res, next) => {

    let allLeaveStatus;
    let permission;
    let resultshiftallot = [];
    let graceTime;
    let clockOutHours;
    let lateclockincount;
    let earlyclockoutcount;
    let onclockout;
    let earlyclockin;
    let earlyclockout;
    let lateclockin;
    let afterlateclockin;
    let beforeearlyclockout;
    let finaluser = [];
    // const { userDates, company, branch, unit, department, employee } = req.body;
    const { userDates, employee } = req.body;

    const formattedUserDates = userDates.map((data) => moment(data.formattedDate, "DD/MM/YYYY").format("DD-MM-YYYY"));

    let query = {
        companyname: { $in: employee },
        enquirystatus: {
            $nin: ["Enquiry Purpose"],
        },

    }

    try {
        const [users, controlcriteria, depMonthSets, attendances, holidays, leavetype] = await Promise.all([
            User.find(query,
                {
                    company: 1,
                    branch: 1,
                    unit: 1,
                    team: 1,
                    department: 1,
                    doj: 1,
                    empcode: 1,
                    companyname: 1,
                    team: 1,
                    floor: 1,
                    username: 1,
                    designation: 1,
                    weekoff: 1,
                    shiftallot: 1,
                    shifttiming: 1,
                    boardingLog: 1,
                    attendancemode: 1,
                    reasondate: 1,
                    departmentlog: 1,
                    designationlog: 1,
                }
            ),
            ControlCriteria.find(),
            DepartmentMonth.find({}, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 }),
            Attendance.find({
                date: { $in: formattedUserDates },
            }),
            Holiday.find({}, { date: 1, company: 1, applicablefor: 1, unit: 1, team: 1, employee: 1, noofdays: 1 }),
            Leavetype.find({}, { leavetype: 1, code: 1 })
        ])

        const userCds = users.map(user => user.companyname);
        allLeaveStatus = await ApplyLeave.find({ employeename: { $in: userCds } });
        permission = await Permission.find({ employeename: { $in: userCds } }, { employeeid: 1, date: 1, status: 1, applytype: 1, compensationstatus: 1, compensationapplytype: 1, requesthours: 1, shiftmode: 1, });

        // graceTime = controlcriteria[0].gracetime;
        clockOutHours = controlcriteria[0].clockout;
        lateclockincount = controlcriteria[0].lateclockincount;
        earlyclockoutcount = controlcriteria[0].earlyclockoutcount;
        onclockout = controlcriteria[0].onclockout;
        earlyclockin = controlcriteria[0].earlyclockin;
        lateclockin = controlcriteria[0].lateclockin;
        earlyclockout = controlcriteria[0].earlyclockout;
        afterlateclockin = controlcriteria[0].afterlateclockin;
        beforeearlyclockout = controlcriteria[0].afterlateclockin;

        finaluser = users?.flatMap((item, index) => {

            let isEmployeeGrace = controlcriteria[0].todos && controlcriteria[0].todos.find(d => d.company === item.company &&
                d.branch === item.branch && d.unit === item.unit && d.team === item.team &&
                d.employeename === item.companyname
            )

            if (isEmployeeGrace) {
                graceTime = isEmployeeGrace.employeegracetime;
            }
            else {
                graceTime = controlcriteria[0].gracetime;
            }

            item.shiftallot?.map(allot => {
                resultshiftallot.push({ ...allot })
            })

            const filteredMatchingDoubleShiftItem = resultshiftallot?.filter(val => val && val?._doc?.empcode === item?._doc?.empcode && val?._doc?.adjstatus === 'Approved');
            const dojDate = item?._doc?.boardingLog.length > 0 ?
                item?._doc?.boardingLog[0].startdate
                : item?._doc?.doj;

            // Filter out the dates that have matching 'Shift Adjustment' todates
            let removedUserDates = userDates?.filter(date => {
                // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
                const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem.find(item => item && item?._doc?.todate === date.formattedDate && item?._doc?.adjustmenttype === 'Shift Adjustment');

                // If there is no matching 'Shift Adjustment', keep the date
                return !matchingShiftAdjustmentToDate;
            });

            // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
            let uniqueEntries = new Set();

            // Iterate over removedUserDates and add unique entries to the Set
            userDates?.forEach(date => {
                uniqueEntries.add(JSON.stringify({
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    shiftMode: 'Main Shift',
                    weekNumberInMonth: date.weekNumberInMonth
                }));
            });

            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach(item => {
                const [day, month, year] = item._doc.adjdate?.split('/')
                let newFormattedDate = new Date(`${year}-${month}-${day}`);

                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(JSON.stringify({
                        formattedDate: item._doc.adjdate,
                        dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
                        dayCount: parseInt(moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")),
                        shiftMode: 'Second Shift',
                        weekNumberInMonth: (getWeekNumberInMonth(newFormattedDate) === 1 ? `${getWeekNumberInMonth(newFormattedDate)}st Week` :
                            getWeekNumberInMonth(newFormattedDate) === 2 ? `${getWeekNumberInMonth(newFormattedDate)}nd Week` :
                                getWeekNumberInMonth(newFormattedDate) === 3 ? `${getWeekNumberInMonth(newFormattedDate)}rd Week` :
                                    getWeekNumberInMonth(newFormattedDate) > 3 ? `${getWeekNumberInMonth(newFormattedDate)}th Week` : '')
                    }));
                }
            });

            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries)?.map(entry => JSON.parse(entry));

            function sortUserDates(dates) {
                return dates.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);
            const createdUserDates = sortedCreatedUserDates?.filter(d => {
                const filterData = userDates.some(val => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date) => {
                let filteredRowData = resultshiftallot?.filter((val) => val?._doc?.empcode == item?._doc?.empcode);
                const matchingItem = filteredRowData?.find(item => item && item?._doc?.adjdate == date.formattedDate);
                const matchingItemAllot = filteredRowData?.find(item => item && formatDate(item?._doc?.date) == date.formattedDate);
                const matchingDoubleShiftItem = filteredRowData?.find(item => item && item?._doc?.todate === date.formattedDate);
                const matchingRemovedItem = filteredRowData?.find(item => item?._doc?.removedshiftdate === date.formattedDate);
                const matchingAssignShiftItem = filteredRowData?.find(item => item?._doc?.adjdate === date.formattedDate && item?._doc?.adjstatus === 'Approved' && item?._doc?.adjustmenttype === 'Assign Shift');

                const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                    // return item;
                });

                // Remove duplicate entries with the most recent entry
                const uniqueEntriesDep = {};
                item?._doc?.departmentlog?.forEach(entry => {
                    const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                    const key = entry.startdate;
                    if (!(key in uniqueEntriesDep)) {
                        uniqueEntriesDep[key] = entry;
                    }
                });

                const uniqueDepLog = Object.values(uniqueEntriesDep);
                const [columnDay, columnMonth, columnYear] = date.formattedDate?.split('/');
                const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

                // Find the relevant log entry for the given date     
                const relevantDepLogEntry = uniqueDepLog
                    .filter(log => log.startdate <= finalDate)
                    .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

                // Remove duplicate entries with the most recent entry
                const uniqueEntriesDesig = {};
                item?._doc?.designationlog?.forEach(entry => {
                    const entryDate = new Date(entry.startdate);
                    const key = entry.startdate;
                    if (!(key in uniqueEntriesDesig)) {
                        uniqueEntriesDesig[key] = entry;
                    }
                });

                const uniqueDesigLog = Object.values(uniqueEntriesDesig);

                // Find the relevant log entry for the given date     
                const relevantDesigLogEntry = uniqueDesigLog
                    .filter(log => log.startdate <= finalDate)
                    .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

                const depMonthSet = depMonthSets.filter(d => d.department === (relevantDepLogEntry && relevantDepLogEntry?.department))
                const attendance = attendances.filter(d => d.username === item?._doc?.username)

                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item?._doc?.weekoff?.includes(date.dayName);
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                const row = {
                    id: `${item?._doc?._id.toString()}_${date.formattedDate}_${date.shiftMode}`,
                    userid: item?._doc?._id.toString(),
                    company: item?._doc?.company,
                    designation: item?._doc?.designation,
                    branch: item?._doc?.branch,
                    unit: item?._doc?.unit,
                    team: item?._doc?.team,
                    department: (relevantDepLogEntry && relevantDepLogEntry?.department),
                    designation: (relevantDesigLogEntry && relevantDesigLogEntry?.designation),
                    username: item?._doc?.companyname,
                    rowusername: item?._doc?.username,
                    empcode: item?._doc?.empcode,
                    weekoff: item?._doc?.weekoff,
                    boardingLog: item?._doc?.boardingLog,
                    shiftallot: item?._doc?.shiftallot,
                    doj: dojDate,
                    shift: getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                    date: `${date.formattedDate} ${date.dayName} ${date.dayCount}`,
                    rowformattedDate: date.formattedDate,
                    dayName: date.dayName,
                    shiftMode: date.shiftMode,
                    reasondate: item?._doc?.reasondate,
                    clockin: checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        date.shiftMode,
                    ),
                    clockout: checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        date.shiftMode,
                    ),
                    clockinstatus: checkClockInStatus(
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        graceTime, allLeaveStatus, holidays,
                        checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,), item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname,
                        earlyclockin, lateclockin, afterlateclockin, leavetype, permission,
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    clockoutstatus: checkClockOutStatus(
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        clockOutHours, checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        allLeaveStatus, holidays, item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname, onclockout,
                        earlyclockout, beforeearlyclockout,
                        checkGetClockInAutoStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        leavetype, permission, date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    attendanceautostatus: checkAttendanceStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    lateclockincount: lateclockincount,
                    earlyclockoutcount: earlyclockoutcount,
                    weekoffpresentstatus: checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                };

                return row;
            });

            return userRows;

        });

    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finaluser) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ finaluser });
});


exports.getAllUserClockinAndClockoutStatusFilter = catchAsyncErrors(async (req, res, next) => {

    let allLeaveStatus;
    let permission;
    let resultshiftallot = [];
    let graceTime;
    let clockOutHours;
    let lateclockincount;
    let earlyclockoutcount;
    let onclockout;
    let earlyclockin;
    let earlyclockout;
    let lateclockin;
    let afterlateclockin;
    let beforeearlyclockout;
    let finaluser = [];
    // const { userDates, company, branch, unit, department, employee } = req.body;
    const { userDates, employee } = req.body;

    const formattedUserDates = userDates.map((data) => moment(data.formattedDate, "DD/MM/YYYY").format("DD-MM-YYYY"));

    let query = {
        companyname: { $in: employee },
        enquirystatus: {
            $nin: ["Enquiry Purpose"],
        },

    }

    try {
        const [users, controlcriteria, depMonthSets, attendances, holidays, leavetype] = await Promise.all([
            User.find(query,
                {
                    company: 1,
                    branch: 1,
                    unit: 1,
                    team: 1,
                    department: 1,
                    doj: 1,
                    empcode: 1,
                    companyname: 1,
                    team: 1,
                    floor: 1,
                    username: 1,
                    designation: 1,
                    weekoff: 1,
                    shiftallot: 1,
                    shifttiming: 1,
                    boardingLog: 1,
                    attendancemode: 1,
                    reasondate: 1,
                    departmentlog: 1,
                    designationlog: 1,
                }
            ),
            ControlCriteria.find(),
            DepartmentMonth.find({}, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 }),
            Attendance.find({
                date: { $in: formattedUserDates },
            }),
            Holiday.find({}, { date: 1, company: 1, applicablefor: 1, unit: 1, team: 1, employee: 1, noofdays: 1 }),
            Leavetype.find({}, { leavetype: 1, code: 1 })
        ])

        const userCds = users.map(user => user.companyname);
        allLeaveStatus = await ApplyLeave.find({ employeename: { $in: userCds } });
        permission = await Permission.find({ employeename: { $in: userCds } }, { employeeid: 1, date: 1, status: 1, applytype: 1, compensationstatus: 1, compensationapplytype: 1, requesthours: 1, shiftmode: 1, });

        // graceTime = controlcriteria[0].gracetime;
        clockOutHours = controlcriteria[0].clockout;
        lateclockincount = controlcriteria[0].lateclockincount;
        earlyclockoutcount = controlcriteria[0].earlyclockoutcount;
        onclockout = controlcriteria[0].onclockout;
        earlyclockin = controlcriteria[0].earlyclockin;
        lateclockin = controlcriteria[0].lateclockin;
        earlyclockout = controlcriteria[0].earlyclockout;
        afterlateclockin = controlcriteria[0].afterlateclockin;
        beforeearlyclockout = controlcriteria[0].afterlateclockin;

        finaluser = users?.flatMap((item, index) => {

            let isEmployeeGrace = controlcriteria[0].todos && controlcriteria[0].todos.find(d => d.company === item.company &&
                d.branch === item.branch && d.unit === item.unit && d.team === item.team &&
                d.employeename === item.companyname
            )

            if (isEmployeeGrace) {
                graceTime = isEmployeeGrace.employeegracetime;
            }
            else {
                graceTime = controlcriteria[0].gracetime;
            }

            item.shiftallot?.map(allot => {
                resultshiftallot.push({ ...allot })
            })

            const filteredMatchingDoubleShiftItem = resultshiftallot?.filter(val => val && val?._doc?.empcode === item?._doc?.empcode && val?._doc?.adjstatus === 'Approved');
            const dojDate = item?._doc?.boardingLog.length > 0 ?
                item?._doc?.boardingLog[0].startdate
                : item?._doc?.doj;

            // Filter out the dates that have matching 'Shift Adjustment' todates
            let removedUserDates = userDates?.filter(date => {
                // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
                const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem.find(item => item && item?._doc?.todate === date.formattedDate && item?._doc?.adjustmenttype === 'Shift Adjustment');

                // If there is no matching 'Shift Adjustment', keep the date
                return !matchingShiftAdjustmentToDate;
            });

            // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
            let uniqueEntries = new Set();

            // Iterate over removedUserDates and add unique entries to the Set
            userDates?.forEach(date => {
                uniqueEntries.add(JSON.stringify({
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    shiftMode: 'Main Shift',
                    weekNumberInMonth: date.weekNumberInMonth
                }));
            });

            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach(item => {
                const [day, month, year] = item._doc.adjdate?.split('/')
                let newFormattedDate = new Date(`${year}-${month}-${day}`);

                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(JSON.stringify({
                        formattedDate: item._doc.adjdate,
                        dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
                        dayCount: parseInt(moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")),
                        shiftMode: 'Second Shift',
                        weekNumberInMonth: (getWeekNumberInMonth(newFormattedDate) === 1 ? `${getWeekNumberInMonth(newFormattedDate)}st Week` :
                            getWeekNumberInMonth(newFormattedDate) === 2 ? `${getWeekNumberInMonth(newFormattedDate)}nd Week` :
                                getWeekNumberInMonth(newFormattedDate) === 3 ? `${getWeekNumberInMonth(newFormattedDate)}rd Week` :
                                    getWeekNumberInMonth(newFormattedDate) > 3 ? `${getWeekNumberInMonth(newFormattedDate)}th Week` : '')
                    }));
                }
            });

            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries)?.map(entry => JSON.parse(entry));

            function sortUserDates(dates) {
                return dates.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);
            const createdUserDates = sortedCreatedUserDates?.filter(d => {
                const filterData = userDates.some(val => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date) => {
                let filteredRowData = resultshiftallot?.filter((val) => val?._doc?.empcode == item?._doc?.empcode);
                const matchingItem = filteredRowData?.find(item => item && item?._doc?.adjdate == date.formattedDate);
                const matchingItemAllot = filteredRowData?.find(item => item && formatDate(item?._doc?.date) == date.formattedDate);
                const matchingDoubleShiftItem = filteredRowData?.find(item => item && item?._doc?.todate === date.formattedDate);
                const matchingRemovedItem = filteredRowData?.find(item => item?._doc?.removedshiftdate === date.formattedDate);
                const matchingAssignShiftItem = filteredRowData?.find(item => item?._doc?.adjdate === date.formattedDate && item?._doc?.adjstatus === 'Approved' && item?._doc?.adjustmenttype === 'Assign Shift');

                const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                    // return item;
                });

                // Remove duplicate entries with the most recent entry
                const uniqueEntriesDep = {};
                item?._doc?.departmentlog?.forEach(entry => {
                    const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                    const key = entry.startdate;
                    if (!(key in uniqueEntriesDep)) {
                        uniqueEntriesDep[key] = entry;
                    }
                });

                const uniqueDepLog = Object.values(uniqueEntriesDep);
                const [columnDay, columnMonth, columnYear] = date.formattedDate?.split('/');
                const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

                // Find the relevant log entry for the given date     
                const relevantDepLogEntry = uniqueDepLog
                    .filter(log => log.startdate <= finalDate)
                    .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

                // Remove duplicate entries with the most recent entry
                const uniqueEntriesDesig = {};
                item?._doc?.designationlog?.forEach(entry => {
                    const entryDate = new Date(entry.startdate);
                    const key = entry.startdate;
                    if (!(key in uniqueEntriesDesig)) {
                        uniqueEntriesDesig[key] = entry;
                    }
                });

                const uniqueDesigLog = Object.values(uniqueEntriesDesig);

                // Find the relevant log entry for the given date     
                const relevantDesigLogEntry = uniqueDesigLog
                    .filter(log => log.startdate <= finalDate)
                    .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

                const depMonthSet = depMonthSets.filter(d => d.department === (relevantDepLogEntry && relevantDepLogEntry?.department))
                const attendance = attendances.filter(d => d.username === item?._doc?.username)

                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item?._doc?.weekoff?.includes(date.dayName);
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                const row = {
                    id: `${item?._doc?._id.toString()}_${date.formattedDate}_${date.shiftMode}`,
                    userid: item?._doc?._id.toString(),
                    company: item?._doc?.company,
                    designation: item?._doc?.designation,
                    branch: item?._doc?.branch,
                    unit: item?._doc?.unit,
                    team: item?._doc?.team,
                    department: (relevantDepLogEntry && relevantDepLogEntry?.department),
                    designation: (relevantDesigLogEntry && relevantDesigLogEntry?.designation),
                    username: item?._doc?.companyname,
                    rowusername: item?._doc?.username,
                    empcode: item?._doc?.empcode,
                    weekoff: item?._doc?.weekoff,
                    boardingLog: item?._doc?.boardingLog,
                    shiftallot: item?._doc?.shiftallot,
                    doj: dojDate,
                    shift: getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                    date: `${date.formattedDate} ${date.dayName} ${date.dayCount}`,
                    rowformattedDate: date.formattedDate,
                    dayName: date.dayName,
                    shiftMode: date.shiftMode,
                    reasondate: item?._doc?.reasondate,
                    clockin: checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        date.shiftMode,
                    ),
                    clockout: checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        date.shiftMode,
                    ),
                    clockinstatus: checkClockInStatus(
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        graceTime, allLeaveStatus, holidays,
                        checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,), item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname,
                        earlyclockin, lateclockin, afterlateclockin, leavetype, permission,
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    clockoutstatus: checkClockOutStatus(
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        clockOutHours, checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        allLeaveStatus, holidays, item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname, onclockout,
                        earlyclockout, beforeearlyclockout,
                        checkGetClockInAutoStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        leavetype, permission, date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    attendanceautostatus: checkAttendanceStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    lateclockincount: lateclockincount,
                    earlyclockoutcount: earlyclockoutcount,
                    weekoffpresentstatus: checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                };

                return row;
            });

            return userRows;

        });

    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finaluser) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ finaluser });
});






exports.getAllUserClockinAndClockoutStatusForMontLopCalFilter = catchAsyncErrors(async (req, res, next) => {
    let graceTime;
    let clockOutHours;
    let lateclockincount;
    let earlyclockoutcount;
    let onclockout;
    let earlyclockin;
    let earlyclockout;
    let lateclockin;
    let afterlateclockin;
    let beforeearlyclockout;
    let finaluserbefore = [];
    let finaluser = [];
    //const { ismonth, isyear, company, branch, unit, department, employee } = req.body;
    const { ismonth, isyear, employee } = req.body;

    try {
        const [users, depMonthSets, controlcriteria, holidays, leavetype] = await Promise.all([
            User.find(
                {
                    //company: { $in: company },
                    //branch: { $in: branch },
                    //unit: { $in: unit },
                    //$or: [
                    //    {
                    //        departmentlog: {
                    //            $elemMatch: {
                    //                department: { $in: department }
                    //            }
                    //        }
                    //    },
                    //    { companyname: { $in: employee } },
                    //],
                    companyname: { $in: employee },
                    enquirystatus: {
                        $nin: ["Enquiry Purpose"],
                    },
                }, {
                company: 1,
                branch: 1,
                unit: 1,
                team: 1,
                department: 1,
                doj: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                floor: 1,
                username: 1,
                designation: 1,
                role: 1,
                weekoff: 1,
                shiftallot: 1,
                shifttiming: 1,
                boardingLog: 1,
                attendancemode: 1,
                reasondate: 1,
                departmentlog: 1,
            }
            ),
            DepartmentMonth.find({}, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 }),
            ControlCriteria.find(),
            Holiday.find({}, { date: 1, company: 1, applicablefor: 1, unit: 1, team: 1, employee: 1, noofdays: 1 }),
            Leavetype.find({}, { leavetype: 1, code: 1 })
        ])
        const userIds = users.map(user => user._id);
        const userCds = users.map(user => user.companyname);

        const [attendances, allLeaveStatus, permission] = await Promise.all([
            Attendance.find({ userid: { $in: userIds } }),
            ApplyLeave.find({ employeename: { $in: userCds } }),
            Permission.find({ employeename: { $in: userCds } }, { employeeid: 1, date: 1, status: 1, applytype: 1, compensationstatus: 1, compensationapplytype: 1, requesthours: 1, shiftmode: 1, })

        ])
        // graceTime = controlcriteria[0].gracetime;
        clockOutHours = controlcriteria[0].clockout;
        lateclockincount = controlcriteria[0].lateclockincount;
        earlyclockoutcount = controlcriteria[0].earlyclockoutcount;
        onclockout = controlcriteria[0].onclockout;
        earlyclockin = controlcriteria[0].earlyclockin;
        lateclockin = controlcriteria[0].lateclockin;
        earlyclockout = controlcriteria[0].earlyclockout;
        afterlateclockin = controlcriteria[0].afterlateclockin;
        beforeearlyclockout = controlcriteria[0].afterlateclockin;

        const monthNames = ["January", "February", "March", "April", "May", "June",
            "July", "August", "September", "October", "November", "December"
        ];

        finaluser = users?.flatMap((item, index) => {

            let isEmployeeGrace = controlcriteria[0].todos && controlcriteria[0].todos.find(d => d.company === item.company &&
                d.branch === item.branch && d.unit === item.unit && d.team === item.team &&
                d.employeename === item.companyname
            )

            if (isEmployeeGrace) {
                graceTime = isEmployeeGrace.employeegracetime;
            }
            else {
                graceTime = controlcriteria[0].gracetime;
            }

            let userDates = [];

            // Remove duplicate entries with the most recent entry
            const uniqueEntriesDep = {};
            item.departmentlog?.forEach(entry => {
                const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                const key = entry.startdate;
                if (!(key in uniqueEntriesDep)) {
                    uniqueEntriesDep[key] = entry;
                }
            });
            const foundDepartment = depMonthSets?.find((d) => Number(d.year) === isyear && d.monthname === monthNames[ismonth - 1]);
            const uniqueDepLog = Object.values(uniqueEntriesDep);
            const relevantDepLogEntry = uniqueDepLog
                .filter(log => new Date(log.startdate) <= new Date(foundDepartment && foundDepartment.fromdate))
                .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

            const comparedDate = depMonthSets?.filter((d) => d.department === (relevantDepLogEntry && relevantDepLogEntry?.department) && Number(d.year) === isyear && d.monthname === monthNames[ismonth - 1]);
            const dojDate = item?._doc?.boardingLog.length > 0 ?
                item?._doc?.boardingLog[0].startdate
                : item?._doc?.doj;

            if (comparedDate && comparedDate.length > 0) {
                comparedDate?.forEach((dep) => {
                    if (!dep.fromdate && !dep.todate) {
                        return '';
                    }

                    if (!item?._doc?.doj) {
                        return "";
                    }

                    const [year2, month2, day2] = dojDate?.split('-').map(Number);
                    const joiningDate = new Date(year2, month2 - 1, day2);
                    const [year1, month1, day1] = dep.fromdate?.split('-').map(Number);
                    const [year, month, day] = dep.todate?.split('-').map(Number);
                    const lastDate = new Date(year, month - 1, day);
                    const firstDate = new Date(year1, month1 - 1, day1);

                    if (joiningDate < firstDate) {
                        // Check if the shift date is before or equal to the current date
                        if (lastDate >= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(firstDate);
                            // Loop through the dates in the range
                            while (startDate <= currentDateAttStatus) {
                                userDates.push({
                                    formattedDate: format(startDate, 'dd/MM/yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        } else if (lastDate <= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(firstDate);
                            // Loop through the dates in the range
                            while (startDate <= lastDate) {
                                userDates.push({
                                    formattedDate: format(startDate, 'dd/MM/yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        }
                    } else {
                        // Check if the shift date is before or equal to the current date
                        if (lastDate >= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(joiningDate);
                            // Loop through the dates in the range
                            while (startDate <= currentDateAttStatus) {
                                userDates.push({
                                    formattedDate: format(startDate, 'dd/MM/yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        }
                        else if (lastDate <= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(joiningDate);
                            // Loop through the dates in the range
                            while (startDate <= lastDate) {
                                userDates.push({
                                    formattedDate: format(startDate, 'dd/MM/yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        }
                    }
                });
            }
            else {
                const [year2, month2, day2] = dojDate?.split('-').map(Number);
                const joiningDate = new Date(year2, month2 - 1, day2);
                // Calculate the start date of the month based on the selected month
                const startDate = new Date(isyear, ismonth - 1, 1);

                const endDate = new Date(startDate);
                endDate.setMonth(endDate.getMonth() + 1);
                endDate.setDate(endDate.getDate() - 1);

                if (joiningDate < startDate) {
                    // Check if the shift date is before or equal to the current date
                    if (endDate >= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            userDates.push({
                                formattedDate: format(currentDate1, 'dd/MM/yyyy'),
                                dayName: format(currentDate1, 'EEEE'),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    } else if (endDate <= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            userDates.push({
                                formattedDate: format(currentDate1, 'dd/MM/yyyy'),
                                dayName: format(currentDate1, 'EEEE'),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    }
                } else {
                    // Check if the shift date is before or equal to the current date
                    if (endDate >= currentDateAttStatus) {
                        // If matched, push the range from 'fromdate' to 'todate'
                        const startDate = new Date(joiningDate);
                        // Loop through the dates in the range
                        while (startDate <= currentDateAttStatus) {
                            userDates.push({
                                formattedDate: format(startDate, 'dd/MM/yyyy'),
                                dayName: format(startDate, 'EEEE'),
                                dayCount: startDate.getDate(),
                            });
                            startDate.setDate(startDate.getDate() + 1);
                        }
                    } else if (endDate <= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            userDates.push({
                                formattedDate: format(currentDate1, 'dd/MM/yyyy'),
                                dayName: format(currentDate1, 'EEEE'),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    }
                }
            }

            const filteredMatchingDoubleShiftItem = item.shiftallot?.filter(val => val && val?._doc?.empcode === item?._doc?.empcode && val?._doc?.adjstatus === 'Approved');

            // Filter out the dates that have matching 'Shift Adjustment' todates
            let removedUserDates = userDates.filter(date => {
                // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
                const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem.find(item => item && item?._doc?.todate === date.formattedDate && item?._doc?.adjustmenttype === 'Shift Adjustment');

                // If there is no matching 'Shift Adjustment', keep the date
                return !matchingShiftAdjustmentToDate;
            });

            // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
            let uniqueEntries = new Set();

            // Iterate over removedUserDates and add unique entries to the Set
            userDates.forEach(date => {
                uniqueEntries.add(JSON.stringify({
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    shiftMode: 'Main Shift',
                    weekNumberInMonth: date.weekNumberInMonth,
                }));
            });

            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach(item => {
                const [day, month, year] = item._doc.adjdate?.split('/')
                let newFormattedDate = new Date(`${year}-${month}-${day}`);

                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(JSON.stringify({
                        formattedDate: item._doc.adjdate,
                        dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
                        dayCount: parseInt(moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")),
                        shiftMode: 'Second Shift',
                        weekNumberInMonth: (getWeekNumberInMonth(newFormattedDate) === 1 ? `${getWeekNumberInMonth(newFormattedDate)}st Week` :
                            getWeekNumberInMonth(newFormattedDate) === 2 ? `${getWeekNumberInMonth(newFormattedDate)}nd Week` :
                                getWeekNumberInMonth(newFormattedDate) === 3 ? `${getWeekNumberInMonth(newFormattedDate)}rd Week` :
                                    getWeekNumberInMonth(newFormattedDate) > 3 ? `${getWeekNumberInMonth(newFormattedDate)}th Week` : '')
                    }));
                }
            });

            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries).map(entry => JSON.parse(entry));

            function sortUserDates(dates) {
                return dates.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);
            const createdUserDates = sortedCreatedUserDates?.filter(d => {
                const filterData = userDates.some(val => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date) => {
                let filteredRowData = item.shiftallot?.filter((val) => val?._doc?.empcode == item?._doc?.empcode);
                const matchingItem = filteredRowData?.find(item => item && item?._doc?.adjdate == date.formattedDate);
                const matchingItemAllot = filteredRowData?.find(item => item && formatDate(item?._doc?.date) == date.formattedDate);
                const matchingDoubleShiftItem = filteredRowData?.find(item => item && item?._doc?.todate === date.formattedDate);
                const matchingRemovedItem = filteredRowData?.find(item => item?._doc?.removedshiftdate === date.formattedDate);
                const matchingAssignShiftItem = filteredRowData?.find(item => item?._doc?.adjdate === date.formattedDate && item?._doc?.adjstatus === 'Approved' && item?._doc?.adjustmenttype === 'Assign Shift');

                const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                    // return item;
                });

                const depMonthSet = depMonthSets?.filter((d) => d.department === (relevantDepLogEntry && relevantDepLogEntry?.department) && Number(d.year) === isyear && d.monthname === monthNames[ismonth - 1]);
                const attendance = attendances.filter(d => {
                    const [userday, usermonth, useryear] = date.formattedDate?.split('/');
                    const [attday, attmonth, attyear] = d.date?.split('-');
                    const userDate = `${useryear}-${usermonth}-${userday}`;
                    const datevalue = `${attyear}-${attmonth}-${attday}`;
                    return (
                        d.username === item.username && new Date(datevalue) >= new Date(userDate) && new Date(datevalue) <= new Date(userDate)
                    )
                })

                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item?._doc?.weekoff?.includes(date.dayName);
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                const row = {
                    id: `${item?._doc?._id.toString()}_${date.formattedDate}_${date.shiftMode}`,
                    userid: item?._doc?._id.toString(),
                    company: item?._doc?.company,
                    branch: item?._doc?.branch,
                    unit: item?._doc?.unit,
                    team: item?._doc?.team,
                    department: (relevantDepLogEntry && relevantDepLogEntry.department),
                    username: item?._doc?.companyname,
                    empcode: item?._doc?.empcode,
                    weekoff: item?._doc?.weekoff,
                    boardingLog: item?._doc?.boardingLog,
                    shiftallot: item?._doc?.shiftallot,
                    doj: dojDate,
                    shift: getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                    date: `${date.formattedDate} ${date.dayName} ${date.dayCount}`,
                    role: item?._doc?.role,
                    rowformattedDate: date.formattedDate,
                    dayName: date.dayName,
                    shiftMode: date.shiftMode,
                    reasondate: item?._doc?.reasondate,
                    clockin: checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        date.shiftMode,
                    ),
                    clockout: checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        date.shiftMode,
                    ),
                    clockinstatus: checkClockInStatus(
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        graceTime, allLeaveStatus, holidays,
                        checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,), item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname,
                        earlyclockin, lateclockin, afterlateclockin, leavetype, permission,
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    clockoutstatus: checkClockOutStatus(
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        clockOutHours, checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        allLeaveStatus, holidays, item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname, onclockout,
                        earlyclockout, beforeearlyclockout,
                        checkGetClockInAutoStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        leavetype, permission, date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    attendanceautostatus: checkAttendanceStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    lateclockincount: lateclockincount,
                    earlyclockoutcount: earlyclockoutcount,
                    totalnumberofdays: getTotalMonthDaysUser(item?._doc?.department, depMonthSet, ismonth, isyear),
                    empshiftdays: getTotalMonthDaysForEmpUser(dojDate, item?._doc?.department, depMonthSet, ismonth, isyear),
                    totalcounttillcurrendate: getTotalMonthsCurrentDateCountUser(dojDate, item?._doc?.department, depMonthSet, ismonth, isyear),
                    totalshift: getTotalShiftHoursUser(item?._doc?._id.toString(), createdUserDates, attendance),
                    weekoffpresentstatus: checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                };

                return row;
            });

            return userRows;

        });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finaluser) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ finaluser });
});

/// get usershift clockin and clockout status individual
exports.getAllUserClockinAndClockoutStatusIndividual = catchAsyncErrors(async (req, res, next) => {

    let allLeaveStatus;
    let permission;
    let resultshiftallot = [];
    let graceTime;
    let clockOutHours;
    let lateclockincount;
    let earlyclockoutcount;
    let onclockout;
    let earlyclockin;
    let earlyclockout;
    let lateclockin;
    let afterlateclockin;
    let beforeearlyclockout;
    let finaluser = [];
    const { userDates } = req.body;

    const formattedUserDates = userDates.map((data) => moment(data.formattedDate, "DD/MM/YYYY").format("DD-MM-YYYY"));

    try {
        const [users, controlcriteria, depMonthSet, attendance, holidays, leavetype] = await Promise.all([
            User.find(
                {
                    // company: req.body.company,
                    // branch: req.body.branch,
                    // unit: req.body.unit,
                    // department: req.body.department,
                    enquirystatus: {
                        $nin: ["Enquiry Purpose"],
                    },
                    // resonablestatus: {
                    //     $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                    // },
                    $or: [
                        { reasondate: { $exists: false } }, // Include if reasondate doesn't exist
                        { reasondate: "" },
                        { reasondate: { $gte: req.body.fromdate } }
                    ]
                }, {
                company: 1,
                branch: 1,
                unit: 1,
                team: 1,
                department: 1,
                doj: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                floor: 1,
                username: 1,
                designation: 1,
                weekoff: 1,
                shiftallot: 1,
                shifttiming: 1,
                boardingLog: 1,
                attendancemode: 1,
                role: 1,
                reasondate: 1,
                departmentlog: 1,
            }
            ),
            ControlCriteria.find(),
            DepartmentMonth.find({}, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 }),
            Attendance.find({
                date: { $in: formattedUserDates },
            }),
            Holiday.find({}, { date: 1, company: 1, applicablefor: 1, unit: 1, team: 1, employee: 1, noofdays: 1 }),
            Leavetype.find({}, { leavetype: 1, code: 1 })
        ])
        const userCds = users.map(user => user.companyname);
        allLeaveStatus = await ApplyLeave.find({ employeename: { $in: userCds } });
        permission = await Permission.find({ employeename: { $in: userCds } }, { employeeid: 1, date: 1, status: 1, applytype: 1, compensationstatus: 1, compensationapplytype: 1, requesthours: 1, shiftmode: 1, });

        // graceTime = controlcriteria[0].gracetime;
        clockOutHours = controlcriteria[0].clockout;
        lateclockincount = controlcriteria[0].lateclockincount;
        earlyclockoutcount = controlcriteria[0].earlyclockoutcount;
        onclockout = controlcriteria[0].onclockout;
        earlyclockin = controlcriteria[0].earlyclockin;
        lateclockin = controlcriteria[0].lateclockin;
        earlyclockout = controlcriteria[0].earlyclockout;
        afterlateclockin = controlcriteria[0].afterlateclockin;
        beforeearlyclockout = controlcriteria[0].afterlateclockin;

        finaluser = users?.flatMap((item, index) => {

            let isEmployeeGrace = controlcriteria[0].todos && controlcriteria[0].todos.find(d => d.company === item.company &&
                d.branch === item.branch && d.unit === item.unit && d.team === item.team &&
                d.employeename === item.companyname
            )

            if (isEmployeeGrace) {
                graceTime = isEmployeeGrace.employeegracetime;
            }
            else {
                graceTime = controlcriteria[0].gracetime;
            }

            item.shiftallot?.map(allot => {
                resultshiftallot.push({ ...allot })
            })

            const filteredMatchingDoubleShiftItem = resultshiftallot?.filter(val => val && val?._doc?.empcode === item?._doc?.empcode && val?._doc?.adjstatus === 'Approved');
            const dojDate = item?._doc?.boardingLog.length > 0 ?
                item?._doc?.boardingLog[0].startdate
                : item?._doc?.doj;

            // Filter out the dates that have matching 'Shift Adjustment' todates
            let removedUserDates = userDates?.filter(date => {
                // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
                const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem.find(item => item && item?._doc?.todate === date.formattedDate && item?._doc?.adjustmenttype === 'Shift Adjustment');

                // If there is no matching 'Shift Adjustment', keep the date
                return !matchingShiftAdjustmentToDate;
            });

            // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
            let uniqueEntries = new Set();

            // Iterate over removedUserDates and add unique entries to the Set
            userDates?.forEach(date => {
                uniqueEntries.add(JSON.stringify({
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    shiftMode: 'Main Shift',
                    weekNumberInMonth: date.weekNumberInMonth
                }));
            });

            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach(item => {
                const [day, month, year] = item._doc.adjdate?.split('/')
                let newFormattedDate = new Date(`${year}-${month}-${day}`);

                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(JSON.stringify({
                        formattedDate: item._doc.adjdate,
                        dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
                        dayCount: parseInt(moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")),
                        shiftMode: 'Second Shift',
                        weekNumberInMonth: (getWeekNumberInMonth(newFormattedDate) === 1 ? `${getWeekNumberInMonth(newFormattedDate)}st Week` :
                            getWeekNumberInMonth(newFormattedDate) === 2 ? `${getWeekNumberInMonth(newFormattedDate)}nd Week` :
                                getWeekNumberInMonth(newFormattedDate) === 3 ? `${getWeekNumberInMonth(newFormattedDate)}rd Week` :
                                    getWeekNumberInMonth(newFormattedDate) > 3 ? `${getWeekNumberInMonth(newFormattedDate)}th Week` : '')
                    }));
                }
            });

            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries)?.map(entry => JSON.parse(entry));

            function sortUserDates(dates) {
                return dates.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);
            const createdUserDates = sortedCreatedUserDates?.filter(d => {
                const filterData = userDates.some(val => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date) => {
                let filteredRowData = resultshiftallot?.filter((val) => val?._doc?.empcode == item?._doc?.empcode);
                const matchingItem = filteredRowData?.find(item => item && item?._doc?.adjdate == date.formattedDate);
                const matchingItemAllot = filteredRowData?.find(item => item && formatDate(item?._doc?.date) == date.formattedDate);
                const matchingDoubleShiftItem = filteredRowData?.find(item => item && item?._doc?.todate === date.formattedDate);
                const matchingRemovedItem = filteredRowData?.find(item => item?._doc?.removedshiftdate === date.formattedDate);
                const matchingAssignShiftItem = filteredRowData?.find(item => item?._doc?.adjdate === date.formattedDate && item?._doc?.adjstatus === 'Approved' && item?._doc?.adjustmenttype === 'Assign Shift');

                const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                    // return item;
                });

                // Remove duplicate entries with the most recent entry
                const uniqueEntriesDep = {};
                item?._doc?.departmentlog?.forEach(entry => {
                    const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                    const key = entry.startdate;
                    if (!(key in uniqueEntriesDep)) {
                        uniqueEntriesDep[key] = entry;
                    }
                });

                const uniqueDepLog = Object.values(uniqueEntriesDep);
                const [columnDay, columnMonth, columnYear] = date.formattedDate?.split('/');
                const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

                // Find the relevant log entry for the given date     
                const relevantDepLogEntry = uniqueDepLog
                    .filter(log => log.startdate <= finalDate)
                    .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item?._doc?.weekoff?.includes(date.dayName);
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                const row = {
                    id: `${item?._doc?._id.toString()}_${date.formattedDate}_${date.shiftMode}`,
                    userid: item?._doc?._id.toString(),
                    company: item?._doc?.company,
                    branch: item?._doc?.branch,
                    unit: item?._doc?.unit,
                    team: item?._doc?.team,
                    department: relevantDepLogEntry && relevantDepLogEntry?.department,
                    username: item?._doc?.companyname,
                    empcode: item?._doc?.empcode,
                    weekoff: item?._doc?.weekoff,
                    boardingLog: item?._doc?.boardingLog,
                    shiftallot: item?._doc?.shiftallot,
                    doj: dojDate,
                    shift: getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                    date: `${date.formattedDate} ${date.dayName} ${date.dayCount}`,
                    role: item?._doc?.role,
                    rowformattedDate: date.formattedDate,
                    dayName: date.dayName,
                    shiftMode: date.shiftMode,
                    rowusername: item?._doc?.username,
                    reasondate: item?._doc?.reasondate,
                    clockin: checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        date.shiftMode,
                    ),
                    clockout: checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        date.shiftMode,
                    ),
                    clockinstatus: checkClockInStatus(
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        graceTime, allLeaveStatus, holidays,
                        checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,), item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname,
                        earlyclockin, lateclockin, afterlateclockin, leavetype, permission,
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    clockoutstatus: checkClockOutStatus(
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        clockOutHours, checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        allLeaveStatus, holidays, item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname, onclockout,
                        earlyclockout, beforeearlyclockout,
                        checkGetClockInAutoStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        leavetype, permission, date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,)
                    ),
                    lateclockincount: lateclockincount,
                    earlyclockoutcount: earlyclockoutcount,
                    ipaddress: getUserIp(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode),
                    weekoffpresentstatus: checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                };

                return row;
            });
            return userRows;

        });

    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finaluser) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ finaluser });
});


exports.getAllUserClockinAndClockoutStatusIndividualFilter = catchAsyncErrors(async (req, res, next) => {
    let allLeaveStatus;
    let permission;
    let resultshiftallot = [];
    let graceTime;
    let clockOutHours;
    let lateclockincount;
    let earlyclockoutcount;
    let onclockout;
    let earlyclockin;
    let earlyclockout;
    let lateclockin;
    let afterlateclockin;
    let beforeearlyclockout;
    let finaluser = [];
    // const { userDates, company, branch, unit, department, employee } = req.body;
    const { userDates, employee } = req.body;

    const formattedUserDates = userDates.map((data) => moment(data.formattedDate, "DD/MM/YYYY").format("DD-MM-YYYY"));

    try {
        const [users, controlcriteria, depMonthSets, attendances, holidays, leavetype] = await Promise.all([
            User.find(
                {
                    //company: { $in: company },
                    //branch: { $in: branch },
                    //unit: { $in: unit },
                    //$or: [
                    //    {
                    //        departmentlog: {
                    //            $elemMatch: {
                    //                department: { $in: department }
                    //            }
                    //        }
                    //    },
                    //    { companyname: { $in: employee } },
                    //],
                    companyname: { $in: employee },
                    enquirystatus: {
                        $nin: ["Enquiry Purpose"],
                    },
                    // resonablestatus: {
                    //     $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                    // },
                    //  $or: [
                    //     { reasondate: { $exists: false } }, // Include if reasondate doesn't exist
                    //    { reasondate: "" },
                    //    { reasondate: { $gte: req.body.fromdate } } 
                    //  ]
                }, {
                company: 1,
                branch: 1,
                unit: 1,
                team: 1,
                department: 1,
                doj: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                floor: 1,
                username: 1,
                designation: 1,
                weekoff: 1,
                shiftallot: 1,
                shifttiming: 1,
                boardingLog: 1,
                attendancemode: 1,
                role: 1,
                reasondate: 1,
                departmentlog: 1,
                attendancemode: 1,
            }
            ),
            ControlCriteria.find(),
            DepartmentMonth.find({}, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 }),
            Attendance.find({
                date: { $in: formattedUserDates },
            }),
            Holiday.find({}, { date: 1, company: 1, applicablefor: 1, unit: 1, team: 1, employee: 1, noofdays: 1 }),
            Leavetype.find({}, { leavetype: 1, code: 1 })
        ])
        const userCds = users.map(user => user.companyname);
        allLeaveStatus = await ApplyLeave.find({ employeename: { $in: userCds } });
        permission = await Permission.find({ employeename: { $in: userCds } }, { employeeid: 1, date: 1, status: 1, applytype: 1, compensationstatus: 1, compensationapplytype: 1, requesthours: 1, shiftmode: 1, });

        // graceTime = controlcriteria[0].gracetime;
        clockOutHours = controlcriteria[0].clockout;
        lateclockincount = controlcriteria[0].lateclockincount;
        earlyclockoutcount = controlcriteria[0].earlyclockoutcount;
        onclockout = controlcriteria[0].onclockout;
        earlyclockin = controlcriteria[0].earlyclockin;
        lateclockin = controlcriteria[0].lateclockin;
        earlyclockout = controlcriteria[0].earlyclockout;
        afterlateclockin = controlcriteria[0].afterlateclockin;
        beforeearlyclockout = controlcriteria[0].afterlateclockin;

        finaluser = users?.flatMap((item, index) => {

            let isEmployeeGrace = controlcriteria[0].todos && controlcriteria[0].todos.find(d => d.company === item.company &&
                d.branch === item.branch && d.unit === item.unit && d.team === item.team &&
                d.employeename === item.companyname
            )

            if (isEmployeeGrace) {
                graceTime = isEmployeeGrace.employeegracetime;
            }
            else {
                graceTime = controlcriteria[0].gracetime;
            }

            item.shiftallot?.map(allot => {
                resultshiftallot.push({ ...allot })
            })

            const filteredMatchingDoubleShiftItem = resultshiftallot?.filter(val => val && val?._doc?.empcode === item?._doc?.empcode && val?._doc?.adjstatus === 'Approved');
            const dojDate = item?._doc?.boardingLog.length > 0 ?
                item?._doc?.boardingLog[0].startdate
                : item?._doc?.doj;

            // Filter out the dates that have matching 'Shift Adjustment' todates
            let removedUserDates = userDates?.filter(date => {
                // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
                const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem.find(item => item && item?._doc?.todate === date.formattedDate && item?._doc?.adjustmenttype === 'Shift Adjustment');

                // If there is no matching 'Shift Adjustment', keep the date
                return !matchingShiftAdjustmentToDate;
            });

            // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
            let uniqueEntries = new Set();

            // Iterate over removedUserDates and add unique entries to the Set
            userDates?.forEach(date => {
                uniqueEntries.add(JSON.stringify({
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    shiftMode: 'Main Shift',
                    weekNumberInMonth: date.weekNumberInMonth
                }));
            });

            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach(item => {
                const [day, month, year] = item._doc.adjdate?.split('/')
                let newFormattedDate = new Date(`${year}-${month}-${day}`);

                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(JSON.stringify({
                        formattedDate: item._doc.adjdate,
                        dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
                        dayCount: parseInt(moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")),
                        shiftMode: 'Second Shift',
                        weekNumberInMonth: (getWeekNumberInMonth(newFormattedDate) === 1 ? `${getWeekNumberInMonth(newFormattedDate)}st Week` :
                            getWeekNumberInMonth(newFormattedDate) === 2 ? `${getWeekNumberInMonth(newFormattedDate)}nd Week` :
                                getWeekNumberInMonth(newFormattedDate) === 3 ? `${getWeekNumberInMonth(newFormattedDate)}rd Week` :
                                    getWeekNumberInMonth(newFormattedDate) > 3 ? `${getWeekNumberInMonth(newFormattedDate)}th Week` : '')
                    }));
                }
            });

            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries)?.map(entry => JSON.parse(entry));
            function sortUserDates(dates) {
                return dates.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);
            const createdUserDates = sortedCreatedUserDates?.filter(d => {
                const filterData = userDates.some(val => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date) => {
                let filteredRowData = resultshiftallot?.filter((val) => val?._doc?.empcode == item?._doc?.empcode);
                const matchingItem = filteredRowData?.find(item => item && item?._doc?.adjdate == date.formattedDate);
                const matchingItemAllot = filteredRowData?.find(item => item && formatDate(item?._doc?.date) == date.formattedDate);
                const matchingDoubleShiftItem = filteredRowData?.find(item => item && item?._doc?.todate === date.formattedDate);
                const matchingRemovedItem = filteredRowData?.find(item => item?._doc?.removedshiftdate === date.formattedDate);
                const matchingAssignShiftItem = filteredRowData?.find(item => item?._doc?.adjdate === date.formattedDate && item?._doc?.adjstatus === 'Approved' && item?._doc?.adjustmenttype === 'Assign Shift');

                const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                    // return item;
                });

                // Remove duplicate entries with the most recent entry
                const uniqueEntriesDep = {};
                item?._doc?.departmentlog?.forEach(entry => {
                    const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                    const key = entry.startdate;
                    if (!(key in uniqueEntriesDep)) {
                        uniqueEntriesDep[key] = entry;
                    }
                });

                const uniqueDepLog = Object.values(uniqueEntriesDep);
                const [columnDay, columnMonth, columnYear] = date.formattedDate?.split('/');
                const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

                // Find the relevant log entry for the given date     
                const relevantDepLogEntry = uniqueDepLog
                    .filter(log => log.startdate <= finalDate)
                    .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

                const depMonthSet = depMonthSets.filter(d => d.department === (relevantDepLogEntry && relevantDepLogEntry?.department))
                const attendance = attendances.filter(d => d.username === item?._doc?.username)

                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item?._doc?.weekoff?.includes(date.dayName);
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                const row = {
                    id: `${item?._doc?._id.toString()}_${date.formattedDate}_${date.shiftMode}`,
                    userid: item?._doc?._id.toString(),
                    company: item?._doc?.company,
                    branch: item?._doc?.branch,
                    unit: item?._doc?.unit,
                    team: item?._doc?.team,
                    department: (relevantDepLogEntry && relevantDepLogEntry?.department),
                    username: item?._doc?.companyname,
                    empcode: item?._doc?.empcode,
                    weekoff: item?._doc?.weekoff,
                    boardingLog: item?._doc?.boardingLog,
                    shiftallot: item?._doc?.shiftallot,
                    doj: dojDate,
                    shift: getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                    date: `${date.formattedDate} ${date.dayName} ${date.dayCount}`,
                    role: item?._doc?.role,
                    rowformattedDate: date.formattedDate,
                    dayName: date.dayName,
                    shiftMode: date.shiftMode,
                    rowusername: item?._doc?.username,
                    reasondate: item?._doc?.reasondate,
                    attendancemode: item?._doc?.attendancemode,
                    clockin: checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        date.shiftMode,
                    ),
                    clockout: checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        date.shiftMode,
                    ),
                    clockinstatus: checkClockInStatus(
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        graceTime, allLeaveStatus, holidays,
                        checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,), item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname,
                        earlyclockin, lateclockin, afterlateclockin, leavetype, permission,
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    clockoutstatus: checkClockOutStatus(
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        clockOutHours, checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        allLeaveStatus, holidays, item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname, onclockout,
                        earlyclockout, beforeearlyclockout,
                        checkGetClockInAutoStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        leavetype, permission, date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,)
                    ),
                    attendanceautostatus: checkAttendanceStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    lateclockincount: lateclockincount,
                    earlyclockoutcount: earlyclockoutcount,
                    ipaddress: getUserIp(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode),
                    weekoffpresentstatus: checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                };

                return row;
            });
            return userRows;

        });

    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finaluser) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ finaluser });
});

exports.getAllUserClockinAndClockoutStatusFilterDateWise = catchAsyncErrors(async (req, res, next) => {
    let allLeaveStatus;
    let resultshiftallot = [];
    let graceTime;
    let clockOutHours;
    let lateclockincount;
    let earlyclockoutcount;
    let onclockout;
    let earlyclockin;
    let earlyclockout;
    let lateclockin;
    let afterlateclockin;
    let beforeearlyclockout;
    let leavetype;
    let permission;
    let finaluser = [];
    //const { userDates, company, branch, unit, team, department, employee } = req.body;
    const { userDates, employee } = req.body;
    const formattedUserDates = userDates.map((data) =>
        moment(data.formattedDate, "DD/MM/YYYY").format("DD-MM-YYYY")
    );

    try {

        let query = {
            //company: { $in: company },
            //branch: { $in: branch },
            //unit: { $in: unit },
            companyname: { $in: employee },
            enquirystatus: {
                $nin: ["Enquiry Purpose"],
            },
        };

        //// If team is provided, include the team in the condition
        //if (team && team.length > 0) {
        //    query.$and = [
        //        { team: { $in: team } },
        //        {
        //            $or: [
        //                {
        //                    departmentlog: {
        //                        $elemMatch: {
        //                            department: { $in: department }
        //                        }
        //                    }
        //                },
        //                { companyname: { $in: employee } }
        //            ]
        //        }
        //    ];
        //} else {
        //    // If team is not provided, just use department or employee condition
        //    query.$or = [
        //        {
        //            departmentlog: {
        //                $elemMatch: {
        //                    department: { $in: department }
        //                }
        //            }
        //        },
        //        { companyname: { $in: employee } }
        //    ];
        //}

        const [users, controlcriteria, depMonthSets, attendances, holidays, leavetype] = await Promise.all([
            User.find(query,
                {
                    company: 1,
                    branch: 1,
                    unit: 1,
                    team: 1,
                    department: 1,
                    doj: 1,
                    dot: 1,
                    empcode: 1,
                    companyname: 1,
                    team: 1,
                    floor: 1,
                    username: 1,
                    designation: 1,
                    weekoff: 1,
                    shiftallot: 1,
                    shifttiming: 1,
                    boardingLog: 1,
                    attendancemode: 1,
                    reasondate: 1,
                    departmentlog: 1,
                }
            ),
            ControlCriteria.find(),
            DepartmentMonth.find({}, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 }),
            Attendance.find({
                date: { $in: formattedUserDates },
            }),
            Holiday.find({}, { date: 1, company: 1, applicablefor: 1, unit: 1, team: 1, employee: 1, noofdays: 1 }),
            Leavetype.find({}, { leavetype: 1, code: 1 })
        ])
        const userCds = users.map(user => user.companyname);
        allLeaveStatus = await ApplyLeave.find({ employeename: { $in: userCds } });
        permission = await Permission.find({ employeename: { $in: userCds } }, { employeeid: 1, date: 1, status: 1, applytype: 1, compensationstatus: 1, compensationapplytype: 1, requesthours: 1, shiftmode: 1, });

        // graceTime = controlcriteria[0].gracetime;
        clockOutHours = controlcriteria[0].clockout;
        lateclockincount = controlcriteria[0].lateclockincount;
        earlyclockoutcount = controlcriteria[0].earlyclockoutcount;
        onclockout = controlcriteria[0].onclockout;
        earlyclockin = controlcriteria[0].earlyclockin;
        lateclockin = controlcriteria[0].lateclockin;
        earlyclockout = controlcriteria[0].earlyclockout;
        afterlateclockin = controlcriteria[0].afterlateclockin;
        beforeearlyclockout = controlcriteria[0].afterlateclockin;

        finaluser = users?.flatMap((item, index) => {

            let isEmployeeGrace = controlcriteria[0].todos && controlcriteria[0].todos.find(d => d.company === item.company &&
                d.branch === item.branch && d.unit === item.unit && d.team === item.team &&
                d.employeename === item.companyname
            )

            if (isEmployeeGrace) {
                graceTime = isEmployeeGrace.employeegracetime;
            }
            else {
                graceTime = controlcriteria[0].gracetime;
            }

            const filteredMatchingDoubleShiftItem = item.shiftallot?.filter(val => val && val?._doc?.empcode === item?._doc?.empcode && val?._doc?.adjstatus === 'Approved');
            const dojDate = item?._doc?.boardingLog.length > 0 ?
                item?._doc?.boardingLog[0].startdate
                : item?._doc?.doj;

            // Filter out the dates that have matching 'Shift Adjustment' todates
            let removedUserDates = userDates?.filter(date => {

                // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
                const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem.find(item => item && item?._doc?.todate === date.formattedDate && item?._doc?.adjustmenttype === 'Shift Adjustment');
                // If there is no matching 'Shift Adjustment', keep the date
                return !matchingShiftAdjustmentToDate;
            });

            // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
            let uniqueEntries = new Set();

            // Iterate over removedUserDates and add unique entries to the Set
            userDates.forEach(date => {
                uniqueEntries.add(JSON.stringify({
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    shiftMode: 'Main Shift',
                    weekNumberInMonth: date.weekNumberInMonth
                }));
            });

            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach(item => {
                const [day, month, year] = item._doc.adjdate?.split('/')
                let newFormattedDate = new Date(`${year}-${month}-${day}`);
                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(JSON.stringify({
                        formattedDate: item._doc.adjdate,
                        dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
                        dayCount: parseInt(moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")),
                        shiftMode: 'Second Shift',
                        weekNumberInMonth: (getWeekNumberInMonth(newFormattedDate) === 1 ? `${getWeekNumberInMonth(newFormattedDate)}st Week` :
                            getWeekNumberInMonth(newFormattedDate) === 2 ? `${getWeekNumberInMonth(newFormattedDate)}nd Week` :
                                getWeekNumberInMonth(newFormattedDate) === 3 ? `${getWeekNumberInMonth(newFormattedDate)}rd Week` :
                                    getWeekNumberInMonth(newFormattedDate) > 3 ? `${getWeekNumberInMonth(newFormattedDate)}th Week` : '')
                    }));
                }
            });

            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries)?.map(entry => JSON.parse(entry));

            function sortUserDates(dates) {
                return dates.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);
            const createdUserDates = sortedCreatedUserDates?.filter(d => {
                const filterData = userDates.some(val => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date) => {
                let filteredRowData = item?._doc?.shiftallot?.filter((val) => val?._doc?.empcode == item?._doc?.empcode);
                const matchingItem = filteredRowData?.find(item => item && item?._doc?.adjdate == date.formattedDate);
                const matchingItemAllot = filteredRowData?.find(item => item && formatDate(item?._doc?.date) == date.formattedDate);
                const matchingDoubleShiftItem = filteredRowData?.find(item => item && item?._doc?.todate === date.formattedDate);
                const matchingRemovedItem = filteredRowData?.find(item => item?._doc?.removedshiftdate === date.formattedDate);
                const matchingAssignShiftItem = filteredRowData?.find(item => item?._doc?.adjdate === date.formattedDate && item?._doc?.adjstatus === 'Approved' && item?._doc?.adjustmenttype === 'Assign Shift');

                const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                    // return item;
                });

                // Remove duplicate entries with the most recent entry
                const uniqueEntriesDep = {};
                item?._doc?.departmentlog?.forEach(entry => {
                    const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                    const key = entry.startdate;
                    if (!(key in uniqueEntriesDep)) {
                        uniqueEntriesDep[key] = entry;
                    }
                });

                const uniqueDepLog = Object.values(uniqueEntriesDep);
                const [columnDay, columnMonth, columnYear] = date.formattedDate?.split('/');
                const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

                // Find the relevant log entry for the given date     
                const relevantDepLogEntry = uniqueDepLog
                    .filter(log => log.startdate <= finalDate)
                    .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

                const depMonthSet = depMonthSets.filter(d => d.department === (relevantDepLogEntry && relevantDepLogEntry?.department))
                const attendance = attendances.filter(d => d.username === item?._doc?.username)

                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item?._doc?.weekoff?.includes(date.dayName);
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                const row = {
                    id: `${item?._doc?._id.toString()}_${date.formattedDate}_${date.shiftMode}`,
                    userid: item?._doc?._id.toString(),
                    company: item?._doc?.company,
                    branch: item?._doc?.branch,
                    unit: item?._doc?.unit,
                    team: item?._doc?.team,
                    department: (relevantDepLogEntry && relevantDepLogEntry?.department),
                    username: item?._doc?.companyname,
                    empcode: item?._doc?.empcode,
                    boardingLog: item?._doc?.boardingLog,
                    shiftallot: item?._doc?.shiftallot,
                    doj: dojDate,
                    shift: getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                    date: `${date.formattedDate} ${date.dayName} ${date.dayCount}`,
                    rowformattedDate: date.formattedDate,
                    dayName: date.dayName,
                    shiftMode: date.shiftMode,
                    reasondate: item?._doc?.reasondate,
                    weekoff: item?._doc?.weekoff,
                    clockin: checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        date.shiftMode,
                    ),
                    clockout: checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        date.shiftMode,
                    ),
                    clockinstatus: checkClockInStatus(
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        graceTime, allLeaveStatus, holidays,
                        checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,), item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname,
                        earlyclockin, lateclockin, afterlateclockin, leavetype, permission,
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    clockoutstatus: checkClockOutStatus(
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        clockOutHours, checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        allLeaveStatus, holidays, item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname, onclockout,
                        earlyclockout, beforeearlyclockout,
                        checkGetClockInAutoStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        leavetype, permission, date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,)
                    ),
                    lateclockincount: lateclockincount,
                    earlyclockoutcount: earlyclockoutcount,
                    attendanceautostatus: checkAttendanceStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    weekoffpresentstatus: checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                };

                return row;
            });
            return userRows;
        });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    if (!finaluser) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ finaluser });
}
);

exports.getAllUserClockinAndClockoutStatusLeave = catchAsyncErrors(async (req, res, next) => {

    let finaluser = [];

    const { userDates } = req.body;

    try {
        const [users, depMonthSet] = await Promise.all([
            User.find(
                {
                    $or: [
                        { empcode: req.body.empcode },
                        { companyname: req.body.companyname }
                    ],

                    resonablestatus: {
                        $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                    },
                }, {
                company: 1,
                branch: 1,
                unit: 1,
                team: 1,
                department: 1,
                doj: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                floor: 1,
                username: 1,
                designation: 1,
                weekoff: 1,
                shiftallot: 1,
                shifttiming: 1,
                boardingLog: 1,
                attendancemode: 1,
                departmentlog: 1,
            }
            ),
            DepartmentMonth.find({}, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 }),
        ])

        const beforefinaluser = users?.flatMap((item, index) => {

            const filteredMatchingDoubleShiftItem = item.shiftallot?.filter(val => val && val?._doc?.empcode === item?._doc?.empcode && val?._doc?.adjstatus === 'Approved');
            const dojDate = item?._doc?.boardingLog.length > 0 ?
                item?._doc?.boardingLog[0].startdate
                : item?._doc?.doj;

            // Filter out the dates that have matching 'Shift Adjustment' todates
            let removedUserDates = userDates?.filter(date => {
                // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
                const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem.find(item => item && item?._doc?.todate === date.formattedDate && item?._doc?.adjustmenttype === 'Shift Adjustment');

                // If there is no matching 'Shift Adjustment', keep the date
                return !matchingShiftAdjustmentToDate;
            });

            // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
            let uniqueEntries = new Set();

            // Iterate over removedUserDates and add unique entries to the Set
            userDates?.forEach(date => {
                uniqueEntries.add(JSON.stringify({
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    shiftMode: 'Main Shift',
                    weekNumberInMonth: date.weekNumberInMonth
                }));
            });

            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach(item => {
                const [day, month, year] = item._doc.adjdate?.split('/')
                let newFormattedDate = new Date(`${year}-${month}-${day}`);

                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(JSON.stringify({
                        formattedDate: item._doc.adjdate,
                        dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
                        dayCount: parseInt(moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")),
                        shiftMode: 'Second Shift',
                        weekNumberInMonth: (getWeekNumberInMonth(newFormattedDate) === 1 ? `${getWeekNumberInMonth(newFormattedDate)}st Week` :
                            getWeekNumberInMonth(newFormattedDate) === 2 ? `${getWeekNumberInMonth(newFormattedDate)}nd Week` :
                                getWeekNumberInMonth(newFormattedDate) === 3 ? `${getWeekNumberInMonth(newFormattedDate)}rd Week` :
                                    getWeekNumberInMonth(newFormattedDate) > 3 ? `${getWeekNumberInMonth(newFormattedDate)}th Week` : '')
                    }));
                }
            });

            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries)?.map(entry => JSON.parse(entry));

            function sortUserDates(dates) {
                return dates.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);
            const createdUserDates = sortedCreatedUserDates?.filter(d => {
                const filterData = userDates.some(val => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date) => {

                const matchingItem = item.shiftallot?.find(item => item && item?._doc?.adjdate == date.formattedDate);
                const matchingItemAllot = item.shiftallot?.find(item => item && formatDate(item?._doc?.date) == date.formattedDate);
                const matchingDoubleShiftItem = item.shiftallot?.find(item => item && item?._doc?.todate === date.formattedDate);
                const matchingRemovedItem = item.shiftallot?.find(item => item?._doc?.removedshiftdate === date.formattedDate);
                const matchingAssignShiftItem = item.shiftallot?.find(item => item?._doc?.adjdate === date.formattedDate && item?._doc?.adjstatus === 'Approved' && item?._doc?.adjustmenttype === 'Assign Shift');

                const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                });

                // Remove duplicate entries with the most recent entry
                const uniqueEntriesDep = {};
                item?._doc?.departmentlog?.forEach(entry => {
                    const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                    const key = entry.startdate;
                    if (!(key in uniqueEntriesDep)) {
                        uniqueEntriesDep[key] = entry;
                    }
                });

                const uniqueDepLog = Object.values(uniqueEntriesDep);
                const [columnDay, columnMonth, columnYear] = date.formattedDate?.split('/');
                const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

                // Find the relevant log entry for the given date     
                const relevantDepLogEntry = uniqueDepLog
                    .filter(log => log.startdate <= finalDate)
                    .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item?._doc?.weekoff?.includes(date.dayName);
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                const row = {
                    shift: getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                    formattedDate: date.formattedDate,
                    doj: dojDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    weekNumberInMonth: date.weekNumberInMonth,
                    shiftMode: date.shiftMode,
                    leavestatus: '',
                    shiftcount: '',
                    department: (relevantDepLogEntry && relevantDepLogEntry?.department),
                };
                return row;
            });
            return userRows;
        });
        finaluser = [...new Set(beforefinaluser)]
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finaluser) {
        return next(new ErrorHandler("Users not found", 400));
    }
    return res.status(200).json({ finaluser });
});
exports.getAllUserClockinAndClockoutStatusLogin = catchAsyncErrors(async (req, res, next) => {

    let finaluser = [];

    const { userDates } = req.body;

    try {
        const [users, depMonthSet] = await Promise.all([
            User.find(
                {
                    companyname: req.body.companyname,
                    resonablestatus: {
                        $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                    },
                }, {
                company: 1,
                branch: 1,
                unit: 1,
                team: 1,
                department: 1,
                doj: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                floor: 1,
                username: 1,
                designation: 1,
                weekoff: 1,
                shiftallot: 1,
                shifttiming: 1,
                boardingLog: 1,
                attendancemode: 1,
                departmentlog: 1,
            }
            ),
            DepartmentMonth.find({}, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 }),
        ])
        const beforefinaluser = users?.flatMap((item, index) => {

            const filteredMatchingDoubleShiftItem = item.shiftallot?.filter(val => val && val?._doc?.empcode === item?._doc?.empcode && val?._doc?.adjstatus === 'Approved');
            const dojDate = item?._doc?.boardingLog.length > 0 ?
                item?._doc?.boardingLog[0].startdate
                : item?._doc?.doj;

            // Filter out the dates that have matching 'Shift Adjustment' todates
            let removedUserDates = userDates?.filter(date => {
                // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
                const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem.find(item => item && item?._doc?.todate === date.formattedDate && item?._doc?.adjustmenttype === 'Shift Adjustment');

                // If there is no matching 'Shift Adjustment', keep the date
                return !matchingShiftAdjustmentToDate;
            });

            // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
            let uniqueEntries = new Set();

            // Iterate over removedUserDates and add unique entries to the Set
            userDates?.forEach(date => {
                uniqueEntries.add(JSON.stringify({
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    shiftMode: 'Main Shift',
                    weekNumberInMonth: date.weekNumberInMonth
                }));
            });

            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach(item => {
                const [day, month, year] = item._doc.adjdate?.split('/')
                let newFormattedDate = new Date(`${year}-${month}-${day}`);

                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(JSON.stringify({
                        formattedDate: item._doc.adjdate,
                        dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
                        dayCount: parseInt(moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")),
                        shiftMode: 'Second Shift',
                        weekNumberInMonth: (getWeekNumberInMonth(newFormattedDate) === 1 ? `${getWeekNumberInMonth(newFormattedDate)}st Week` :
                            getWeekNumberInMonth(newFormattedDate) === 2 ? `${getWeekNumberInMonth(newFormattedDate)}nd Week` :
                                getWeekNumberInMonth(newFormattedDate) === 3 ? `${getWeekNumberInMonth(newFormattedDate)}rd Week` :
                                    getWeekNumberInMonth(newFormattedDate) > 3 ? `${getWeekNumberInMonth(newFormattedDate)}th Week` : '')
                    }));
                }
            });

            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries)?.map(entry => JSON.parse(entry));

            function sortUserDates(dates) {
                return dates.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);
            const createdUserDates = sortedCreatedUserDates?.filter(d => {
                const filterData = userDates.some(val => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date) => {

                const matchingItem = item.shiftallot?.find(item => item && item?._doc?.adjdate == date.formattedDate);
                const matchingItemAllot = item.shiftallot?.find(item => item && formatDate(item?._doc?.date) == date.formattedDate);
                const matchingDoubleShiftItem = item.shiftallot?.find(item => item && item?._doc?.todate === date.formattedDate);
                const matchingRemovedItem = item.shiftallot?.find(item => item?._doc?.removedshiftdate === date.formattedDate);
                const matchingAssignShiftItem = item.shiftallot?.find(item => item?._doc?.adjdate === date.formattedDate && item?._doc?.adjstatus === 'Approved' && item?._doc?.adjustmenttype === 'Assign Shift');

                const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                    // return item;
                });

                // Remove duplicate entries with the most recent entry
                const uniqueEntriesDep = {};
                item?._doc?.departmentlog?.forEach(entry => {
                    const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                    const key = entry.startdate;
                    if (!(key in uniqueEntriesDep)) {
                        uniqueEntriesDep[key] = entry;
                    }
                });

                const uniqueDepLog = Object.values(uniqueEntriesDep);
                const [columnDay, columnMonth, columnYear] = date.formattedDate?.split('/');
                const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

                // Find the relevant log entry for the given date     
                const relevantDepLogEntry = uniqueDepLog
                    .filter(log => log.startdate <= finalDate)
                    .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item?._doc?.weekoff?.includes(date.dayName);
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                const row = {
                    shift: getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                    formattedDate: date.formattedDate,
                    doj: dojDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    weekNumberInMonth: date.weekNumberInMonth,
                    shiftMode: date.shiftMode,
                    leavestatus: '',
                    shiftcount: '',
                };
                return row;
            });
            return userRows;
        });
        finaluser = [...new Set(beforefinaluser)]
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finaluser) {
        return next(new ErrorHandler("Users not found", 400));
    }
    return res.status(200).json({ finaluser });
});

exports.getAllUserClockinAndClockoutStatusMyIndividual = catchAsyncErrors(async (req, res, next) => {
    let allLeaveStatus;
    let resultshiftallot = [];
    let graceTime;
    let clockOutHours;
    let lateclockincount;
    let earlyclockoutcount;
    let onclockout;
    let earlyclockin;
    let earlyclockout;
    let lateclockin;
    let afterlateclockin;
    let beforeearlyclockout;
    let permission;
    let finaluser = [];
    const { userDates } = req.body;

    const formattedUserDates = userDates.map((data) => moment(data.formattedDate, "DD/MM/YYYY").format("DD-MM-YYYY"));

    try {
        const [users, controlcriteria, depMonthSet, attendance, holidays, leavetype] = await Promise.all([
            User.find(
                {
                    companyname: req.body.username,
                    empcode: req.body.empcode,
                }, {
                company: 1,
                branch: 1,
                unit: 1,
                team: 1,
                department: 1,
                doj: 1,
                dot: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                floor: 1,
                username: 1,
                designation: 1,
                weekoff: 1,
                shiftallot: 1,
                shifttiming: 1,
                boardingLog: 1,
                attendancemode: 1,
                role: 1,
                reasondate: 1,
                departmentlog: 1,
            }
            ),
            ControlCriteria.find(),
            DepartmentMonth.find({}, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 }),
            Attendance.find({
                date: { $in: formattedUserDates },
            }),
            Holiday.find({}, { date: 1, company: 1, applicablefor: 1, unit: 1, team: 1, employee: 1, noofdays: 1 }),
            Leavetype.find({}, { leavetype: 1, code: 1 })
        ])
        const userCds = users.map(user => user.companyname);
        allLeaveStatus = await ApplyLeave.find({ employeename: { $in: userCds } });
        permission = await Permission.find({ employeename: { $in: userCds } }, { employeeid: 1, date: 1, status: 1, applytype: 1, compensationstatus: 1, compensationapplytype: 1, requesthours: 1, shiftmode: 1, });

        // graceTime = controlcriteria[0].gracetime;
        clockOutHours = controlcriteria[0].clockout;
        lateclockincount = controlcriteria[0].lateclockincount;
        earlyclockoutcount = controlcriteria[0].earlyclockoutcount;
        onclockout = controlcriteria[0].onclockout;
        earlyclockin = controlcriteria[0].earlyclockin;
        lateclockin = controlcriteria[0].lateclockin;
        earlyclockout = controlcriteria[0].earlyclockout;
        afterlateclockin = controlcriteria[0].afterlateclockin;
        beforeearlyclockout = controlcriteria[0].afterlateclockin;

        finaluser = users?.flatMap((item, index) => {

            let isEmployeeGrace = controlcriteria[0].todos && controlcriteria[0].todos.find(d => d.company === item.company &&
                d.branch === item.branch && d.unit === item.unit && d.team === item.team &&
                d.employeename === item.companyname
            )

            if (isEmployeeGrace) {
                graceTime = isEmployeeGrace.employeegracetime;
            }
            else {
                graceTime = controlcriteria[0].gracetime;
            }

            item.shiftallot?.map(allot => {
                resultshiftallot.push({ ...allot })
            })

            const filteredMatchingDoubleShiftItem = resultshiftallot?.filter(val => val && val?._doc?.empcode === item?._doc?.empcode && val?._doc?.adjstatus === 'Approved');
            const dojDate = item?._doc?.boardingLog.length > 0 ?
                item?._doc?.boardingLog[0].startdate
                : item?._doc?.doj;

            // Filter out the dates that have matching 'Shift Adjustment' todates
            let removedUserDates = userDates?.filter(date => {
                // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
                const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem.find(item => item && item?._doc?.todate === date.formattedDate && item?._doc?.adjustmenttype === 'Shift Adjustment');

                // If there is no matching 'Shift Adjustment', keep the date
                return !matchingShiftAdjustmentToDate;
            });

            // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
            let uniqueEntries = new Set();

            // Iterate over removedUserDates and add unique entries to the Set
            userDates?.forEach(date => {
                uniqueEntries.add(JSON.stringify({
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    shiftMode: 'Main Shift',
                    weekNumberInMonth: date.weekNumberInMonth
                }));
            });

            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach(item => {
                const [day, month, year] = item._doc.adjdate?.split('/')
                let newFormattedDate = new Date(`${year}-${month}-${day}`);

                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(JSON.stringify({
                        formattedDate: item._doc.adjdate,
                        dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
                        dayCount: parseInt(moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")),
                        shiftMode: 'Second Shift',
                        weekNumberInMonth: (getWeekNumberInMonth(newFormattedDate) === 1 ? `${getWeekNumberInMonth(newFormattedDate)}st Week` :
                            getWeekNumberInMonth(newFormattedDate) === 2 ? `${getWeekNumberInMonth(newFormattedDate)}nd Week` :
                                getWeekNumberInMonth(newFormattedDate) === 3 ? `${getWeekNumberInMonth(newFormattedDate)}rd Week` :
                                    getWeekNumberInMonth(newFormattedDate) > 3 ? `${getWeekNumberInMonth(newFormattedDate)}th Week` : '')
                    }));
                }
            });

            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries)?.map(entry => JSON.parse(entry));

            function sortUserDates(dates) {
                return dates.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);
            const createdUserDates = sortedCreatedUserDates?.filter(d => {
                const filterData = userDates.some(val => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date) => {
                let filteredRowData = resultshiftallot?.filter((val) => val?._doc?.empcode == item?._doc?.empcode);
                const matchingItem = filteredRowData?.find(item => item && item?._doc?.adjdate == date.formattedDate);
                const matchingItemAllot = filteredRowData?.find(item => item && formatDate(item?._doc?.date) == date.formattedDate);
                const matchingDoubleShiftItem = filteredRowData?.find(item => item && item?._doc?.todate === date.formattedDate);
                const matchingRemovedItem = filteredRowData?.find(item => item?._doc?.removedshiftdate === date.formattedDate);
                const matchingAssignShiftItem = filteredRowData?.find(item => item?._doc?.adjdate === date.formattedDate && item?._doc?.adjstatus === 'Approved' && item?._doc?.adjustmenttype === 'Assign Shift');

                const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                    // return item;
                });

                // Remove duplicate entries with the most recent entry
                const uniqueEntriesDep = {};
                item?._doc?.departmentlog?.forEach(entry => {
                    const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                    const key = entry.startdate;
                    if (!(key in uniqueEntriesDep)) {
                        uniqueEntriesDep[key] = entry;
                    }
                });

                const uniqueDepLog = Object.values(uniqueEntriesDep);
                const [columnDay, columnMonth, columnYear] = date.formattedDate?.split('/');
                const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

                // Find the relevant log entry for the given date     
                const relevantDepLogEntry = uniqueDepLog
                    .filter(log => log.startdate <= finalDate)
                    .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item?._doc?.weekoff?.includes(date.dayName);
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                const row = {
                    id: `${item?._doc?._id.toString()}_${date.formattedDate}_${date.shiftMode}`,
                    userid: item?._doc?._id.toString(),
                    company: item?._doc?.company,
                    branch: item?._doc?.branch,
                    unit: item?._doc?.unit,
                    team: item?._doc?.team,
                    department: relevantDepLogEntry && relevantDepLogEntry?.department,
                    username: item?._doc?.companyname,
                    empcode: item?._doc?.empcode,
                    weekoff: item?._doc?.weekoff,
                    boardingLog: item?._doc?.boardingLog,
                    shiftallot: item?._doc?.shiftallot,
                    doj: dojDate,
                    shift: getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                    date: `${date.formattedDate} ${date.dayName} ${date.dayCount}`,
                    role: item?._doc?.role,
                    rowformattedDate: date.formattedDate,
                    dayName: date.dayName,
                    shiftMode: date.shiftMode,
                    rowusername: item?._doc?.username,
                    reasondate: item?._doc?.reasondate,
                    clockin: checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        date.shiftMode,
                    ),
                    clockout: checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        date.shiftMode,
                    ),
                    clockinstatus: checkClockInStatus(
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        graceTime, allLeaveStatus, holidays,
                        checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,), item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname,
                        earlyclockin, lateclockin, afterlateclockin, leavetype, permission,
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    clockoutstatus: checkClockOutStatus(
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        clockOutHours, checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        allLeaveStatus, holidays, item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname, onclockout,
                        earlyclockout, beforeearlyclockout,
                        checkGetClockInAutoStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        leavetype, permission, date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    attendanceautostatus: checkAttendanceStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    lateclockincount: lateclockincount,
                    earlyclockoutcount: earlyclockoutcount,
                    ipaddress: getUserIp(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode),
                    weekoffpresentstatus: checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                };

                return row;
            });
            return userRows;

        });

    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finaluser) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ finaluser });
});

exports.getAllUserClockinAndClockoutStatusIndividualHierarchyFilterChange = catchAsyncErrors(async (req, res, next) => {
    let result,
        hierarchy,
        resultAccessFilter,
        secondaryhierarchyfinal,
        tertiaryhierarchyfinal,
        primaryhierarchyfinal,
        hierarchyfilter,
        filteredoverall = [],
        reportingtobaseduser,
        primaryhierarchy,
        hierarchyfilter1,
        secondaryhierarchy,
        hierarchyfilter2,
        tertiaryhierarchy,
        primaryhierarchyall,
        secondaryhierarchyall,
        tertiaryhierarchyall,
        userbranch,
        hierarchySecond,
        overallMyallList,
        hierarchyMap,
        resulted = [],
        resultedTeam = [],
        myallTotalNames,
        hierarchyFinal,
        hierarchyDefault;

    const { company, branch, listpageaccessmode } = req.body;

    try {
        let levelFinal = req.body?.sector === "all" ? ["Primary", "Secondary", "Tertiary"] : [req.body?.sector]
        let answer = await Hirerarchi.aggregate([
            {
                $match: {
                    supervisorchoose:
                        req?.body?.username, // Match supervisorchoose with username
                    level: { $in: levelFinal } // Corrected unmatched quotation mark
                }
            },
            {
                $lookup: {
                    from: "reportingheaders",
                    let: {
                        teamControlsArray: {
                            $ifNull: ["$pagecontrols", []]
                        }
                    },
                    pipeline: [
                        {
                            $match: {
                                $expr: {
                                    $and: [
                                        {
                                            $in: [
                                                "$name",
                                                "$$teamControlsArray"
                                            ]
                                        }, // Check if 'name' is in 'teamcontrols' array
                                        {
                                            $in: [
                                                req?.body?.pagename,
                                                "$reportingnew" // Check if 'menuteamloginstatus' is in 'reportingnew' array
                                            ]
                                        } // Additional condition for reportingnew array
                                    ]
                                }
                            }
                        }
                    ],
                    as: "reportData" // The resulting matched documents will be in this field
                }
            },
            {
                $project: {
                    supervisorchoose: 1,
                    employeename: 1,
                    reportData: 1
                }
            }
        ]);
        let restrictList = answer?.filter(data => data?.reportData?.length > 0)?.flatMap(Data => Data?.employeename)

        const [users,] = await Promise.all([
            User.find(
                {
                    enquirystatus: {
                        $nin: ["Enquiry Purpose"],
                    },
                    resonablestatus: {
                        $nin: [
                            "Not Joined",
                            "Postponed",
                            "Rejected",
                            "Closed",
                            "Releave Employee",
                            "Absconded",
                            "Hold",
                            "Terminate",
                        ],
                    },
                    ...(listpageaccessmode === "Reporting to Based"
                        ? { reportingto: req.body.username }
                        : {}),
                },
                {
                    company: 1,
                    branch: 1,
                    unit: 1,
                    team: 1,
                    department: 1,
                    doj: 1,
                    dot: 1,
                    empcode: 1,
                    companyname: 1,
                    team: 1,
                    floor: 1,
                    username: 1,
                    designation: 1,
                    weekoff: 1,
                    shiftallot: 1,
                    shifttiming: 1,
                    boardingLog: 1,
                    role: 1,
                    _id: 1,
                    reasondate: 1,
                    departmentlog: 1, attendancemode: 1
                }
            ),
        ]);

        //myhierarchy dropdown
        if (
            ((req.body.hierachy === "My Hierarchy List" || req.body.hierachy === "All Hierarchy List") &&
                listpageaccessmode === "Hierarchy Based") ||
            listpageaccessmode === "Overall"
        ) {
            hierarchy = await Hirerarchi.find({
                supervisorchoose: req.body.username,
                level: req.body.sector,
            });
            hierarchyDefault = await Hirerarchi.find({
                supervisorchoose: req.body.username,
            });

            let answerDef = hierarchyDefault.map((data) => data.employeename);
            hierarchyFinal =
                req.body.sector === "all"
                    ? answerDef.length > 0
                        ? [].concat(...answerDef)
                        : []
                    : hierarchy.length > 0
                        ? [].concat(...hierarchy.map((item) => item.employeename))
                        : [];
            hierarchyMap = hierarchyFinal.length > 0 ? hierarchyFinal : [];

            hierarchyfilter = await Hirerarchi.find({
                supervisorchoose: req.body.username,
                level: "Primary",
            });
            primaryhierarchy = hierarchyfilter.map((item) => item.employeename[0])
                ? hierarchyfilter.map((item) => item.employeename[0])
                : [];

            hierarchyfilter1 = await Hirerarchi.find({
                supervisorchoose: req.body.username,
                level: "Secondary",
            });
            secondaryhierarchy = hierarchyfilter1.map(
                (item) => item.employeename[0]
            )
                ? hierarchyfilter1.map((item) => item.employeename[0])
                : [];

            hierarchyfilter2 = await Hirerarchi.find({
                supervisorchoose: req.body.username,
                level: "Tertiary",
            });
            tertiaryhierarchy = hierarchyfilter2.map((item) => item.employeename[0])
                ? hierarchyfilter2.map((item) => item.employeename[0])
                : [];

            resulted = users
                .map((userObj) => {
                    const matchingHierarchy = hierarchyDefault.find(
                        (hierarchyObj) =>
                            hierarchyObj.employeename[0] == userObj.companyname
                    );
                    return {
                        companyname: userObj.companyname,
                        unit: userObj.unit,
                        department: userObj.department,
                        team: userObj.team,
                        branch: userObj.branch,
                        doj: userObj.doj,
                        dot: userObj.dot,
                        empcode: userObj.empcode,
                        floor: userObj.floor,
                        designation: userObj.designation,
                        shiftallot: userObj.shiftallot,
                        shifttiming: userObj.shifttiming,
                        boardingLog: userObj.boardingLog,
                        role: userObj.role,
                        weekoff: userObj.weekoff,
                        company: userObj.company,
                        username: userObj.username,
                        _id: userObj._id,
                        control: matchingHierarchy ? matchingHierarchy.control : "",
                    };
                })
                .filter((data) => hierarchyMap.includes(data.companyname));
        }

        if (
            ((req.body.hierachy === "My Hierarchy List" || req.body.hierachy === "All Hierarchy List") &&
                listpageaccessmode === "Hierarchy Based") ||
            listpageaccessmode === "Overall"
        ) {
            hierarchySecond = await Hirerarchi.find(
                {},
                { employeename: 1, supervisorchoose: 1, level: 1, control: 1 }
            );
            hierarchyDefault = await Hirerarchi.find({
                supervisorchoose: req.body.username,
            });

            let answerDef = hierarchyDefault
                .map((data) => data.employeename)
                .flat();

            function findEmployeesRecursive(
                currentSupervisors,
                processedSupervisors,
                users
            ) {
                const filteredData = hierarchySecond.filter((item) =>
                    item.supervisorchoose.some(
                        (supervisor) =>
                            currentSupervisors.includes(supervisor) &&
                            !processedSupervisors.has(supervisor)
                    )
                );

                if (filteredData.length === 0) {
                    return users;
                }

                const newEmployees = filteredData.reduce((employees, item) => {
                    employees.push(...item.employeename);
                    processedSupervisors.add(item.supervisorchoose[0]); // Assuming each item has only one supervisorchoose
                    return employees;
                }, []);

                const uniqueNewEmployees = [...new Set(newEmployees)];
                users = [...users, ...filteredData];

                return findEmployeesRecursive(
                    uniqueNewEmployees,
                    processedSupervisors,
                    users
                );
            }

            const processedSupervisors = new Set();
            const filteredOverallItem = findEmployeesRecursive(
                answerDef,
                processedSupervisors,
                []
            );
            let answerDeoverall = filteredOverallItem
                .filter((data) =>
                    req.body.sector == "all"
                        ? ["Primary", "Secondary", "Tertiary"].includes(data.level)
                        : data.level == req.body.sector
                )
                .map((item) => item.employeename[0]);

            resultedTeam = users
                .map((userObj) => {
                    const matchingHierarchycontrol = filteredOverallItem.find(
                        (hierarchyObj) =>
                            hierarchyObj.employeename[0] == userObj.companyname
                    );
                    return {
                        companyname: userObj.companyname,
                        unit: userObj.unit,
                        department: userObj.department,
                        team: userObj.team,
                        branch: userObj.branch,
                        doj: userObj.doj,
                        dot: userObj.dot,
                        empcode: userObj.empcode,
                        floor: userObj.floor,
                        designation: userObj.designation,
                        shiftallot: userObj.shiftallot,
                        shifttiming: userObj.shifttiming,
                        boardingLog: userObj.boardingLog,
                        role: userObj.role,
                        weekoff: userObj.weekoff,
                        company: userObj.company,
                        username: userObj.username,
                        _id: userObj._id,
                        level: matchingHierarchycontrol
                            ? matchingHierarchycontrol.level
                            : "",
                        control: matchingHierarchycontrol
                            ? matchingHierarchycontrol.control
                            : "",
                    };
                })
                .filter((data) => answerDeoverall.includes(data.companyname));

            let hierarchyallfinal = await Hirerarchi.find({
                employeename: { $in: answerDeoverall.map((item) => item) },
                level: req.body.sector,
            });
            hierarchyFinal =
                req.body.sector === "all"
                    ? answerDeoverall.length > 0
                        ? [].concat(...answerDeoverall)
                        : []
                    : hierarchyallfinal.length > 0
                        ? [].concat(...hierarchyallfinal.map((item) => item.employeename))
                        : [];

            primaryhierarchyall = resultedTeam
                .filter((item) => item.level == "Primary")
                .map((item) => item.companyname);

            secondaryhierarchyall = resultedTeam
                .filter((item) => item.level == "Secondary")
                .map((item) => item.companyname);

            tertiaryhierarchyall = resultedTeam
                .filter((item) => item.level == "Tertiary")
                .map((item) => item.companyname);
        }

        //my + all hierarchy list dropdown
        if (
            ((req.body.hierachy === "My Hierarchy List" || req.body.hierachy === "All Hierarchy List" || req.body.hierachy === "My + All Hierarchy List") &&
                listpageaccessmode === "Hierarchy Based") ||
            listpageaccessmode === "Overall"
        ) {
            hierarchySecond = await Hirerarchi.find(
                {},
                { employeename: 1, supervisorchoose: 1, level: 1, control: 1 }
            );
            hierarchyDefault = await Hirerarchi.find({
                supervisorchoose: req.body.username,
            });

            let answerDef = hierarchyDefault.map((data) => data.employeename);

            function findEmployeesRecursive(
                currentSupervisors,
                processedSupervisors,
                users
            ) {
                const filteredData = hierarchySecond.filter((item) =>
                    item.supervisorchoose.some(
                        (supervisor) =>
                            currentSupervisors.includes(supervisor) &&
                            !processedSupervisors.has(supervisor)
                    )
                );

                if (filteredData.length === 0) {
                    return users;
                }

                const newEmployees = filteredData.reduce((employees, item) => {
                    employees.push(...item.employeename);
                    processedSupervisors.add(item.supervisorchoose[0]); // Assuming each item has only one supervisorchoose
                    return employees;
                }, []);

                const uniqueNewEmployees = [...new Set(newEmployees)];
                users = [...users, ...filteredData];

                return findEmployeesRecursive(
                    uniqueNewEmployees,
                    processedSupervisors,
                    users
                );
            }

            const processedSupervisors = new Set();
            const filteredOverallItem = findEmployeesRecursive(
                [req.body.username],
                processedSupervisors,
                []
            );
            let answerDeoverall = filteredOverallItem
                .filter((data) =>
                    req.body.sector == "all"
                        ? ["Primary", "Secondary", "Tertiary"].includes(data.level)
                        : data.level == req.body.sector
                )
                .map((item) => item.employeename[0]);

            filteredoverall = users
                .map((userObj) => {
                    const matchingHierarchycontrol = filteredOverallItem.find(
                        (hierarchyObj) =>
                            hierarchyObj.employeename[0] == userObj.companyname
                    );
                    return {
                        companyname: userObj.companyname,
                        unit: userObj.unit,
                        department: userObj.department,
                        team: userObj.team,
                        branch: userObj.branch,
                        doj: userObj.doj,
                        dot: userObj.dot,
                        empcode: userObj.empcode,
                        floor: userObj.floor,
                        designation: userObj.designation,
                        shiftallot: userObj.shiftallot,
                        shifttiming: userObj.shifttiming,
                        boardingLog: userObj.boardingLog,
                        role: userObj.role,
                        weekoff: userObj.weekoff,
                        company: userObj.company,
                        username: userObj.username,
                        _id: userObj._id,
                        level: matchingHierarchycontrol
                            ? matchingHierarchycontrol.level
                            : "",
                        control: matchingHierarchycontrol
                            ? matchingHierarchycontrol.control
                            : "",
                    };
                })
                .filter((data) => answerDeoverall.includes(data.companyname));

            let hierarchyallfinal = await Hirerarchi.find({
                employeename: { $in: answerDeoverall.map((item) => item) },
                level: req.body.sector,
            });
            hierarchyFinal =
                req.body.sector === "all"
                    ? answerDeoverall.length > 0
                        ? [].concat(...answerDeoverall)
                        : []
                    : hierarchyallfinal.length > 0
                        ? [].concat(...hierarchyallfinal.map((item) => item.employeename))
                        : [];

            primaryhierarchyfinal = filteredoverall
                .filter((item) => item.level == "Primary")
                .map((item) => item.companyname);

            secondaryhierarchyfinal = filteredoverall
                .filter((item) => item.level == "Secondary")
                .map((item) => item.companyname);

            tertiaryhierarchyfinal = filteredoverall
                .filter((item) => item.level == "Tertiary")
                .map((item) => item.companyname);
        }

        if (listpageaccessmode === "Reporting to Based") {
            reportingtobaseduser = users.map((userObj) => {
                return {
                    companyname: userObj.companyname,
                    unit: userObj.unit,
                    department: userObj.department,
                    team: userObj.team,
                    branch: userObj.branch,
                    doj: userObj.doj,
                    dot: userObj.dot,
                    empcode: userObj.empcode,
                    floor: userObj.floor,
                    designation: userObj.designation,
                    shiftallot: userObj.shiftallot,
                    shifttiming: userObj.shifttiming,
                    boardingLog: userObj.boardingLog,
                    role: userObj.role,
                    weekoff: userObj.weekoff,
                    company: userObj.company,
                    username: userObj.username,
                    _id: userObj._id,
                    level: "",
                    control: "",
                };
            });
        }

        let resultAccessFiltered =
            req.body.hierachy === "My Hierarchy List" &&
                (listpageaccessmode === "Hierarchy Based" ||
                    listpageaccessmode === "Overall")
                ? resulted
                : req.body.hierachy === "All Hierarchy List" &&
                    (listpageaccessmode === "Hierarchy Based" ||
                        listpageaccessmode === "Overall")
                    ? resultedTeam
                    : req.body.hierachy === "My + All Hierarchy List" &&
                        (listpageaccessmode === "Hierarchy Based" ||
                            listpageaccessmode === "Overall")
                        ? filteredoverall
                        : reportingtobaseduser;
        // console.log(resulted, 'resulted')

        const restrictTeam = await Hirerarchi.aggregate([
            {
                $match: {
                    supervisorchoose:
                        { $in: [...filteredoverall]?.map(data => data?.companyname) }, // Match supervisorchoose with username
                    level: { $in: levelFinal } // Corrected unmatched quotation mark
                }
            },
            {
                $lookup: {
                    from: "reportingheaders",
                    let: {
                        teamControlsArray: {
                            $ifNull: ["$pagecontrols", []]
                        }
                    },
                    pipeline: [
                        {
                            $match: {
                                $expr: {
                                    $and: [
                                        {
                                            $in: [
                                                "$name",
                                                "$$teamControlsArray"
                                            ]
                                        }, // Check if 'name' is in 'teamcontrols' array
                                        {
                                            $in: [
                                                req?.body?.pagename,
                                                "$reportingnew" // Check if 'menuteamloginstatus' is in 'reportingnew' array
                                            ]
                                        } // Additional condition for reportingnew array
                                    ]
                                }
                            }
                        }
                    ],
                    as: "reportData" // The resulting matched documents will be in this field
                }
            },
            {
                $project: {
                    supervisorchoose: 1,
                    employeename: 1,
                    reportData: 1
                }
            }
        ]);

        let restrictListTeam = restrictTeam?.filter(data => data?.reportData?.length > 0)?.flatMap(Data => Data?.employeename)
        let overallRestrictList = req.body.hierachy === "myhierarchy" ? restrictList : req.body.hierachy === "allhierarchy" ? restrictListTeam : [...restrictList, ...restrictListTeam];
        resultAccessFilter = overallRestrictList?.length > 0 ? resultAccessFiltered?.filter(data => overallRestrictList?.includes(data?.companyname)) : [];
        // console.log(resultAccessFiltered?.length, "resultAccessFiltered")

    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    // if (!finaluser) {
    //     return next(new ErrorHandler("Users not found", 400));
    // }

    return res.status(200).json({ resultAccessFilter, resultedTeam });
});

exports.getAllUserClockinAndClockoutStatusIndividualHierarchyFilter = catchAsyncErrors(
    async (req, res, next) => {
        let resultArray,
            user,
            result1,
            ans1D,
            i = 1,
            result2,
            result3,
            result4,
            result5,
            result6,
            dataCheck,
            userFilter,
            result,
            hierarchyFilter,
            answerDef,
            hierarchyFinal,
            hierarchy,
            hierarchyDefList,
            resultAccessFilter,
            branch,
            hierarchySecond,
            overallMyallList,
            hierarchyMap,
            resulted,
            resultedTeam,
            myallTotalNames;

        try {
            const { listpageaccessmode } = req.body;
            let levelFinal = req.body?.sector === "all" ? ["Primary", "Secondary", "Tertiary"] : [req.body?.sector]
            let answer = await Hirerarchi.aggregate([
                {
                    $match: {
                        supervisorchoose:
                            req?.body?.username, // Match supervisorchoose with username
                        level: { $in: levelFinal } // Corrected unmatched quotation mark
                    }
                },
                {
                    $lookup: {
                        from: "reportingheaders",
                        let: {
                            teamControlsArray: {
                                $ifNull: ["$pagecontrols", []]
                            }
                        },
                        pipeline: [
                            {
                                $match: {
                                    $expr: {
                                        $and: [
                                            {
                                                $in: [
                                                    "$name",
                                                    "$$teamControlsArray"
                                                ]
                                            }, // Check if 'name' is in 'teamcontrols' array
                                            {
                                                $in: [
                                                    req?.body?.pagename,
                                                    "$reportingnew" // Check if 'menuteamloginstatus' is in 'reportingnew' array
                                                ]
                                            } // Additional condition for reportingnew array
                                        ]
                                    }
                                }
                            }
                        ],
                        as: "reportData" // The resulting matched documents will be in this field
                    }
                },
                {
                    $project: {
                        supervisorchoose: 1,
                        employeename: 1,
                        reportData: 1
                    }

                }
            ]);
            let restrictList = answer?.filter(data => data?.reportData?.length > 0)?.flatMap(Data => Data?.employeename)


            result = await User.find(
                {
                    enquirystatus: {
                        $nin: ["Enquiry Purpose"],
                    },
                    resonablestatus: {
                        $nin: [
                            "Not Joined",
                            "Postponed",
                            "Rejected",
                            "Closed",
                            "Releave Employee",
                            "Absconded",
                            "Hold",
                            "Terminate",
                        ],
                    },
                    ...(listpageaccessmode === "Reporting to Based"
                        ? { reportingto: req.body.username }
                        : {}),
                },
                {
                    company: 1,
                    branch: 1,
                    unit: 1,
                    team: 1,
                    department: 1,
                    doj: 1,
                    dot: 1,
                    empcode: 1,
                    companyname: 1,
                    team: 1,
                    floor: 1,
                    username: 1,
                    designation: 1,
                    weekoff: 1,
                    shiftallot: 1,
                    shifttiming: 1,
                    boardingLog: 1,
                    role: 1,
                    _id: 1,
                    reasondate: 1,
                    departmentlog: 1, attendancemode: 1
                }
            );

            // Accordig to sector and list filter process
            hierarchyFilter = await Hirerarchi.find({ level: req.body.sector });
            userFilter = hierarchyFilter
                .filter((data) => data.supervisorchoose.includes(req.body.username))
                .map((data) => data.employeename);

            hierarchyDefList = await Hirerarchi.find();
            user = await User.find({ companyname: req.body.username });
            const userFilt = user.length > 0 && user[0].designation;
            const desiGroup = await Designation.find();
            let HierarchyFilt =
                req.body.sector === "all"
                    ? hierarchyDefList
                        .filter((data) =>
                            data.supervisorchoose.includes(req.body.username)
                        )
                        .map((data) => data.designationgroup)
                    : hierarchyFilter
                        .filter((data) =>
                            data.supervisorchoose.includes(req.body.username)
                        )
                        .map((data) => data.designationgroup);
            const DesifFilter = desiGroup.filter((data) =>
                HierarchyFilt.includes(data.group)
            );
            const desigName = DesifFilter.length > 0 && DesifFilter[0].name;
            const SameDesigUser = HierarchyFilt.includes("All")
                ? true
                : userFilt === desigName;
            //Default Loading of List
            answerDef = hierarchyDefList
                .filter((data) => data.supervisorchoose.includes(req.body.username))
                .map((data) => data.employeename);

            hierarchyFinal =
                req.body.sector === "all"
                    ? answerDef.length > 0
                        ? [].concat(...answerDef)
                        : []
                    : hierarchyFilter.length > 0
                        ? [].concat(...userFilter)
                        : [];

            hierarchyMap = hierarchyFinal.length > 0 ? hierarchyFinal : [];

            //solo
            ans1D =
                req.body.sector === "all"
                    ? answerDef.length > 0
                        ? hierarchyDefList.filter((data) =>
                            data.supervisorchoose.includes(req.body.username)
                        )
                        : []
                    : hierarchyFilter.length > 0
                        ? hierarchyFilter.filter((data) =>
                            data.supervisorchoose.includes(req.body.username)
                        )
                        : [];
            result1 =
                ans1D.length > 0
                    ? result
                        .map((item1) => {
                            const matchingItem2 = ans1D.find((item2) =>
                                item2.employeename.includes(item1.companyname)
                            );

                            if (matchingItem2) {
                                const plainItem1 = item1.toObject ? item1.toObject() : item1;
                                return {
                                    ...plainItem1,
                                    level: req.body.sector + "-" + matchingItem2.control,
                                };
                                //   return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                            }
                        })
                        .filter((item) => item !== undefined)
                    : [];

            resulted = result1;

            //team
            let branches = [];
            hierarchySecond = await Hirerarchi.find();

            const subBranch =
                hierarchySecond.length > 0
                    ? hierarchySecond
                        .filter((item) =>
                            item.supervisorchoose.some((name) =>
                                hierarchyMap.includes(name)
                            )
                        )
                        .map((item) => item.employeename)
                        .flat()
                    : "";

            const answerFilterExcel =
                hierarchySecond.length > 0
                    ? hierarchySecond.filter((item) =>

                        item.supervisorchoose.some((name) => hierarchyMap.includes(name))
                    )
                    : [];

            result2 =
                answerFilterExcel.length > 0
                    ? result
                        .map((item1) => {
                            const matchingItem2 = answerFilterExcel.find((item2) =>
                                item2.employeename.includes(item1.companyname)
                            );
                            if (matchingItem2) {
                                // If a match is found, inject the control property into the corresponding item in an1
                                const plainItem1 = item1.toObject ? item1.toObject() : item1;
                                return {
                                    ...plainItem1,
                                    level: req.body.sector + "-" + matchingItem2.control,
                                };
                                // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                            }
                        })
                        .filter((item) => item !== undefined)
                    : [];
            branches.push(...subBranch);

            const ans =
                subBranch.length > 0
                    ? hierarchySecond
                        .filter((item) =>
                            item.supervisorchoose.some((name) => subBranch.includes(name))
                        )
                        .map((item) => item.employeename)
                        .flat()
                    : "";
            const answerFilterExcel2 =
                subBranch.length > 0
                    ? hierarchySecond.filter((item) =>
                        item.supervisorchoose.some((name) => subBranch.includes(name))
                    )
                    : [];

            result3 =
                answerFilterExcel2.length > 0
                    ? result
                        .map((item1) => {
                            const matchingItem2 = answerFilterExcel2.find((item2) =>
                                item2.employeename.includes(item1.companyname)
                            );
                            if (matchingItem2) {
                                const plainItem1 = item1.toObject ? item1.toObject() : item1;

                                return {
                                    ...plainItem1,
                                    level: req.body.sector + "-" + matchingItem2.control,
                                };
                                // If a match is found, inject the control property into the corresponding item in an1
                                // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                            }
                        })
                        .filter((item) => item !== undefined)
                    : [];
            branches.push(...ans);

            const loop3 =
                ans.length > 0
                    ? hierarchySecond
                        .filter((item) =>
                            item.supervisorchoose.some((name) => ans.includes(name))
                        )
                        .map((item) => item.employeename)
                        .flat()
                    : "";

            const answerFilterExcel3 =
                ans.length > 0
                    ? hierarchySecond.filter((item) =>
                        item.supervisorchoose.some((name) => ans.includes(name))
                    )
                    : [];

            result4 =
                answerFilterExcel3.length > 0
                    ? result
                        .map((item1) => {
                            const matchingItem2 = answerFilterExcel3?.find((item2) =>
                                item2.employeename.includes(item1.companyname)
                            );
                            if (matchingItem2) {
                                const plainItem1 = item1.toObject ? item1.toObject() : item1;
                                return {
                                    ...plainItem1,
                                    level: req.body.sector + "-" + matchingItem2.control,
                                };
                                // If a match is found, inject the control property into the corresponding item in an1
                                // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                            }
                        })
                        .filter((item) => item !== undefined)
                    : [];
            branches.push(...loop3);

            const loop4 =
                loop3.length > 0
                    ? hierarchySecond
                        .filter((item) =>
                            item.supervisorchoose.some((name) => loop3.includes(name))
                        )
                        .map((item) => item.employeename)
                        .flat()
                    : [];
            const answerFilterExcel4 =
                loop3.length > 0
                    ? hierarchySecond.filter((item) =>
                        item.supervisorchoose.some((name) => loop3.includes(name))
                    )
                    : [];
            result5 =
                answerFilterExcel4.length > 0
                    ? result
                        .map((item1) => {
                            const matchingItem2 = answerFilterExcel4?.find((item2) =>
                                item2.employeename.includes(item1.companyname)
                            );
                            if (matchingItem2) {
                                const plainItem1 = item1.toObject ? item1.toObject() : item1;
                                return {
                                    ...plainItem1,
                                    level: req.body.sector + "-" + matchingItem2.control,
                                };
                                // If a match is found, inject the control property into the corresponding item in an1
                                // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                            }
                        })
                        .filter((item) => item !== undefined)
                    : [];
            branches.push(...loop4);

            const loop5 =
                loop4.length > 0
                    ? hierarchySecond
                        .filter((item) =>
                            item.supervisorchoose.some((name) => loop4.includes(name))
                        )
                        .map((item) => item.employeename)
                        .flat()
                    : "";
            const answerFilterExcel5 =
                loop4.length > 0
                    ? hierarchySecond.filter((item) =>
                        item.supervisorchoose.some((name) => loop4.includes(name))
                    )
                    : [];
            result6 =
                answerFilterExcel5.length > 0
                    ? result
                        .map((item1) => {
                            const matchingItem2 = answerFilterExcel5?.find((item2) =>
                                item2.employeename.includes(item1.companyname)
                            );
                            if (matchingItem2) {
                                const plainItem1 = item1.toObject ? item1.toObject() : item1;
                                return {
                                    ...plainItem1,
                                    level: req.body.sector + "-" + matchingItem2.control,
                                };
                                // If a match is found, inject the control property into the corresponding item in an1
                                // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                            }
                        })
                        .filter((item) => item !== undefined)
                    : [];
            branches.push(...loop5);

            resultedTeam = [
                ...result2,
                ...result3,
                ...result4,
                ...result5,
                ...result6,
            ];
            //overall Teams List
            myallTotalNames = [...hierarchyMap, ...branches];
            overallMyallList = [...resulted, ...resultedTeam];
            console.log(myallTotalNames, 'myallTotalNames')
            const restrictTeam = await Hirerarchi.aggregate([
                {
                    $match: {
                        supervisorchoose:
                            { $in: myallTotalNames }, // Match supervisorchoose with username
                        level: { $in: levelFinal } // Corrected unmatched quotation mark
                    }
                },
                {
                    $lookup: {
                        from: "reportingheaders",
                        let: {
                            teamControlsArray: {
                                $ifNull: ["$pagecontrols", []]
                            }
                        },
                        pipeline: [
                            {
                                $match: {
                                    $expr: {
                                        $and: [
                                            {
                                                $in: [
                                                    "$name",
                                                    "$$teamControlsArray"
                                                ]
                                            }, // Check if 'name' is in 'teamcontrols' array
                                            {
                                                $in: [
                                                    req?.body?.pagename,
                                                    "$reportingnew" // Check if 'menuteamloginstatus' is in 'reportingnew' array
                                                ]
                                            } // Additional condition for reportingnew array
                                        ]
                                    }
                                }
                            }
                        ],
                        as: "reportData" // The resulting matched documents will be in this field
                    }
                },
                {
                    $project: {
                        supervisorchoose: 1,
                        employeename: 1,
                        reportData: 1
                    }
                }
            ]);
            let restrictListTeam = restrictTeam?.filter(data => data?.reportData?.length > 0)?.flatMap(Data => Data?.employeename)
            let overallRestrictList = req.body.hierachy === "myhierarchy" ? restrictList : req.body.hierachy === "allhierarchy" ? restrictListTeam : [...restrictList, ...restrictListTeam];

            let resultAccessFiltered =
                req.body.hierachy === "myhierarchy" &&
                    (listpageaccessmode === "Hierarchy Based" ||

                        listpageaccessmode === "Overall")
                    ? resulted
                    : req.body.hierachy === "allhierarchy" &&
                        (listpageaccessmode === "Hierarchy Based" ||
                            listpageaccessmode === "Overall")
                        ? resultedTeam
                        : req.body.hierachy === "myallhierarchy" &&
                            (listpageaccessmode === "Hierarchy Based" ||
                                listpageaccessmode === "Overall")
                            ? overallMyallList
                            : result;

            resultAccessFilter = overallRestrictList?.length > 0 ? resultAccessFiltered?.filter(data => overallRestrictList?.includes(data?.companyname)) : [];


        } catch (err) {
            return next(new ErrorHandler("Records not found!", 404));
        }
        return res.status(200).json({
            resultedTeam,
            resultAccessFilter,
            hierarchyFilter,
        });
    }
);

exports.getAllUserClockinAndClockoutStatusForMontLopCalFilterMinPointsNew = catchAsyncErrors(async (req, res, next) => {
    let users;
    let controlcriteria;
    let attendance;
    let allLeaveStatus;
    let holidays;
    let resultshiftallot = [];
    let depMonthSet;
    let graceTime;
    let clockOutHours;
    let lateclockincount;
    let earlyclockoutcount;
    let onclockout;
    let earlyclockin;
    let earlyclockout;
    let lateclockin;
    let afterlateclockin;
    let beforeearlyclockout;
    let leavetype;
    let permission;
    let weekOffDates = [];
    let finaluser = [];
    const { ismonth, isyear } = req.body;

    try {
        users = await User.find(
            {
                resonablestatus: {
                    $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
            },
            {
                company: 1,
                branch: 1,
                unit: 1,
                team: 1,
                department: 1,
                doj: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                floor: 1,
                username: 1,
                designation: 1,
                shift: 1,
                weekoff: 1,
                shiftallot: 1,
                shifttiming: 1,
                boardingLog: 1, attendancemode: 1,
                departmentlog: 1,
            }
        );
        const monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
        const from_date = new Date(isyear, ismonth - 1, 1);

        // Calculate the last day of the previous month
        const last_day_prev_month = new Date(from_date.getFullYear(), from_date.getMonth(), 0);

        // Get the 15th day of the previous month
        const before_month_date = new Date(last_day_prev_month.getFullYear(), last_day_prev_month.getMonth(), 20);

        // Get the 15th day of the next month
        const next_month = new Date(from_date.getFullYear(), from_date.getMonth() + 1, 10);

        let fromdate = before_month_date.toISOString()?.split("T")[0];
        let todate = next_month.toISOString()?.split("T")[0];

        const originalDateObject = new Date(fromdate);

        const originalDateObjecttodate = new Date(todate);

        // const maxDateDocument = await Attendance.aggregate([
        //   {
        //     $match: {
        //       date: { $exists: true, $ne: "", $regex: /^\d{2}-\d{2}-\d{4}$/ },
        //     },
        //   },
        //   {
        //     $project: {
        //       date: {
        //         $dateFromString: {
        //           dateString: "$date",
        //           format: "%d-%m-%Y",
        //         },
        //       },
        //     },
        //   },
        //   {
        //     $sort: { date: -1 },
        //   },
        //   {
        //     $limit: 1,
        //   },
        // ]);
        const maxDateDocument = await Attendance.findOne({}, { createdAt: 1 }).sort({ createdAt: -1 });

        const maxDate = maxDateDocument.length > 0 ? maxDateDocument[0].createdAt : null;

        let maxDateFinal = originalDateObjecttodate > (maxDate ? maxDate : new Date(req.body.today)) ? (maxDate ? maxDate : req.body.today) : originalDateObjecttodate;

        attendance = await Attendance.find(
            {
                $and: [{ createdAt: { $gt: originalDateObject } }, { createdAt: { $lt: maxDateFinal } }],
            },
            { username: 1, clockintime: 1, clockouttime: 1, buttonstatus: 1, date: 1, userid: 1, status: 1 }
        );
        depMonthSet = await DepartmentMonth.find({ year: { $eq: isyear }, monthname: { $eq: monthNames[ismonth - 1] } }, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 });
        controlcriteria = await ControlCriteria.find();

        const userCds = users.map(user => user.companyname);
        allLeaveStatus = await ApplyLeave.find({ employeename: { $in: userCds } });
        holidays = await Holiday.find({}, { date: 1, company: 1, applicablefor: 1, unit: 1, team: 1, employee: 1, noofdays: 1 });
        leavetype = await Leavetype.find({}, { leavetype: 1, code: 1 });
        permission = await Permission.find({ employeename: { $in: userCds } }, { employeeid: 1, date: 1, status: 1, applytype: 1, compensationstatus: 1, compensationapplytype: 1, requesthours: 1, shiftmode: 1, });

        // graceTime = controlcriteria[0].gracetime;
        clockOutHours = controlcriteria[0].clockout;
        lateclockincount = controlcriteria[0].lateclockincount;
        earlyclockoutcount = controlcriteria[0].earlyclockoutcount;
        onclockout = controlcriteria[0].onclockout;
        earlyclockin = controlcriteria[0].earlyclockin;
        lateclockin = controlcriteria[0].lateclockin;
        earlyclockout = controlcriteria[0].earlyclockout;
        afterlateclockin = controlcriteria[0].afterlateclockin;
        beforeearlyclockout = controlcriteria[0].afterlateclockin;

        finaluser = users?.flatMap((item, index) => {

            let isEmployeeGrace = controlcriteria[0].todos && controlcriteria[0].todos.find(d => d.company === item.company &&
                d.branch === item.branch && d.unit === item.unit && d.team === item.team &&
                d.employeename === item.companyname
            )

            if (isEmployeeGrace) {
                graceTime = isEmployeeGrace.employeegracetime;
            }
            else {
                graceTime = controlcriteria[0].gracetime;
            }

            let userDates = [];

            // const comparedDate = depMonthSet?.filter((d) => d.department === item.department);

            // Remove duplicate entries with the most recent entry
            const uniqueEntriesDep = {};
            item.departmentlog?.forEach(entry => {
                const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                const key = entry.startdate;
                if (!(key in uniqueEntriesDep)) {
                    uniqueEntriesDep[key] = entry;
                }
            });
            const foundDepartment = depMonthSet?.find((d) => Number(d.year) === isyear && d.monthname === monthNames[ismonth - 1]);
            const uniqueDepLog = Object.values(uniqueEntriesDep);
            const relevantDepLogEntry = uniqueDepLog
                .filter(log => new Date(log.startdate) <= new Date(foundDepartment && foundDepartment.fromdate))
                .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

            const comparedDate = depMonthSet?.filter((d) => d.department === (relevantDepLogEntry && relevantDepLogEntry.department) && Number(d.year) === isyear && d.monthname === monthNames[ismonth - 1]);
            const dojDate = item?._doc?.boardingLog.length > 0 ?
                item?._doc?.boardingLog[0].startdate
                : item?._doc?.doj;

            if (comparedDate && comparedDate.length > 0) {
                comparedDate?.forEach((dep) => {
                    if (!dep.fromdate && !dep.todate) {
                        return "";
                    }

                    if (!item?._doc?.doj) {
                        return "";
                    }

                    const [year2, month2, day2] = dojDate?.split("-").map(Number);
                    const joiningDate = new Date(year2, month2 - 1, day2);
                    const [year1, month1, day1] = dep.fromdate?.split("-").map(Number);
                    const [year, month, day] = dep.todate?.split("-").map(Number);
                    const lastDate = new Date(year, month - 1, day);
                    const firstDate = new Date(year1, month1 - 1, day1);

                    if (joiningDate < firstDate) {
                        // Check if the shift date is before or equal to the current date
                        // if (lastDate >= currentDateAttStatus) {
                        //   // If matched, push the range from 'fromdate' to 'todate'
                        //   const startDate = new Date(firstDate);
                        //   // Loop through the dates in the range
                        //   while (startDate <= currentDateAttStatus) {
                        //     userDates.push({
                        //       formattedDate: format(startDate, "dd/MM/yyyy"),
                        //       dayName: format(startDate, "EEEE"),
                        //       dayCount: startDate.getDate(),
                        //     });
                        //     startDate.setDate(startDate.getDate() + 1);
                        //   }
                        // } else if (lastDate <= currentDateAttStatus) {
                        // If matched, push the range from 'fromdate' to 'todate'
                        const startDate = new Date(firstDate);
                        // Loop through the dates in the range
                        while (startDate <= lastDate) {
                            userDates.push({
                                formattedDate: format(startDate, "dd/MM/yyyy"),
                                dayName: format(startDate, "EEEE"),
                                dayCount: startDate.getDate(),
                            });
                            startDate.setDate(startDate.getDate() + 1);
                        }
                        // }
                    } else {
                        // Check if the shift date is before or equal to the current date
                        // if (lastDate >= currentDateAttStatus) {
                        //   // If matched, push the range from 'fromdate' to 'todate'
                        //   const startDate = new Date(joiningDate);
                        //   // Loop through the dates in the range
                        //   while (startDate <= currentDateAttStatus) {
                        //     userDates.push({
                        //       formattedDate: format(startDate, "dd/MM/yyyy"),
                        //       dayName: format(startDate, "EEEE"),
                        //       dayCount: startDate.getDate(),
                        //     });
                        //     startDate.setDate(startDate.getDate() + 1);
                        //   }
                        // } else if (lastDate <= currentDateAttStatus) {
                        // If matched, push the range from 'fromdate' to 'todate'
                        const startDate = new Date(joiningDate);
                        // Loop through the dates in the range
                        while (startDate <= lastDate) {
                            userDates.push({
                                formattedDate: format(startDate, "dd/MM/yyyy"),
                                dayName: format(startDate, "EEEE"),
                                dayCount: startDate.getDate(),
                            });
                            startDate.setDate(startDate.getDate() + 1);
                        }
                        // }
                    }
                });
            } else {
                const [year2, month2, day2] = dojDate?.split("-").map(Number);
                const joiningDate = new Date(year2, month2 - 1, day2);
                // Calculate the start date of the month based on the selected month
                const startDate = new Date(isyear, ismonth - 1, 1);

                const endDate = new Date(startDate);
                endDate.setMonth(endDate.getMonth() + 1);
                endDate.setDate(endDate.getDate() - 1);

                if (joiningDate < startDate) {
                    // Check if the shift date is before or equal to the current date
                    // if (endDate >= currentDateAttStatus) {
                    //   let currentDate1 = new Date(startDate);

                    //   while (currentDate1 <= endDate) {
                    //     userDates.push({
                    //       formattedDate: format(currentDate1, "dd/MM/yyyy"),
                    //       dayName: format(currentDate1, "EEEE"),
                    //       dayCount: currentDate1.getDate(),
                    //     });
                    //     currentDate1.setDate(currentDate1.getDate() + 1);
                    //   }
                    // } else if (endDate <= currentDateAttStatus) {
                    let currentDate1 = new Date(startDate);

                    while (currentDate1 <= endDate) {
                        userDates.push({
                            formattedDate: format(currentDate1, "dd/MM/yyyy"),
                            dayName: format(currentDate1, "EEEE"),
                            dayCount: currentDate1.getDate(),
                        });
                        currentDate1.setDate(currentDate1.getDate() + 1);
                    }
                    // }
                } else {
                    // Check if the shift date is before or equal to the current date
                    // if (endDate >= currentDateAttStatus) {
                    //   // If matched, push the range from 'fromdate' to 'todate'
                    //   const startDate = new Date(joiningDate);
                    //   // Loop through the dates in the range
                    //   while (startDate <= currentDateAttStatus) {
                    //     userDates.push({
                    //       formattedDate: format(startDate, "dd/MM/yyyy"),
                    //       dayName: format(startDate, "EEEE"),
                    //       dayCount: startDate.getDate(),
                    //     });
                    //     startDate.setDate(startDate.getDate() + 1);
                    //   }
                    // } else if (endDate <= currentDateAttStatus) {
                    let currentDate1 = new Date(startDate);

                    while (currentDate1 <= endDate) {
                        userDates.push({
                            formattedDate: format(currentDate1, "dd/MM/yyyy"),
                            dayName: format(currentDate1, "EEEE"),
                            dayCount: currentDate1.getDate(),
                        });
                        currentDate1.setDate(currentDate1.getDate() + 1);
                    }
                }
                // }
            }

            item.shiftallot?.map((allot) => {
                resultshiftallot.push({ ...allot });
            });

            const filteredMatchingDoubleShiftItem = resultshiftallot?.filter(val => val && val?._doc?.empcode === item?._doc?.empcode && val?._doc?.adjstatus === 'Approved');

            // Filter out the dates that have matching 'Shift Adjustment' todates
            let removedUserDates = userDates.filter(date => {
                // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
                const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem.find(item => item && item?._doc?.todate === date.formattedDate && item?._doc?.adjustmenttype === 'Shift Adjustment');

                // If there is no matching 'Shift Adjustment', keep the date
                return !matchingShiftAdjustmentToDate;
            });

            // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
            let uniqueEntries = new Set();

            // Iterate over removedUserDates and add unique entries to the Set
            userDates.forEach(date => {
                uniqueEntries.add(JSON.stringify({
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    shiftMode: 'Main Shift',
                    weekNumberInMonth: date.weekNumberInMonth,
                }));
            });

            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach(item => {
                const [day, month, year] = item._doc.adjdate?.split('/')
                let newFormattedDate = new Date(`${year}-${month}-${day}`);

                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(JSON.stringify({
                        formattedDate: item._doc.adjdate,
                        dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
                        dayCount: parseInt(moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")),
                        shiftMode: 'Second Shift',
                        weekNumberInMonth: (getWeekNumberInMonth(newFormattedDate) === 1 ? `${getWeekNumberInMonth(newFormattedDate)}st Week` :
                            getWeekNumberInMonth(newFormattedDate) === 2 ? `${getWeekNumberInMonth(newFormattedDate)}nd Week` :
                                getWeekNumberInMonth(newFormattedDate) === 3 ? `${getWeekNumberInMonth(newFormattedDate)}rd Week` :
                                    getWeekNumberInMonth(newFormattedDate) > 3 ? `${getWeekNumberInMonth(newFormattedDate)}th Week` : '')
                    }));
                }
            });

            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries).map(entry => JSON.parse(entry));

            function sortUserDates(dates) {
                return dates.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);
            const createdUserDates = sortedCreatedUserDates?.filter(d => {
                const filterData = userDates.some(val => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date) => {
                let filteredRowData = resultshiftallot?.filter((val) => val?._doc?.empcode == item?._doc?.empcode);
                const matchingItem = filteredRowData?.find(item => item && item?._doc?.adjdate == date.formattedDate);
                const matchingItemAllot = filteredRowData?.find(item => item && formatDate(item?._doc?.date) == date.formattedDate);
                const matchingDoubleShiftItem = filteredRowData?.find(item => item && item?._doc?.todate === date.formattedDate);
                const matchingRemovedItem = filteredRowData?.find(item => item?._doc?.removedshiftdate === date.formattedDate);
                const matchingAssignShiftItem = filteredRowData?.find(item => item?._doc?.adjdate === date.formattedDate && item?._doc?.adjstatus === 'Approved' && item?._doc?.adjustmenttype === 'Assign Shift');

                const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                    // return item;
                });

                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item?._doc?.weekoff?.includes(date.dayName);
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                const row = {
                    // id: `${item?._doc?._id.toString()}_${date.formattedDate}_${date.shiftMode}`,
                    // userid: item?._doc?._id.toString(),
                    company: item?._doc?.company,
                    branch: item?._doc?.branch,
                    unit: item?._doc?.unit,
                    team: item?._doc?.team,
                    dpj: dojDate,
                    department: relevantDepLogEntry && relevantDepLogEntry?.department,
                    username: item?._doc?.companyname,
                    empcode: item?._doc?.empcode,
                    weekoff: item?._doc?.weekoff,
                    boardingLog: item?._doc?.boardingLog,
                    shiftallot: item?._doc?.shiftallot,
                    shift: getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                    date: `${date.formattedDate} ${date.dayName} ${date.dayCount}`,
                    role: item?._doc?.role,
                    rowformattedDate: date.formattedDate,
                    dayName: date.dayName,
                    shiftMode: date.shiftMode,
                    clockin: checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        date.shiftMode,
                    ),
                    clockout: checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        date.shiftMode,
                    ),
                    clockinstatus: checkClockInStatus(
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        graceTime, allLeaveStatus, holidays,
                        checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,), item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname,
                        earlyclockin, lateclockin, afterlateclockin, leavetype, permission,
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    clockoutstatus: checkClockOutStatus(
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        clockOutHours, checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        allLeaveStatus, holidays, item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname, onclockout,
                        earlyclockout, beforeearlyclockout,
                        checkGetClockInAutoStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        leavetype, permission, date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    // attendanceautostatus: checkAttendanceStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    // lateclockincount: lateclockincount,
                    // earlyclockoutcount: earlyclockoutcount,
                    totalnumberofdays: getTotalMonthDaysUser(item?._doc?.department, depMonthSet, ismonth, isyear),
                    // empshiftdays: getTotalMonthDaysForEmpUser(dojDate, item?._doc?.department, depMonthSet, ismonth, isyear),
                    // totalcounttillcurrendate: getTotalMonthsCurrentDateCountUser(dojDate, item?._doc?.department, depMonthSet, ismonth, isyear),
                    // totalshift: getTotalShiftHoursUser(item?._doc?._id.toString(), createdUserDates, attendance),
                    weekoffpresentstatus: checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                };
                return row;
            });

            return userRows;
        });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finaluser) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ finaluser });
});

exports.getAllRemoteIndividualuserFilter = catchAsyncErrors(async (req, res) => {
    try {
        const { username, companyname } = req.body;

        const matchStage = {
            $match: {
                enquirystatus: { $nin: ["Enquiry Purpose"] },
                resonablestatus: {
                    $nin: [
                        "Not Joined",
                        "Postponed",
                        "Rejected",
                        "Closed",
                        "Releave Employee",
                        "Absconded",
                        "Hold",
                        "Terminate",
                    ],
                },
                ...(username ? { username } : {}),
                ...(companyname ? { companyname } : {}),
            },
        };

        const pipeline = [
            matchStage, // Step 1: Filter Users
            {
                $addFields: {
                    userIdAsString: { $toString: "$_id" }, // Convert ObjectId to String
                },
            },
            {
                $lookup: {
                    from: "remoteworkmodes",
                    localField: "userIdAsString",
                    foreignField: "employeeid",
                    as: "remoteWorkModeData",
                },
            },
            {
                $addFields: {
                    addremoteworkmode: { $ifNull: ["$remoteWorkModeData.addremoteworkmode", []] }, // Set to empty array if null
                },
            },
            {
                $project: {
                    company: 1,
                    workmode: 1,
                    branch: 1,
                    unit: 1,
                    team: 1,
                    empcode: 1,
                    companyname: 1,
                    workstationofficestatus: 1,
                    approvedremotestatus: 1,
                    addremoteworkmode: 1,
                    workstationinput: 1,
                    username: 1,
                },
            },
        ];

        const filteredUsers = await User.aggregate(pipeline);

        return res.status(200).json({ filterallremoteuser: filteredUsers });
    } catch (err) {
        return res.status(500).json({ error: "Internal server error" });
    }
});

//Hierarchy Based remote users
exports.getAllRemoteHierarchyBasedUsers = catchAsyncErrors(
    async (req, res, next) => {
        let resultArray,
            user,
            result1,
            ans1D,
            i = 1,
            result2,
            result3,
            result4,
            result5,
            result6,
            dataCheck,
            userFilter,
            result,
            hierarchyFilter,
            answerDef,
            hierarchyFinal,
            hierarchy,
            hierarchyDefList,
            resultAccessFilter,
            branch,
            hierarchySecond,
            overallMyallList,
            hierarchyMap,
            resulted,
            resultedTeam,
            DataAccessMode = false,
            myallTotalNames;

        try {
            const { listpageaccessmode } = req.body;
            let levelFinal = req.body?.sector === "all" ? ["Primary", "Secondary", "Tertiary"] : [req.body?.sector]
            let answer = await Hirerarchi.aggregate([
                {
                    $match: {
                        supervisorchoose:
                            req?.body?.username, // Match supervisorchoose with username
                        level: { $in: levelFinal } // Corrected unmatched quotation mark
                    }
                },
                {
                    $lookup: {
                        from: "reportingheaders",
                        let: {
                            teamControlsArray: {
                                $ifNull: ["$pagecontrols", []]
                            }
                        },
                        pipeline: [
                            {
                                $match: {
                                    $expr: {
                                        $and: [
                                            {
                                                $in: [
                                                    "$name",
                                                    "$$teamControlsArray"
                                                ]
                                            }, // Check if 'name' is in 'teamcontrols' array
                                            {
                                                $in: [
                                                    req?.body?.pagename,
                                                    "$reportingnew" // Check if 'menuteamloginstatus' is in 'reportingnew' array
                                                ]
                                            } // Additional condition for reportingnew array
                                        ]
                                    }
                                }
                            }
                        ],
                        as: "reportData" // The resulting matched documents will be in this field
                    }
                },
                {
                    $project: {
                        supervisorchoose: 1,
                        employeename: 1,
                        reportData: 1
                    }

                }
            ]);

            // Manager Condition Without Supervisor
            const HierarchySupervisorFind = await Hirerarchi.find({ supervisorchoose: req?.body?.username });
            DataAccessMode = req.body.role?.some(role => role.toLowerCase() === "manager") && HierarchySupervisorFind?.length === 0;
            const { uniqueNames, pageControlsData } = await Hierarchyfilter(levelFinal, req?.body?.pagename);


            let restrictList = answer?.filter(data => data?.reportData?.length > 0)?.flatMap(Data => Data?.employeename)

            const matchStage = {
                $match: {
                    enquirystatus: { $nin: ["Enquiry Purpose"] },
                    approvedremotestatus: "applied",
                    resonablestatus: {
                        $nin: [
                            "Not Joined",
                            "Postponed",
                            "Rejected",
                            "Closed",
                            "Releave Employee",
                            "Absconded",
                            "Hold",
                            "Terminate",
                        ],
                    },
                    ...(listpageaccessmode === "Reporting to Based"

                        ? { reportingto: req.body.username }
                        : {}),
                },
            };

            const pipeline = [
                matchStage,
                {
                    $lookup: {
                        from: "remoteworkmodes",
                        localField: "userIdAsString",
                        foreignField: "employeeid",
                        as: "remoteWorkModeData",
                    },
                },
                {
                    $addFields: {
                        addremoteworkmode: { $ifNull: ["$remoteWorkModeData.addremoteworkmode", []] }, // Set to empty array if null
                    },
                },
                {
                    $project: {
                        empcode: 1,
                        companyname: 1,
                        username: 1,
                        branch: 1,
                        unit: 1,
                        designation: 1,
                        team: 1,
                        department: 1,
                        company: 1,
                        addremoteworkmode: 1,
                        workstation: 1,
                        workstationshortname: 1,
                        workstationinput: 1,
                        approvedremotestatus: 1
                    },
                },
            ]

            result = await User.aggregate(pipeline);

            // Accordig to sector and list filter process
            hierarchyFilter = await Hirerarchi.find({ level: req.body.sector });
            userFilter = hierarchyFilter
                .filter((data) => data.supervisorchoose.includes(req.body.username))
                .map((data) => data.employeename);

            hierarchyDefList = await Hirerarchi.find();
            user = await User.find({ companyname: req.body.username });
            const userFilt = user.length > 0 && user[0].designation;
            const desiGroup = await Designation.find();
            let HierarchyFilt =
                req.body.sector === "all"
                    ? hierarchyDefList
                        .filter((data) =>
                            data.supervisorchoose.includes(req.body.username)
                        )
                        .map((data) => data.designationgroup)
                    : hierarchyFilter
                        .filter((data) =>
                            data.supervisorchoose.includes(req.body.username)
                        )
                        .map((data) => data.designationgroup);
            const DesifFilter = desiGroup.filter((data) =>
                HierarchyFilt.includes(data.group)
            );
            const desigName = DesifFilter.length > 0 && DesifFilter[0].name;
            const SameDesigUser = HierarchyFilt.includes("All")
                ? true
                : userFilt === desigName;
            //Default Loading of List
            answerDef = hierarchyDefList
                .filter((data) => data.supervisorchoose.includes(req.body.username))
                .map((data) => data.employeename);

            hierarchyFinal =
                req.body.sector === "all"
                    ? answerDef.length > 0
                        ? [].concat(...answerDef)
                        : []
                    : hierarchyFilter.length > 0
                        ? [].concat(...userFilter)
                        : [];

            hierarchyMap = hierarchyFinal.length > 0 ? hierarchyFinal : [];

            //solo
            ans1D =
                req.body.sector === "all"
                    ? answerDef.length > 0
                        ? hierarchyDefList.filter((data) =>
                            data.supervisorchoose.includes(req.body.username)
                        )
                        : []
                    : hierarchyFilter.length > 0
                        ? hierarchyFilter.filter((data) =>
                            data.supervisorchoose.includes(req.body.username)
                        )
                        : [];
            result1 =
                ans1D.length > 0
                    ? result
                        .map((item1) => {
                            const matchingItem2 = ans1D.find((item2) =>
                                item2.employeename.includes(item1.companyname)
                            );

                            if (matchingItem2) {
                                const plainItem1 = item1.toObject ? item1.toObject() : item1;
                                return {
                                    ...plainItem1,
                                    level: req.body.sector + "-" + matchingItem2.control,
                                };
                                //   return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                            }
                        })
                        .filter((item) => item !== undefined)
                    : [];

            resulted = result1;

            //team
            let branches = [];
            hierarchySecond = await Hirerarchi.find();

            const subBranch =
                hierarchySecond.length > 0
                    ? hierarchySecond
                        .filter((item) =>
                            item.supervisorchoose.some((name) =>
                                hierarchyMap.includes(name)
                            )
                        )
                        .map((item) => item.employeename)
                        .flat()
                    : "";

            const answerFilterExcel =
                hierarchySecond.length > 0
                    ? hierarchySecond.filter((item) =>

                        item.supervisorchoose.some((name) => hierarchyMap.includes(name))
                    )
                    : [];

            result2 =
                answerFilterExcel.length > 0
                    ? result
                        .map((item1) => {
                            const matchingItem2 = answerFilterExcel.find((item2) =>
                                item2.employeename.includes(item1.companyname)
                            );
                            if (matchingItem2) {
                                // If a match is found, inject the control property into the corresponding item in an1
                                const plainItem1 = item1.toObject ? item1.toObject() : item1;
                                return {
                                    ...plainItem1,
                                    level: req.body.sector + "-" + matchingItem2.control,
                                };
                                // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                            }
                        })
                        .filter((item) => item !== undefined)
                    : [];
            branches.push(...subBranch);

            const ans =
                subBranch.length > 0
                    ? hierarchySecond
                        .filter((item) =>
                            item.supervisorchoose.some((name) => subBranch.includes(name))
                        )
                        .map((item) => item.employeename)
                        .flat()
                    : "";
            const answerFilterExcel2 =
                subBranch.length > 0
                    ? hierarchySecond.filter((item) =>
                        item.supervisorchoose.some((name) => subBranch.includes(name))
                    )
                    : [];

            result3 =
                answerFilterExcel2.length > 0
                    ? result
                        .map((item1) => {
                            const matchingItem2 = answerFilterExcel2.find((item2) =>
                                item2.employeename.includes(item1.companyname)
                            );
                            if (matchingItem2) {
                                const plainItem1 = item1.toObject ? item1.toObject() : item1;

                                return {
                                    ...plainItem1,
                                    level: req.body.sector + "-" + matchingItem2.control,
                                };
                                // If a match is found, inject the control property into the corresponding item in an1
                                // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                            }
                        })
                        .filter((item) => item !== undefined)
                    : [];
            branches.push(...ans);

            const loop3 =
                ans.length > 0
                    ? hierarchySecond
                        .filter((item) =>
                            item.supervisorchoose.some((name) => ans.includes(name))
                        )
                        .map((item) => item.employeename)
                        .flat()
                    : "";

            const answerFilterExcel3 =
                ans.length > 0
                    ? hierarchySecond.filter((item) =>
                        item.supervisorchoose.some((name) => ans.includes(name))
                    )
                    : [];

            result4 =
                answerFilterExcel3.length > 0
                    ? result
                        .map((item1) => {
                            const matchingItem2 = answerFilterExcel3?.find((item2) =>
                                item2.employeename.includes(item1.companyname)
                            );
                            if (matchingItem2) {
                                const plainItem1 = item1.toObject ? item1.toObject() : item1;
                                return {
                                    ...plainItem1,
                                    level: req.body.sector + "-" + matchingItem2.control,
                                };
                                // If a match is found, inject the control property into the corresponding item in an1
                                // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                            }
                        })
                        .filter((item) => item !== undefined)
                    : [];
            branches.push(...loop3);

            const loop4 =
                loop3.length > 0
                    ? hierarchySecond
                        .filter((item) =>
                            item.supervisorchoose.some((name) => loop3.includes(name))
                        )
                        .map((item) => item.employeename)
                        .flat()
                    : [];
            const answerFilterExcel4 =
                loop3.length > 0
                    ? hierarchySecond.filter((item) =>
                        item.supervisorchoose.some((name) => loop3.includes(name))
                    )
                    : [];
            result5 =
                answerFilterExcel4.length > 0
                    ? result
                        .map((item1) => {
                            const matchingItem2 = answerFilterExcel4?.find((item2) =>
                                item2.employeename.includes(item1.companyname)
                            );
                            if (matchingItem2) {
                                const plainItem1 = item1.toObject ? item1.toObject() : item1;
                                return {
                                    ...plainItem1,
                                    level: req.body.sector + "-" + matchingItem2.control,
                                };
                                // If a match is found, inject the control property into the corresponding item in an1
                                // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                            }
                        })
                        .filter((item) => item !== undefined)
                    : [];
            branches.push(...loop4);

            const loop5 =
                loop4.length > 0
                    ? hierarchySecond
                        .filter((item) =>
                            item.supervisorchoose.some((name) => loop4.includes(name))
                        )
                        .map((item) => item.employeename)
                        .flat()
                    : "";
            const answerFilterExcel5 =
                loop4.length > 0
                    ? hierarchySecond.filter((item) =>
                        item.supervisorchoose.some((name) => loop4.includes(name))
                    )
                    : [];
            result6 =
                answerFilterExcel5.length > 0
                    ? result
                        .map((item1) => {
                            const matchingItem2 = answerFilterExcel5?.find((item2) =>
                                item2.employeename.includes(item1.companyname)
                            );
                            if (matchingItem2) {
                                const plainItem1 = item1.toObject ? item1.toObject() : item1;
                                return {
                                    ...plainItem1,
                                    level: req.body.sector + "-" + matchingItem2.control,
                                };
                                // If a match is found, inject the control property into the corresponding item in an1
                                // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                            }
                        })
                        .filter((item) => item !== undefined)
                    : [];
            branches.push(...loop5);

            resultedTeam = [
                ...result2,
                ...result3,
                ...result4,
                ...result5,
                ...result6,
            ];
            //overall Teams List
            myallTotalNames = DataAccessMode ? uniqueNames : [...hierarchyMap, ...branches];
            const matchStage1 = {
                $match: {
                    companyname: { $in: myallTotalNames },
                    enquirystatus: { $nin: ["Enquiry Purpose"] },
                    approvedremotestatus: "applied",
                    resonablestatus: {
                        $nin: [
                            "Not Joined",
                            "Postponed",
                            "Rejected",
                            "Closed",
                            "Releave Employee",
                            "Absconded",
                            "Hold",
                            "Terminate",
                        ],
                    },
                    ...(listpageaccessmode === "Reporting to Based"

                        ? { reportingto: req.body.username }
                        : {}),
                },
            };
            const pipeline1 = [
                matchStage1,
                {
                    $lookup: {
                        from: "remoteworkmodes",
                        localField: "userIdAsString",
                        foreignField: "employeeid",
                        as: "remoteWorkModeData",
                    },
                },
                {
                    $addFields: {
                        addremoteworkmode: { $ifNull: ["$remoteWorkModeData.addremoteworkmode", []] }, // Set to empty array if null
                    },
                },
                {
                    $project: {
                        empcode: 1,
                        companyname: 1,
                        username: 1,
                        branch: 1,
                        unit: 1,
                        designation: 1,
                        team: 1,
                        department: 1,
                        company: 1,
                        addremoteworkmode: 1,
                        workstation: 1,
                        workstationshortname: 1,
                        workstationinput: 1,
                        approvedremotestatus: 1
                    },
                },
            ]

            const finalResult = await User.aggregate(pipeline1);



            overallMyallList = [...resulted, ...resultedTeam];

            const restrictTeam = await Hirerarchi.aggregate([
                {
                    $match: {
                        supervisorchoose:
                            { $in: myallTotalNames }, // Match supervisorchoose with username
                        level: { $in: levelFinal } // Corrected unmatched quotation mark
                    }
                },
                {
                    $lookup: {
                        from: "reportingheaders",
                        let: {
                            teamControlsArray: {
                                $ifNull: ["$pagecontrols", []]
                            }
                        },
                        pipeline: [
                            {
                                $match: {
                                    $expr: {
                                        $and: [
                                            {
                                                $in: [
                                                    "$name",
                                                    "$$teamControlsArray"
                                                ]
                                            }, // Check if 'name' is in 'teamcontrols' array
                                            {
                                                $in: [
                                                    req?.body?.pagename,
                                                    "$reportingnew" // Check if 'menuteamloginstatus' is in 'reportingnew' array
                                                ]
                                            } // Additional condition for reportingnew array
                                        ]
                                    }
                                }
                            }
                        ],
                        as: "reportData" // The resulting matched documents will be in this field
                    }
                },
                {
                    $project: {
                        supervisorchoose: 1,
                        employeename: 1,
                        reportData: 1
                    }
                }
            ]);
            let restrictListTeam = DataAccessMode ? pageControlsData : restrictTeam?.filter(data => data?.reportData?.length > 0)?.flatMap(Data => Data?.employeename)
            let overallRestrictList = DataAccessMode ? restrictListTeam : (req.body.hierachy === "myhierarchy" ?
                restrictList : req.body.hierachy === "allhierarchy" ?
                    restrictListTeam :
                    [...restrictList, ...restrictListTeam]);

            let resultAccessFiltered = DataAccessMode ? finalResult : (
                req.body.hierachy === "myhierarchy" &&
                    (listpageaccessmode === "Hierarchy Based" ||

                        listpageaccessmode === "Overall")
                    ? resulted
                    : req.body.hierachy === "allhierarchy" &&
                        (listpageaccessmode === "Hierarchy Based" ||
                            listpageaccessmode === "Overall")
                        ? resultedTeam
                        : req.body.hierachy === "myallhierarchy" &&
                            (listpageaccessmode === "Hierarchy Based" ||
                                listpageaccessmode === "Overall")
                            ? overallMyallList
                            : result);

            resultAccessFilter = overallRestrictList?.length > 0 ? resultAccessFiltered?.filter(data => overallRestrictList?.includes(data?.companyname)) : [];


        } catch (err) {
            console.log(err, 'err')
            return next(new ErrorHandler("Records not found!", 404));
        }
        return res.status(200).json({
            resultedTeam,
            resultAccessFilter,
            hierarchyFilter,
            DataAccessMode
        });
    }
);


//remote users
exports.getAllRemoteuserFilter = catchAsyncErrors(async (req, res) => {
    try {
        const {
            companyname,
            branchname,
            unitname,
            teamname,
            employeename,
            departmentname,
        } = req.body;

        const matchStage = {
            $match: {
                enquirystatus: { $nin: ["Enquiry Purpose"] },
                resonablestatus: {
                    $nin: [
                        "Not Joined",
                        "Postponed",
                        "Rejected",
                        "Closed",
                        "Releave Employee",
                        "Absconded",
                        "Hold",
                        "Terminate",
                    ],
                },
                ...(companyname?.length ? { company: { $in: companyname } } : {}),
                ...(branchname?.length ? { branch: { $in: branchname } } : {}),
                ...(unitname?.length ? { unit: { $in: unitname } } : {}),
                ...(teamname?.length ? { team: { $in: teamname } } : {}),
                ...(employeename?.length ? { companyname: { $in: employeename } } : {}),
                ...(departmentname?.length ? { department: { $in: departmentname } } : {}),
            },
        };

        const pipeline = [
            matchStage, // Step 1: Filter Users
            {
                $addFields: {
                    userIdAsString: { $toString: "$_id" },
                }
            },
            {
                $lookup: {
                    from: "remoteworkmodes", // Step 2: Lookup remote work modes
                    localField: "userIdAsString", // Match User ID
                    foreignField: "employeeid", // Corresponding field in remoteworkmodes
                    as: "remoteWorkModeData",
                },
            },
            {
                $addFields: {
                    addremoteworkmode: { $ifNull: [{ $arrayElemAt: ["$remoteWorkModeData.addremoteworkmode", 0] }, []] },
                },
            },
            {
                $match: {
                    "addremoteworkmode.0": { $exists: true }, // Ensure non-empty arrays
                },
            },
            {
                $project: {
                    company: 1,
                    workmode: 1,
                    branch: 1,
                    unit: 1,
                    team: 1,
                    empcode: 1,
                    companyname: 1,
                    workstationofficestatus: 1,
                    addremoteworkmode: 1, // Now coming from remoteworkmodes
                    workstationinput: 1,
                    username: 1,
                    approvedremotestatus: 1,
                },
            },
        ];

        const filteredUsers = await User.aggregate(pipeline);

        return res.status(200).json({ filterallremoteuser: filteredUsers });
    } catch (err) {
        return res.status(500).json({ error: "Internal server error" });
    }
});

exports.getAllunallotRemoteuserFilter = catchAsyncErrors(async (req, res) => {
    try {
        const {
            companyname,
            branchname,
            unitname,
            teamname,
            employeename,
            departmentname,
        } = req.body;

        const matchStage = {
            $match: {
                enquirystatus: { $nin: ["Enquiry Purpose"] },
                resonablestatus: {
                    $nin: [
                        "Not Joined",
                        "Postponed",
                        "Rejected",
                        "Closed",
                        "Releave Employee",
                        "Absconded",
                        "Hold",
                        "Terminate",
                    ],
                },
                ...(companyname?.length ? { company: { $in: companyname } } : {}),
                ...(branchname?.length ? { branch: { $in: branchname } } : {}),
                ...(unitname?.length ? { unit: { $in: unitname } } : {}),
                ...(teamname?.length ? { team: { $in: teamname } } : {}),
                ...(employeename?.length ? { companyname: { $in: employeename } } : {}),
                ...(departmentname?.length ? { department: { $in: departmentname } } : {}),
            },
        };

        const pipeline = [
            matchStage, // Step 1: Filter Users
            {
                $addFields: {
                    userIdAsString: { $toString: "$_id" }, // Convert ObjectId to String
                },
            },
            {
                $lookup: {
                    from: "remoteworkmodes",
                    localField: "userIdAsString",
                    foreignField: "employeeid",
                    as: "remoteWorkModeData",
                },
            },
            {
                $addFields: {
                    addremoteworkmode: { $ifNull: ["$remoteWorkModeData.addremoteworkmode", []] }, // Ensure an empty array if null
                },
            },
            {
                $match: {
                    "addremoteworkmode": { $size: 0 }, // Only users without remote work mode data
                },
            },
            {
                $project: {
                    company: 1,
                    workmode: 1,
                    branch: 1,
                    unit: 1,
                    team: 1,
                    empcode: 1,
                    companyname: 1,
                    workstationofficestatus: 1,
                    addremoteworkmode: 1, // This will be empty
                    workstationinput: 1,
                    username: 1,
                    approvedremotestatus: 1,
                },
            },
        ];

        const filteredUsers = await User.aggregate(pipeline);

        return res.status(200).json({ filterallremoteuser: filteredUsers });
    } catch (err) {
        return res.status(500).json({ error: "Internal server error" });
    }
});


exports.updateUsersShiftLogLastObjects = catchAsyncErrors(async (req, res, next) => {
    try {
        const { boardinglogsarray } = req.body;

        // Construct an array of update operations for each item in changecheckedlabel
        const updateOperations = boardinglogsarray.map((changedShifts) => ({
            updateOne: {
                filter: {
                    "boardingLog._id": changedShifts._id,
                },
                update: {
                    $set: {
                        "boardingLog.$.startdate": changedShifts.startdate,
                    },
                },
            },
        }));

        // Execute the update operations one by one to check and update the matching 'Printed' statuses to 'Re-Printed'
        for (const operation of updateOperations) {
            const { filter, update } = operation.updateOne;

            const shiftallot = await User.findOne(filter);

            if (shiftallot) {
                const product = shiftallot.shiftallot.id(filter["boardingLog._id"]);
                await User.updateOne(filter, update);
            }
        }

        return res
            .status(200)
            .json({ message: "User Shift updated successfully" });
    } catch (err) {
        return next(new ErrorHandler("Error updating shift!", 500));
    }
}
);


//get all users data

exports.getUsersAllData = catchAsyncErrors(async (req, res, next) => {
    let usersstatus;

    try {
        usersstatus = await User.find(
            {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"]
                },
                resonablestatus: {
                    $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
            },
            {
                company: 1, branch: 1, unit: 1, team: 1, companyname: 1, empcode: 1, department: 1, designation: 1, _id: 1, resonablestatus: 1, assignExpLog: 1, doj: 1, processlog: 1, floor: 1, area: 1, workstation: 1, workstationinput: 1, username: 1, commonid: 1,

                username: 1, designationlog: 1, process: 1, religion: 1, workmoe: 1, dob: 1, workmode: 1, originalpassword: 1

                // workstationofficestatus: 1, addremoteworkmode:1,workmode: 1, remoteworkmodestatus: 1, area: 1,employeecount: 1,
                // systemmode: 1, doj: 1,companyname: 1, branch: 1, unit: 1, floor: 1, department: 1, team: 1, designation: 1, 
                // empcode: 1, company: 1, role: 1,resonablestatus: 1, 
                // reasondate: 1, reasonname: 1,lastworkday: 1, empreason: 1, enableworkstation: 1, designationlog: 1, departmentlog: 1, assignExpLog: 1, twofaenabled: 1, 
                // twofatempsecret: 1, twofasecret: 1, process: 1, originalpassword: 1, processlog: 1, processtype: 1, processduration: 1, shifttype: 1,
                // boardingLog: 1,  shiftallot: 1, rejoin: 1, reasonablestatusremarks: 1, wordcheck: 1,
                //  remoteworkmodestatus: 1, addremoteworkmode: 1, createdAt: 1
            }

        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!usersstatus) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ usersstatus });
});

exports.updateUsersShiftLogLastObjects = catchAsyncErrors(async (req, res, next) => {
    try {
        const { boardinglogsarray } = req.body;

        // Construct an array of update operations for each item in changecheckedlabel
        const updateOperations = boardinglogsarray.map((changedShifts) => ({
            updateOne: {
                filter: {
                    "boardingLog._id": changedShifts._id,
                },
                update: {
                    $set: {
                        "boardingLog.$.startdate": changedShifts.startdate,
                    },
                },
            },
        }));

        // Execute the update operations one by one to check and update the matching 'Printed' statuses to 'Re-Printed'
        for (const operation of updateOperations) {
            const { filter, update } = operation.updateOne;

            const shiftallot = await User.findOne(filter);

            if (shiftallot) {
                const product = shiftallot.shiftallot.id(filter["boardingLog._id"]);
                await User.updateOne(filter, update);
            }
        }

        return res
            .status(200)
            .json({ message: "User Shift updated successfully" });
    } catch (err) {
        return next(new ErrorHandler("Error updating shift!", 500));
    }
}
);

exports.getAllSalaryFixFilter = catchAsyncErrors(async (req, res, next) => {
    let salaryRange, salaryData, type, process, amountValue, from, to, result, company, branch;
    try {
        // salaryRange = req.body.salaryrange;
        // type = req.body.type;
        // process = req.body.process;
        // company = req.body.company;
        // branch = req.body.branch;
        // amountValue = parseFloat(req.body.amountvalue); 
        // from = parseFloat(req.body.fromamount); 
        // to = parseFloat(req.body.toamount);



        // let query = {
        //     company: company,
        //     branch: branch,
        // }

        const {
            salaryrange: salaryRange,
            type,
            process,
            company,
            branch,
            amountvalue,
            fromamount,
            toamount
        } = req.body;

        const amountValue = parseFloat(amountvalue);
        const from = parseFloat(fromamount);
        const to = parseFloat(toamount);

        const query = {
            company,
            branch,
            ...(type === "Process Wise" && { processqueue: process })
        };

        if (type === "Process Wise") {

            query.processqueue = process
        }


        // Filter and calculate using map/filter
        if (type === "Process Wise") {

            // Fetch the data from the database
            salaryData = await Salaryslab.find(query, {
                salarycode: 1, basic: 1, hra: 1, conveyance: 1, medicalallowance: 1, productionallowance: 1, productionallowancetwo: 1,
                otherallowance: 1,
                processqueue: 1,

            });
            // result = salaryData

            // let salaryCodes = [...new Set(salaryData.map(item => item.processqueue))]

            const targetPoints = await Targetpoints.find({
                code: process, company: company,
                branch: branch,
            }, { points: 1, processcode: 1 });


            result = salaryData.map(item => {
                const target = targetPoints.find(d => d.processcode === item.salarycode)
                let totalValue = item.basic + item.hra + item.conveyance + item.medicalallowance + item.productionallowance + item.otherallowance

                return {
                    _id: item._id,
                    salarycode: item.salarycode,
                    totalValue: totalValue,
                    targetPointsValue: target ? target.points : null
                };
            })

        } else {

            salaryData = await Salaryslab.find(query, {
                salarycode: 1, basic: 1, hra: 1, conveyance: 1, medicalallowance: 1, productionallowance: 1, productionallowancetwo: 1,
                otherallowance: 1,
                processqueue: 1,

            });


            salaryData = salaryData.filter(item => {

                let totalValue = item.basic + item.hra + item.conveyance + item.medicalallowance + item.productionallowance + item.otherallowance
                if (salaryRange === "Less Than") return totalValue < amountValue;
                if (salaryRange === "Greater Than") return totalValue > amountValue;
                if (salaryRange === "Exact") return totalValue === amountValue;
                if (salaryRange === "Between")
                    return totalValue >= from && totalValue <= to;
                return true; // Default to include all if no range is specified
            });

            let salaryCodes = [...new Set(salaryData.map(item => item.processqueue))]

            const targetPoints = await Targetpoints.find({
                code: { $in: salaryCodes }, company: company,
                branch: branch,
            }, { points: 1, processcode: 1 });


            result = salaryData.map(item => {
                const target = targetPoints.find(d => d.processcode === item.salarycode)
                let totalValue = item.basic + item.hra + item.conveyance + item.medicalallowance + item.productionallowance + item.otherallowance
                return {
                    _id: item._id,
                    salarycode: item.salarycode,
                    totalValue: totalValue,
                    targetPointsValue: target ? target.points : null
                };
            })

        }



        // Fetch and add target points for each item
        //     result = await Promise.all(

        //      return   {

        //         let salaryCodes = salaryData.map(item => item.salarycode)

        //         const targetPoints = await Targetpoints.find({
        //             processcode:{$in:{ salaryCodes}}
        //         });


        //         salaryData.map(async item => {

        //             return {
        //                 _id: item._id,
        //                 salarycode: item.salarycode,
        //                 totalValue: item.totalValue,
        //                 targetPointsValue: targetPoints ? targetPoints.points : null
        //             };
        //         })
        //   }  );
        return res.status(200).json({ result });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }


});


// get All user => /api/users
exports.getAllUsersWithoutStatus = catchAsyncErrors(async (req, res, next) => {
    let users;

    try {
        users = await User.find(
            {
            },
            {
                status: 1,
                resonablestatus: 1,
                reasonname: 1,
                lastworkday: 1,
                rejoin: 1,
                reasonablestatusremarks: 1,
                department: 1,
                dob: 1,
                gender: 1,
                maritalstatus: 1,
                bloodgroup: 1,
                location: 1,
                contactpersonal: 1,
                designationlog: 1,
                processlog: 1,
                boardingLog: 1, attendancemode: 1,
                company: 1,
                addremoteworkmode: 1,
                reasondate: 1,
                empreason: 1,
                percentage: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                username: 1,
                usernameautogenerate: 1,
                workmode: 1,
                email: 1,
                unit: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,

                branch: 1,
                designation: 1,
                floor: 1,
                shift: 1,
                reportingto: 1,
                experience: 1,
                doj: 1,
                dot: 1,
                bankname: 1,
                bankdetails: 1,
                bankbranchname: 1,
                accountholdername: 1,
                accountnumber: 1,
                ifsccode: 1,
                shifttiming: 1,
                shiftgrouping: 1,
                legalname: 1,
                callingname: 1,
                pdoorno: 1,
                pstreet: 1,
                parea: 1,
                plandmark: 1,
                ptaluk: 1,
                ppost: 1,
                ppincode: 1,
                pcountry: 1,
                pstate: 1,
                pcity: 1,
                cdoorno: 1,
                cstreet: 1,
                carea: 1,
                role: 1,
                clandmark: 1,
                ctaluk: 1,
                cpost: 1,
                cpincode: 1,
                ccountry: 1,
                cstate: 1,
                ccity: 1,
                reasondate: 1,
                process: 1,
                workstation: 1,
                weekoff: 1,
                originalpassword: 1,
                enquirystatus: 1,
                area: 1,
                enableworkstation: 1,
                wordcheck: 1,
                shiftallot: 1,
                firstname: 1,
                lastname: 1,
                employeecount: 1,
                emergencyno: 1,
                name: 1,
                salarysetup: 1,
                mode: 1,
                salarycode: 1,
                basic: 1,
                hra: 1,
                conveyance: 1,
                medicalallowance: 1,
                productionallowance: 1,
                otherallowance: 1,
                productionallowancetwo: 1,
                pffromdate: 1,
                pfenddate: 1,
                esifromdate: 1,
                esienddate: 1,
                pfesistatus: 1,

                aadhar: 1,
                panno: 1,
                panstatus: 1, panrefno: 1,
                candidateid: 1,
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: users.length, users });
});


exports.getAllFilteredUsers = catchAsyncErrors(async (req, res, next) => {
    const {
        companyname,
        branchname,
        unitname,
        teamname,
        employeename,
        departmentname,
    } = req.body;

    const filter = {
        enquirystatus: { $nin: ["Enquiry Purpose"] },
        resonablestatus: {
            $nin: [
                "Not Joined",
                "Postponed",
                "Rejected",
                "Closed",
                "Releave Employee",
                "Absconded",
                "Hold",
                "Terminate",
            ],
        },
        ...(companyname && Array.isArray(companyname) && companyname.length > 0
            ? { company: { $in: companyname } }
            : {}),
        ...(branchname && Array.isArray(branchname) && branchname.length > 0
            ? { branch: { $in: branchname } }
            : {}),
        ...(unitname && Array.isArray(unitname) && unitname.length > 0
            ? { unit: { $in: unitname } }
            : {}),
        ...(teamname && Array.isArray(teamname) && teamname.length > 0
            ? { team: { $in: teamname } }
            : {}),
        ...(employeename && Array.isArray(employeename) && employeename.length > 0
            ? { companyname: { $in: employeename } }
            : {}),
        ...(departmentname &&
            Array.isArray(departmentname) &&
            departmentname.length > 0
            ? { department: { $in: departmentname } }
            : {}),
    };

    try {
        const empDocs = await EmployeeDocuments.find(
            {},
            { profileimage: 1, commonid: 1 }
        ).lean();

        const pageSize = 100;
        let page = 0;
        let users;
        let allUsers = [];

        do {
            users = await User.find(filter, {
                status: 1,
                resonablestatus: 1,
                reasonname: 1,
                lastworkday: 1,
                rejoin: 1,
                reasonablestatusremarks: 1,
                department: 1,
                dob: 1,
                gender: 1,
                maritalstatus: 1,
                bloodgroup: 1,
                location: 1,
                contactpersonal: 1,
                designationlog: 1,
                contactfamily: 1,
                ctaluk: 1,
                dom: 1,
                processlog: 1,
                boardingLog: 1, attendancemode: 1,
                company: 1,
                reasondate: 1,
                empreason: 1,
                percentage: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                username: 1,
                usernameautogenerate: 1,
                workmode: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,
                unit: 1,
                branch: 1,
                designation: 1,
                floor: 1,
                shift: 1,
                reportingto: 1,
                experience: 1,
                doj: 1,
                dot: 1,
                bankname: 1,
                bankbranchname: 1,
                accountholdername: 1,
                accountnumber: 1,
                ifsccode: 1,
                shifttiming: 1,
                shiftgrouping: 1,
                legalname: 1,
                callingname: 1,
                pdoorno: 1,
                pstreet: 1,
                candidateid: 1,
                parea: 1,
                plandmark: 1,
                ptaluk: 1,
                ppost: 1,
                ppincode: 1,
                pcountry: 1,
                pstate: 1,
                pcity: 1,
                cdoorno: 1,
                cstreet: 1,
                carea: 1,
                role: 1,
                clandmark: 1,
                ctaluk: 1,
                cpost: 1,
                cpincode: 1,
                ccountry: 1,
                cstate: 1,
                ccity: 1,
                reasondate: 1,
                process: 1,
                workstation: 1,
                weekoff: 1,
                originalpassword: 1,
                enquirystatus: 1,
                area: 1,
                enableworkstation: 1,
                wordcheck: 1,
                shiftallot: 1,
                firstname: 1,
                lastname: 1,
                employeecount: 1,
                emergencyno: 1,
                name: 1,
                salarysetup: 1,
                mode: 1,
                salarycode: 1,
                basic: 1,
                hra: 1,
                conveyance: 1,
                medicalallowance: 1,
                productionallowance: 1,
                otherallowance: 1,
                productionallowancetwo: 1,
                pffromdate: 1,
                pfenddate: 1,
                esifromdate: 1,
                esienddate: 1,
                pfesistatus: 1,
                aadhar: 1,
                panno: 1,
                panstatus: 1,
                panrefno: 1, religion: 1,
                attendancemode: 1,
                companyemail: 1,
                employeecount: 1,
                rocketchatemail: 1,
                rocketchatroles: 1,
            })
                .lean()
                .skip(page * pageSize)
                .limit(pageSize);

            if (!users || users.length === 0) break;

            const mappedUsers = users.map((data) => {
                const foundData = empDocs.find(
                    (item) => item?.commonid?.toString() === data?._id?.toString()
                );
                return {
                    ...data,
                    profileimage: foundData ? foundData.profileimage : "",
                };
            });

            allUsers = [...allUsers, ...mappedUsers];
            page++;
        } while (users.length === pageSize);

        if (allUsers.length === 0) {
            return next(new ErrorHandler("Users not found", 400));
        }

        return res.status(200).json({ count: allUsers.length, users: allUsers });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
});

exports.getAllUsersnew = catchAsyncErrors(async (req, res, next) => {
    let users;

    try {
        users = await User.find(
            {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
                resonablestatus: {
                    $nin: [
                        "Not Joined",
                        "Postponed",
                        "Rejected",
                        "Closed",
                        "Releave Employee",
                        "Absconded",
                        "Hold",
                        "Terminate",
                    ],
                },
            },
            {
                company: 1,
                branch: 1, unit: 1, team: 1, empcode: 1, companyname: 1
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: users.length, users });
});

exports.getAllSalaryFixFilterReport = catchAsyncErrors(async (req, res, next) => {
    try {
        const {
            salaryrange,
            type,
            process,
            amountvalue,
            fromamount,
            toamount,
            company,
            branch,
            batchNumber,
            batchSize,
        } = req.body;

        const amountValue = parseFloat(amountvalue);
        const fromAmount = parseFloat(fromamount);
        const toAmount = parseFloat(toamount);
        const skip = (batchNumber - 1) * batchSize;
        const limit = batchSize;

        // Define the match conditions based on the inputs
        let matchConditions = {
            company: { $in: company },
            branch: { $in: branch },
        };

        if (type === "Process Wise") {
            matchConditions.salarycode = new RegExp("^" + process);
        }

        switch (salaryrange) {
            case "Less Than":
                matchConditions.totalValue = { $lt: amountValue };
                break;
            case "Greater Than":
                matchConditions.totalValue = { $gt: amountValue };
                break;
            case "Exact":
                matchConditions.totalValue = { $eq: amountValue };
                break;
            case "Between":
                matchConditions.totalValue = { $gte: fromAmount, $lte: toAmount };
                break;
        }

        // Perform the optimized aggregation query
        const results = await Salaryslab.aggregate([
            {
                $addFields: {
                    totalValue: {
                        $add: [
                            "$basic",
                            "$hra",
                            "$conveyance",
                            "$medicalallowance",
                            "$productionallowance",
                            "$otherallowance",
                        ],
                    },
                },
            },
            { $match: matchConditions },
            { $skip: skip },
            { $limit: limit },
            {
                $lookup: {
                    from: "targetpoints",
                    localField: "salarycode",
                    foreignField: "processcode",
                    as: "targetpoints",
                },
            },
            {
                $addFields: {
                    targetPointsValue: { $arrayElemAt: ["$targetpoints.points", 0] },
                },
            },
            {
                $project: {
                    targetPointsValue: 1,
                    totalValue: 1,
                    salarycode: 1,
                    company: 1,
                    branch: 1,
                    processqueue: 1,
                },
            },
        ]).exec();

        // Execute the process team query in parallel
        const processTeamData = await ProcessTeam.find(
            {
                company: { $in: company },
                branch: { $in: branch },
                process: { $in: results.map((r) => r.processqueue) },
            },
            { unit: 1, team: 1, company: 1, branch: 1, process: 1 }
        ).lean();

        // Combine the results
        const combinedArray = processTeamData.flatMap((mainItem) =>
            results.map((subItem) => ({
                ...mainItem,
                ...subItem,
                _id: new ObjectId(),
            }))
        );

        // Respond with the result
        return res.status(200).json({ results: combinedArray });
    } catch (err) {
        return res.status(500).json({
            message: "Internal Server Error",
            error: err.message,
        });
    }
});

// check duplicate employeename in create
exports.checkduplicateemployeenamecreate = catchAsyncErrors(
    async (req, res, next) => {
        try {
            const { firstname, lastname, employeename, dob } = req.body;

            const dobParts = dob.split("-");
            const day = dobParts[2];
            const month = dobParts[1];
            const year = dobParts[0];

            // Generate potential company names
            const potentialCompanyNames = [
                employeename,
                `${employeename}${day}`,
                `${employeename}${day}${month}`,
                `${employeename}${day}${month}${year}`,
            ];

            // Check for duplicates in one go
            let existingUser = await User.findOne(
                {
                    $and: [
                        { firstname: { $regex: new RegExp(firstname, "i") } },
                        { lastname: { $regex: new RegExp(lastname, "i") } },
                        {
                            companyname: {
                                $in: potentialCompanyNames.map((name) => new RegExp(name, "i")),
                            },
                        },
                    ],
                }
                // { firstname: 1, lastname: 1, companyname: 1 }
            );

            let currentCompanyName = employeename;

            if (existingUser) {
                // Try to find the first available name in parallel
                const nameChecks = potentialCompanyNames.map((name) =>
                    User.findOne(
                        {
                            $and: [
                                { firstname: { $regex: new RegExp(firstname, "i") } },
                                { lastname: { $regex: new RegExp(lastname, "i") } },
                                { companyname: { $regex: new RegExp(name, "i") } },
                            ],
                        }
                        // { firstname: 1, lastname: 1, companyname: 1 }
                    )
                );

                const results = await Promise.all(nameChecks);
                for (let i = 0; i < results.length; i++) {
                    if (!results[i]) {
                        currentCompanyName = potentialCompanyNames[i];
                        break;
                    }
                }

                // If still a duplicate, append counter until a unique name is found
                if (results.every((result) => result)) {
                    let counter = 1;
                    while (existingUser) {
                        currentCompanyName = `${employeename}${day}${month}${year}${counter}`;
                        existingUser = await User.findOne(
                            {
                                $and: [
                                    { firstname: { $regex: new RegExp(firstname, "i") } },
                                    { lastname: { $regex: new RegExp(lastname, "i") } },
                                    {
                                        companyname: {
                                            $regex: new RegExp(currentCompanyName, "i"),
                                        },
                                    },
                                ],
                            }
                            // { firstname: 1, lastname: 1, companyname: 1 }
                        );
                        counter++;
                    }
                }

                res.status(200).json({
                    exist: true,
                    uniqueCompanyName: currentCompanyName,
                });
            } else {
                res.status(200).json({
                    exist: false,
                    uniqueCompanyName: employeename,
                });
            }
        } catch (err) {
            return next(new ErrorHandler("Records not found!", 404));
        }
    }
);


// check duplicate employeename in edit
exports.checkduplicateemployeenameedit = catchAsyncErrors(
    async (req, res, next) => {
        const { firstname, lastname, employeename, id } = req.body;

        const existingUser = await User.findOne({
            $and: [
                { _id: { $ne: id } },
                { firstname: { $regex: new RegExp(firstname, "i") } },
                { lastname: { $regex: new RegExp(lastname, "i") } },
                { companyname: { $regex: new RegExp(employeename, "i") } },
            ],
        });

        if (existingUser) {
            res.status(200).json({ exist: true });
        } else {
            res.status(200).json({ exist: false });
        }
    }
);

exports.updateUserPwdReset = catchAsyncErrors(async (req, res, next) => {
    const id = req.params.id;

    const { password, originalpassword, resetstatus } = req.body
    const salt = await bcrypt.genSalt(10);
    const hashPassword = await bcrypt.hash(password, salt);
    const upuserone = await User.findByIdAndUpdate(id, {
        password: hashPassword,
        originalpassword,
        resetstatus
    });

    if (!upuserone) {
        return next(new ErrorHandler("User not found", 404));
    }

    return res.status(200).json({ message: "Updated successfully!" });
});
exports.getAllUserTotalShiftDays = catchAsyncErrors(async (req, res, next) => {
    let resultshiftallot = [];
    let graceTime;
    let clockOutHours;
    let lateclockincount;
    let earlyclockoutcount;
    let onclockout;
    let earlyclockin;
    let earlyclockout;
    let lateclockin;
    let afterlateclockin;
    let beforeearlyclockout;
    let finaluser = [];
    const { ismonth, isyear, pageSize, page,
        // employees
    } = req.body;

    try {
        const monthNames = ["January", "February", "March", "April", "May", "June",
            "July", "August", "September", "October", "November", "December"
        ];

        let querydeptmonth = {
            monthname: monthNames[ismonth - 1],
            year: isyear
        }
        let [usersAll, depMonthSet, controlcriteria, holidays, leavetype] = await Promise.all([
            User.find(
                {
                    // resonablestatus: {
                    //     $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                    // },
                    enquirystatus: {
                        $nin: ["Enquiry Purpose"],
                    },
                    // companyname: { $in: employees }

                }, {}
            ).skip((page - 1) * pageSize).limit(pageSize),


            DepartmentMonth.find(querydeptmonth, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 }),
            ControlCriteria.find(),
            Holiday.find({}, { date: 1, company: 1, applicablefor: 1, unit: 1, team: 1, employee: 1, noofdays: 1 }),
            Leavetype.find({}, { leavetype: 1, code: 1 })
        ])

        const resultDateArray = depMonthSet.reduce((acc, curr) => {
            // Compare and update the earliest fromdate
            if (new Date(curr.fromdate) < new Date(acc.fromdate)) {
                acc.fromdate = curr.fromdate;
            }
            // Compare and update the latest todate
            if (new Date(curr.todate) > new Date(acc.todate)) {
                acc.todate = curr.todate;
            }
            return acc;
        }, {
            fromdate: depMonthSet[0].fromdate, // Start with the first fromdate
            todate: depMonthSet[0].todate      // Start with the first todate
        });

        function formatDate(dateString) {
            const [day, month, year] = dateString.split("-");
            return `${year}-${month}-${day}`;
        }

        let attFromDate = (resultDateArray.fromdate)
        let attToDate = (resultDateArray.todate)
        const fromDateSet = [...new Set(depMonthSet.map(d => d.fromdate))];

        let users = usersAll.map(item => {
            let findUserDeprtment = item.department;

            if (item.departmentlog && item.departmentlog.length > 1) {
                // const findDept = item.departmentlog.find(dept => fromDateSet.includes(dept.startdate) );
                const sortedDepartmentLog = item.departmentlog.sort((a, b) => new Date(b.startdate) - new Date(a.startdate));

                const findDept = sortedDepartmentLog.find(dept =>
                    fromDateSet.includes(dept.startdate) ||
                    fromDateSet.some(fromDate => new Date(fromDate) > new Date(dept.startdate))
                );
                findUserDeprtment = findDept ? findDept.department : "";
            } else if (item.departmentlog && item.departmentlog.length > 0) {
                findUserDeprtment = new Date(item.doj) >= new Date(item.departmentlog[0].startdate) ? item.departmentlog[0].department : ""
            }

            // if (department.includes(findUserDeprtment)) {
            return {
                ...item._doc, // Use _doc to avoid including Mongoose metadata
                department: findUserDeprtment,
            };

            // }

            // return null; // Exclude users who don't match the department
        }).filter(item => item !== null);

        const userIds = users.map(user => user._id);
        const userCds = users.map(user => user.companyname);
        const [attendance, allLeaveStatus, permission] = await Promise.all([
            Attendance.find({ userid: { $in: userIds }, createdAt: { $gte: attFromDate, $lte: attToDate } }),
            ApplyLeave.find({ employeename: { $in: userCds } }),
            Permission.find({ employeename: { $in: userCds } }, { employeeid: 1, date: 1, status: 1, applytype: 1, compensationstatus: 1, compensationapplytype: 1, requesthours: 1, shiftmode: 1, })

        ])

        clockOutHours = controlcriteria[0].clockout;
        lateclockincount = controlcriteria[0].lateclockincount;
        earlyclockoutcount = controlcriteria[0].earlyclockoutcount;
        onclockout = controlcriteria[0].onclockout;
        earlyclockin = controlcriteria[0].earlyclockin;
        lateclockin = controlcriteria[0].lateclockin;
        earlyclockout = controlcriteria[0].earlyclockout;
        afterlateclockin = controlcriteria[0].afterlateclockin;
        beforeearlyclockout = controlcriteria[0].afterlateclockin;


        finaluser = users?.flatMap((item, index) => {

            let isEmployeeGrace = controlcriteria[0].todos && controlcriteria[0].todos.find(d => d.company === item.company &&
                d.branch === item.branch && d.unit === item.unit && d.team === item.team &&
                d.employeename === item.companyname
            )

            if (isEmployeeGrace) {
                graceTime = isEmployeeGrace.employeegracetime;
            }
            else {
                graceTime = controlcriteria[0].gracetime;
            }

            let userDates = [];


            // Remove duplicate entries with the most recent entry
            const uniqueEntriesDep = {};
            item.departmentlog?.forEach(entry => {
                const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                const key = entry.startdate;

                if (!(key in uniqueEntriesDep)) {
                    uniqueEntriesDep[key] = entry;
                }
            });

            const comparedDate = depMonthSet?.filter((d) => d.department === item.department);
            const dojDate = item?.boardingLog.length > 0 ?
                item?.boardingLog[0].startdate
                : item?.doj;

            if (comparedDate && comparedDate.length > 0) {
                comparedDate?.forEach((dep) => {
                    if (!dep.fromdate && !dep.todate) {
                        return '';
                    }

                    if (!item.doj) {
                        return "";
                    }

                    const [year2, month2, day2] = dojDate?.split('-').map(Number);
                    const joiningDate = new Date(year2, month2 - 1, day2);
                    const [year1, month1, day1] = dep.fromdate?.split('-').map(Number);
                    const [year, month, day] = dep.todate?.split('-').map(Number);
                    const lastDate = new Date(year, month - 1, day);
                    const firstDate = new Date(year1, month1 - 1, day1);


                    if (joiningDate < firstDate) {
                        // Check if the shift date is before or equal to the current date
                        if (lastDate >= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(firstDate);
                            // Loop through the dates in the range
                            while (startDate <= currentDateAttStatus) {
                                userDates.push({
                                    formattedDate: format(startDate, 'dd/MM/yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        } else if (lastDate <= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(firstDate);
                            // Loop through the dates in the range
                            while (startDate <= lastDate) {
                                userDates.push({
                                    formattedDate: format(startDate, 'dd/MM/yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        }
                    } else {
                        // Check if the shift date is before or equal to the current date
                        if (lastDate >= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(joiningDate);
                            // Loop through the dates in the range
                            while (startDate <= currentDateAttStatus) {
                                userDates.push({
                                    formattedDate: format(startDate, 'dd/MM/yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        }
                        else if (lastDate <= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(joiningDate);
                            // Loop through the dates in the range
                            while (startDate <= lastDate) {
                                userDates.push({
                                    formattedDate: format(startDate, 'dd/MM/yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        }
                    }
                });
            }
            else {
                const [year2, month2, day2] = dojDate?.split('-').map(Number);
                const joiningDate = new Date(year2, month2 - 1, day2);
                // Calculate the start date of the month based on the selected month
                const startDate = new Date(isyear, ismonth - 1, 1);

                const endDate = new Date(startDate);
                endDate.setMonth(endDate.getMonth() + 1);
                endDate.setDate(endDate.getDate() - 1);

                if (joiningDate < startDate) {
                    // Check if the shift date is before or equal to the current date
                    if (endDate >= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            userDates.push({
                                formattedDate: format(currentDate1, 'dd/MM/yyyy'),
                                dayName: format(currentDate1, 'EEEE'),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    } else if (endDate <= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            userDates.push({
                                formattedDate: format(currentDate1, 'dd/MM/yyyy'),
                                dayName: format(currentDate1, 'EEEE'),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    }
                } else {
                    // Check if the shift date is before or equal to the current date
                    if (endDate >= currentDateAttStatus) {
                        // If matched, push the range from 'fromdate' to 'todate'
                        const startDate = new Date(joiningDate);
                        // Loop through the dates in the range
                        while (startDate <= currentDateAttStatus) {
                            userDates.push({
                                formattedDate: format(startDate, 'dd/MM/yyyy'),
                                dayName: format(startDate, 'EEEE'),
                                dayCount: startDate.getDate(),
                            });
                            startDate.setDate(startDate.getDate() + 1);
                        }
                    } else if (endDate <= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            userDates.push({
                                formattedDate: format(currentDate1, 'dd/MM/yyyy'),
                                dayName: format(currentDate1, 'EEEE'),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    }
                }
            }

            item.shiftallot?.map(allot => {
                resultshiftallot.push({ ...allot })
            })

            const filteredMatchingDoubleShiftItem = resultshiftallot?.filter(val => val && val.empcode === item.empcode && val.adjstatus === 'Approved');

            // Filter out the dates that have matching 'Shift Adjustment' todates
            let removedUserDates = userDates.filter(date => {
                // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
                const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem.find(item => item && item.todate === date.formattedDate && item.adjustmenttype === 'Shift Adjustment');

                // If there is no matching 'Shift Adjustment', keep the date
                return !matchingShiftAdjustmentToDate;
            });

            // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
            let uniqueEntries = new Set();

            // Iterate over removedUserDates and add unique entries to the Set
            userDates.forEach(date => {
                uniqueEntries.add(JSON.stringify({
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    shiftMode: 'Main Shift',
                    weekNumberInMonth: date.weekNumberInMonth,
                }));
            });

            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach(item => {
                const [day, month, year] = item._doc.adjdate?.split('/')
                let newFormattedDate = new Date(`${year}-${month}-${day}`);

                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(JSON.stringify({
                        formattedDate: item._doc.adjdate,
                        dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
                        dayCount: parseInt(moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")),
                        shiftMode: 'Second Shift',
                        weekNumberInMonth: (getWeekNumberInMonth(newFormattedDate) === 1 ? `${getWeekNumberInMonth(newFormattedDate)}st Week` :
                            getWeekNumberInMonth(newFormattedDate) === 2 ? `${getWeekNumberInMonth(newFormattedDate)}nd Week` :
                                getWeekNumberInMonth(newFormattedDate) === 3 ? `${getWeekNumberInMonth(newFormattedDate)}rd Week` :
                                    getWeekNumberInMonth(newFormattedDate) > 3 ? `${getWeekNumberInMonth(newFormattedDate)}th Week` : '')
                    }));
                }
            });

            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries).map(entry => JSON.parse(entry));

            function sortUserDates(dates) {
                return dates.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);
            const createdUserDates = sortedCreatedUserDates?.filter(d => {
                const filterData = userDates.some(val => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date) => {
                let filteredRowData = resultshiftallot?.filter((val) => val.empcode == item.empcode);
                const matchingItem = filteredRowData?.find(item => item && item.adjdate == date.formattedDate);
                const matchingItemAllot = filteredRowData?.find(item => item && formatDate(item.date) == date.formattedDate);
                const matchingDoubleShiftItem = filteredRowData?.find(item => item && item.todate === date.formattedDate);
                const matchingRemovedItem = filteredRowData?.find(item => item?._doc?.removedshiftdate === date.formattedDate);
                const matchingAssignShiftItem = filteredRowData?.find(item => item?._doc?.adjdate === date.formattedDate && item?._doc?.adjstatus === 'Approved' && item?._doc?.adjustmenttype === 'Assign Shift');

                const filterBoardingLog = item.boardingLog && item.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                    // return item;
                });
                let attendanceFiltered = attendance.filter(d => d.username === item.username)


                const depMonthSetFiltered = depMonthSet.filter(d => d.department === item.department)
                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item.weekoff?.includes(date.dayName);
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, item.departmentlog, depMonthSetFiltered) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                const row = {
                    id: `${item._id.toString()}_${date.formattedDate}_${date.shiftMode}`,
                    userid: item._id.toString(),
                    company: item.company,
                    branch: item.branch,
                    unit: item.unit,
                    team: item.team,
                    department: item.department,
                    username: item.companyname,
                    empcode: item.empcode,
                    weekoff: item.weekoff,
                    boardingLog: item.boardingLog,
                    shiftallot: item.shiftallot,
                    doj: dojDate,
                    shift: getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered, matchingRemovedItem, matchingAssignShiftItem),
                    date: `${date.formattedDate} ${date.dayName} ${date.dayCount}`,
                    role: item.role,
                    rowformattedDate: date.formattedDate,
                    dayName: date.dayName,
                    shiftMode: date.shiftMode,
                    reasondate: item.reasondate,
                    clockin: checkGetClockInTime(attendanceFiltered, item._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered, matchingRemovedItem, matchingAssignShiftItem),
                        date.shiftMode,
                    ),
                    clockout: checkGetClockOutTime(attendanceFiltered, item._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered, matchingRemovedItem, matchingAssignShiftItem),
                        date.shiftMode,
                    ),
                    clockinstatus: checkClockInStatus(
                        checkGetClockInTime(attendanceFiltered, item._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered, matchingRemovedItem, matchingAssignShiftItem),
                        graceTime, allLeaveStatus, holidays,
                        checkGetClockInDate(attendanceFiltered, item._id.toString(), date.formattedDate, date.shiftMode,), item.branch, item.empcode, item.company, date.formattedDate, item.unit, item.team, item.companyname,
                        earlyclockin, lateclockin, afterlateclockin, leavetype, permission,
                        checkGetClockOutTime(attendanceFiltered, item._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        date.shiftMode, checkWeekOffPresentStatus(attendanceFiltered, item._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    clockoutstatus: checkClockOutStatus(
                        checkGetClockOutTime(attendanceFiltered, item._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        checkGetClockInTime(attendanceFiltered, item._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered, matchingRemovedItem, matchingAssignShiftItem),
                        clockOutHours, checkGetClockInDate(attendanceFiltered, item._id.toString(), date.formattedDate, date.shiftMode,),
                        allLeaveStatus, holidays, item.branch, item.empcode, item.company, date.formattedDate, item.unit, item.team, item.companyname, onclockout,
                        earlyclockout, beforeearlyclockout,
                        checkGetClockInAutoStatus(attendanceFiltered, item._id.toString(), date.formattedDate, date.shiftMode,),
                        leavetype, permission, date.shiftMode, checkWeekOffPresentStatus(attendanceFiltered, item._id.toString(), date.formattedDate, date.shiftMode,)
                    ),
                    attendanceautostatus: checkAttendanceStatus(attendanceFiltered, item._id.toString(), date.formattedDate, date.shiftMode,),
                    lateclockincount: lateclockincount,
                    earlyclockoutcount: earlyclockoutcount,
                    totalnumberofdays: getTotalMonthDaysUser(item.department, depMonthSetFiltered, ismonth, isyear),
                    empshiftdays: getTotalMonthDaysForEmpUser(dojDate, item.department, depMonthSetFiltered, ismonth, isyear),
                    totalcounttillcurrendate: getTotalMonthsCurrentDateCountUser(dojDate, item.department, depMonthSetFiltered, ismonth, isyear),
                    totalshift: getTotalShiftHoursUser(item._id.toString(), createdUserDates, attendanceFiltered),
                    weekoffpresentstatus: checkWeekOffPresentStatus(attendanceFiltered, item._id.toString(), date.formattedDate, date.shiftMode,),
                };
                return row;
            });

            return userRows;

        });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finaluser) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ finaluser });
});
// get All user => /api/allusersemployee
exports.getAllTheUsersEmployee = catchAsyncErrors(async (req, res, next) => {
    let alluseremployee;

    try {
        alluseremployee = await User.find({},
            // {
            //     enquirystatus: {
            //         $nin: ["Enquiry Purpose"],
            //     },
            //     workmode: {
            //         $ne: "Internship",
            //     },
            // resonablestatus: {
            //     $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
            // },
            // },
            {
                status: 1,
                empcode: 1,
                nexttime: 1,
                companyname: 1,
                username: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,
                addremoteworkmode: 1,
                branch: 1,
                unit: 1,
                team: 1,
                company: 1,
                shift: 1,
                experience: 1,
                doj: 1,
                dot: 1,
                fathername: 1,
                mothername: 1,
                contactfamily: 1,

                workmode: 1,
                internstatus: 1,
                resonablestatus: 1,
                reasonname: 1,
                lastworkday: 1,
                rejoin: 1,
                reasonablestatusremarks: 1,
                department: 1,
                dob: 1,
                company: 1,
                reasondate: 1,
                empreason: 1,
                percentage: 1,
                doj: 1,
                dot: 1,
                role: 1,
                assignExpLog: 1,
                resonablestatus: 1,
                rejoin: 1,
                reasonablestatusremarks: 1,
                department: 1,
                dob: 1,
                gender: 1,
                maritalstatus: 1,
                bloodgroup: 1,
                location: 1,
                aadhar: 1,
                panno: 1,

                contactpersonal: 1,
                designationlog: 1,
                processlog: 1,
                boardingLog: 1, attendancemode: 1,
                company: 1,
                reasondate: 1,
                empreason: 1,
                percentage: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                username: 1,
                usernameautogenerate: 1,
                workmode: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,

                unit: 1,
                branch: 1,
                designation: 1,
                floor: 1,
                shift: 1,
                reportingto: 1,
                experience: 1,
                doj: 1,
                dot: 1,
                bankdetails: 1,
                bankname: 1,
                bankbranchname: 1,
                accountholdername: 1,
                accountnumber: 1,
                ifsccode: 1,
                shifttiming: 1,
                shiftgrouping: 1,
                legalname: 1,
                pdoorno: 1,
                pstreet: 1,
                parea: 1,
                plandmark: 1,
                ptaluk: 1,
                ppost: 1,
                ppincode: 1,
                pcountry: 1,
                pstate: 1,
                pcity: 1,
                cdoorno: 1,
                cstreet: 1,
                carea: 1,
                role: 1,
                clandmark: 1,
                ctaluk: 1,
                cpost: 1,
                cpincode: 1,
                ccountry: 1,
                cstate: 1,
                ccity: 1,
                reasondate: 1,
                process: 1,
                workstation: 1,
                weekoff: 1,
                originalpassword: 1,
                enquirystatus: 1,
                area: 1,
                enableworkstation: 1,
                wordcheck: 1,
                shiftallot: 1,
                firstname: 1,
                lastname: 1,
                employeecount: 1,
                emergencyno: 1,
                name: 1,
                salarysetup: 1,
                mode: 1,
                salarycode: 1,
                basic: 1,
                hra: 1,
                conveyance: 1,
                medicalallowance: 1,
                productionallowance: 1,
                otherallowance: 1,
                productionallowancetwo: 1,
                pffromdate: 1,
                pfenddate: 1,
                esifromdate: 1,
                esienddate: 1,
                pfesistatus: 1,
                remoteworkmodestatus: 1,
                addremoteworkmode: 1,
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!alluseremployee) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: alluseremployee.length, alluseremployee });
});

exports.getUserWithStatus = catchAsyncErrors(async (req, res, next) => {
    let finalarray;

    try {
        const {
            pageName,
            company,
            branch,
            unit,
            team,
            department,
            employee,
            profileimage,
        } = req.body;

        // Define the past 3 days range
        const today = moment();
        const pastThreeAttendaysDays = [
            today.clone().format("DD-MM-YYYY"),
            today.clone().subtract(1, "days").format("DD-MM-YYYY"),
            today.clone().subtract(2, "days").format("DD-MM-YYYY"),
            today.clone().subtract(3, "days").format("DD-MM-YYYY"),
        ];
        const pastThreeLeaveDays = [
            today.clone().format("DD/MM/YYYY"),
            today.clone().subtract(1, "days").format("DD/MM/YYYY"),
            today.clone().subtract(2, "days").format("DD/MM/YYYY"),
            today.clone().subtract(3, "days").format("DD/MM/YYYY"),
        ];
        const pastThreeDaysISO = [
            today.clone().format("YYYY-MM-DD"),
            today.clone().subtract(1, "days").format("YYYY-MM-DD"),
            today.clone().subtract(2, "days").format("YYYY-MM-DD"),
            today.clone().subtract(3, "days").format("YYYY-MM-DD"),
        ];
        // Fetch relevant attendance records for the past 3 days
        let filterQuery = {
            enquirystatus: {
                $nin: ["Enquiry Purpose"],
            },
            resonablestatus: {
                $nin: [
                    "Not Joined",
                    "Postponed",
                    "Rejected",
                    "Closed",
                    "Releave Employee",
                    "Absconded",
                    "Hold",
                    "Terminate",
                ],
            },

            // Conditional company filter
            ...(company.length && { company: { $in: company } }),
            // Conditional branch filter
            ...(branch.length && { branch: { $in: branch } }),
            // Conditional unit filter
            ...(unit.length && { unit: { $in: unit } }),
            // Conditional team filter
            ...(team.length && { team: { $in: team } }),
            // Conditional department filter
            ...(department.length && { department: { $in: department } }),
            // Conditional employee filter
            ...(employee.length && { companyname: { $in: employee } }),
        };

        if (pageName === "Employee") {
            filterQuery.workmode = {
                $ne: "Internship",
            };
        } else if (pageName === "Internship") {
            filterQuery.workmode = {
                $eq: "Internship",
            };
        }

        const noticeperiodpipeline = [
            {
                // Sort by empname and then by createdAt in descending order
                $sort: { empname: 1, createdAt: -1 },
            },
            {
                // Group by empname and select the first document per group (most recent)
                $group: {
                    _id: "$empname", // Group by empname
                    mostRecentDocument: { $first: "$$ROOT" }, // Select the most recent document per empname
                },
            },
            {
                // Project the necessary fields from the most recent document
                $replaceRoot: { newRoot: "$mostRecentDocument" },
            },
            {
                $match: {
                    $or: [
                        {
                            exitstatus: true,
                        },
                        // Condition for "Approved" status
                        {
                            approvedStatus: "true",
                            cancelstatus: false,
                        },
                        // Condition for "Applied" status
                        {
                            status: "Applied",
                        },
                    ],
                    // Add the new conditions
                    rejectStatus: { $ne: "true" },
                    cancelstatus: { $ne: true },
                    continuestatus: { $ne: true },
                },
            },
            {
                $project: {
                    empname: 1,
                    empcode: 1,
                    status: 1,
                    rejectStatus: 1,
                    cancelstatus: 1,
                    approvedStatus: 1,
                    continuestatus: 1,
                    recheckStatus: 1,
                    exitstatus: 1,
                    createdAt: 1,
                },
            },
        ];
        // Run all queries in parallel using Promise.all
        const [allusers, attendance, allLeaveStatus, holidays, noticeperiodstatus] =
            await Promise.all([
                User.find(filterQuery, {
                    status: 1,
                    empcode: 1,
                    nexttime: 1,
                    companyname: 1,
                    username: 1,
                    email: 1,
                    religion: 1,
                    employeecount: 1,
                    systemmode: 1,
                    companyemail: 1,
                    branch: 1,
                    unit: 1,
                    team: 1,
                    company: 1,
                    shift: 1,
                    experience: 1,
                    doj: 1,
                    dot: 1,
                    workmode: 1,
                    internstatus: 1,
                    resonablestatus: 1,
                    reasonname: 1,
                    rejoin: 1,
                    reasonablestatusremarks: 1,
                    department: 1,
                    dob: 1,
                    approvedremotestatus: 1,
                    company: 1,
                    reasondate: 1,
                    empreason: 1,
                    percentage: 1,
                    doj: 1,
                    dot: 1,
                    role: 1,
                    assignExpLog: 1,
                    resonablestatus: 1,
                    reasonname: 1,
                    rejoin: 1,
                    reasonablestatusremarks: 1,
                    department: 1,
                    dob: 1,
                    gender: 1,
                    maritalstatus: 1,
                    bloodgroup: 1,
                    location: 1,
                    aadhar: 1,
                    panno: 1,
                    panstatus: 1,
                    panrefno: 1,
                    fathername: 1,
                    mothername: 1,
                    contactfamily: 1,
                    contactno: 1,
                    prefix: 1,
                    assignExpMode: 1,
                    assignExpvalue: 1,
                    processtype: 1,
                    processduration: 1,
                    date: 1,
                    time: 1,
                    grosssalary: 1,
                    timemins: 1,
                    modeexperience: 1,
                    targetexperience: 1,
                    targetpts: 1,
                    dom: 1,
                    contactpersonal: 1,
                    designationlog: 1,
                    processlog: 1,
                    boardingLog: 1,
                    attendancemode: 1,
                    company: 1,
                    reasondate: 1,
                    empreason: 1,
                    percentage: 1,
                    empcode: 1,
                    companyname: 1,
                    team: 1,
                    username: 1,
                    usernameautogenerate: 1,
                    workmode: 1,
                    email: 1,
                    employeecount: 1,
                    systemmode: 1,
                    companyemail: 1,
                    unit: 1,
                    branch: 1,
                    designation: 1,
                    floor: 1,
                    shift: 1,
                    reportingto: 1,
                    experience: 1,
                    doj: 1,
                    dot: 1,
                    bankdetails: 1,
                    shifttiming: 1,
                    shiftgrouping: 1,
                    shifttype: 1,
                    legalname: 1,
                    callingname: 1,
                    pdoorno: 1,
                    pstreet: 1,
                    parea: 1,
                    plandmark: 1,
                    ptaluk: 1,
                    ppost: 1,
                    ppincode: 1,
                    pcountry: 1,
                    pstate: 1,
                    pcity: 1,
                    cdoorno: 1,

                    cstreet: 1,
                    carea: 1,
                    role: 1,
                    clandmark: 1,
                    ctaluk: 1,
                    cpost: 1,
                    cpincode: 1,
                    ccountry: 1,
                    cstate: 1,
                    ccity: 1,
                    reasondate: 1,
                    process: 1,
                    workstation: 1,
                    workstationinput: 1,
                    workstationofficestatus: 1,
                    weekoff: 1,
                    originalpassword: 1,
                    enquirystatus: 1,
                    area: 1,
                    enableworkstation: 1,
                    wordcheck: 1,
                    shiftallot: 1,
                    firstname: 1,
                    lastname: 1,
                    employeecount: 1,
                    emergencyno: 1,
                    name: 1,
                    salarysetup: 1,
                    mode: 1,
                    salarycode: 1,
                    basic: 1,
                    hra: 1,
                    conveyance: 1,
                    medicalallowance: 1,
                    productionallowance: 1,
                    otherallowance: 1,
                    productionallowancetwo: 1,
                    pffromdate: 1,
                    pfenddate: 1,
                    esifromdate: 1,
                    esienddate: 1,
                    pfesistatus: 1,
                    remoteworkmodestatus: 1,
                    addremoteworkmode: 1,
                }).lean(),

                Attendance.find(
                    {
                        date: {
                            $in: pastThreeAttendaysDays,
                        },
                    },
                    { date: 1, userid: 1 }
                ).lean(),

                ApplyLeave.find(
                    {
                        date: { $in: pastThreeLeaveDays },
                        status: { $nin: ["Rejected"] },
                    },
                    { employeename: 1, employeeid: 1, date: 1 }
                ).lean(),

                Holiday.find(
                    {
                        date: { $in: pastThreeDaysISO },
                    },
                    {
                        date: 1,
                        employee: 1,
                        company: 1,
                        applicablefor: 1,
                        unit: 1,
                        team: 1,
                    }
                ).lean(),

                Noticeperiod.aggregate(noticeperiodpipeline).exec(),
            ]);

        let employeeDocumentsMap = {};

        // Fetch profile images only if profileimage is true
        if (profileimage) {
            const employeeDocuments = await EmployeeDocuments.find(
                {
                    commonid: { $in: allusers.map((user) => user._id.toString()) },
                },
                { profileimage: 1, commonid: 1 }
            ).lean();


            // Create a map of employee documents by commonid (user's _id)
            employeeDocumentsMap = employeeDocuments.reduce((acc, doc) => {
                acc[doc.commonid] = doc.profileimage || "";
                return acc;
            }, {});
        }
        // Create a map for fast lookup of attendance records
        const attendanceMap = attendance.reduce((acc, item) => {
            const userId = item.userid.toString();
            const date = moment(item.date, "DD-MM-YYYY").format("DD/MM/YYYY");
            if (!acc[userId]) {
                acc[userId] = [];
            }
            acc[userId].push(date);
            return acc;
        }, {});

        // Create a map for fast lookup of leave records
        let allUserEmpname = allusers.map((user) => user.companyname)
        const myCheckList = await MyCheckList.find({ candidatename: { $in: allUserEmpname } }).lean();
        let leaveWithCheckList = allLeaveStatus.map((item) => {
            let foundData = myCheckList?.find(
                (dataNew) => dataNew.commonid == item._id
            );
            let areAllGroupsCompleted = foundData?.groups?.every(
                (itemNew) => (itemNew.data !== undefined && itemNew.data !== "") || itemNew.files !== undefined
            );

            if (areAllGroupsCompleted) {
                return {
                    ...item,
                    updatestatus: "Completed",
                };
            }
            return null;
        }).filter(item => item);

        // Create a map for fast lookup of leave records
        const leaveMap = leaveWithCheckList.reduce((acc, item) => {
            const userKey = `${item.employeeid}_${item.employeename}`;
            const leaveDates = item.date.map((date) =>
                moment(date, "DD/MM/YYYY").format("DD/MM/YYYY")
            );
            if (!acc[userKey]) {
                acc[userKey] = [];
            }
            acc[userKey].push(...leaveDates);
            return acc;
        }, {});

        // Create a map for fast lookup of holiday records
        const employeeMatchesUser = (user, holiday) => {
            return (
                holiday.company.includes(user.company) &&
                holiday.applicablefor.includes(user.branch) &&
                holiday.unit.includes(user.unit) &&
                holiday.team.includes(user.team) &&
                (holiday.employee.includes(user.companyname) ||
                    holiday.employee.includes("ALL"))
            );
        };
        const holidayMap = holidays.reduce((acc, item) => {
            const date = moment(item.date).format("DD/MM/YYYY");

            allusers.forEach((user) => {
                if (employeeMatchesUser(user, item)) {
                    if (!acc[user.empcode]) {
                        acc[user.empcode] = [];
                    }
                    acc[user.empcode].push(date);
                }
            });

            return acc;
        }, {});

        // Create a map for fast lookup
        const noticePeriodMap = noticeperiodstatus.reduce((acc, item) => {
            const key = `${item.empname}_${item.empcode}`;
            acc[key] = item;
            return acc;
        }, {});

        // Function to check the status for the past 3 days
        const checkStatusForPast3Days = (
            userId,
            empcode,
            employeename,
            weekOffDays,
            doj
        ) => {
            const userKey = `${empcode}_${employeename}`;
            let absentDays = 0;
            let leaveDays = 0;
            let holidayDays = 0;
            const isNewJoiner = pastThreeDaysISO.includes(doj);
            for (let date of pastThreeLeaveDays) {
                // const dayOfWeek = moment(date, "DD/MM/YYYY").format("dddd"); // Get day of the week

                // if (weekOffDays.includes(dayOfWeek)) {
                //   continue; // Skip week off days
                // }
                if (attendanceMap[userId] && attendanceMap[userId].includes(date)) {
                    // User was present on this date
                    continue;
                } else if (leaveMap[userKey] && leaveMap[userKey].includes(date)) {
                    // User was on leave on this date
                    leaveDays++;
                } else if (holidayMap[empcode] && holidayMap[empcode].includes(date)) {
                    holidayDays++;
                } else {
                    // User was absent on this date
                    absentDays++;
                }
            }

            let status = null;
            if (isNewJoiner) {

                status = null;
            } else if (absentDays >= 4) {
                status = "Long Absent";
            } else if (leaveDays >= 4) {
                status = "Long Leave";
            }

            return { status, absentDays, leaveDays, holidayDays };
        };

        // Function to determine the status
        const determineStatus = (
            attendanceStatus,
            noticePeriodStatus,
            livestatus
        ) => {
            if (noticePeriodStatus === "Exit Confirmed") {
                return `Exit Confirmed`;
            } else if (!livestatus && noticePeriodStatus && attendanceStatus) {
                return `Notice Period ${noticePeriodStatus} and ${attendanceStatus}`;
            } else if (noticePeriodStatus) {
                return `Notice Period ${noticePeriodStatus}`;
            } else if (!noticePeriodStatus && attendanceStatus) {
                return attendanceStatus;
            } else if (!noticePeriodStatus && !attendanceStatus && livestatus) {
                return livestatus;
            } else {
                return "No Status";
            }
        };

        // Enrich users with status
        const enrichedLeaveAttendanceUsers = allusers.map((user) => {
            const userId = user._id.toString();
            let weekOffDays = [];
            if (user.boardingLog && user.boardingLog.length > 0) {
                const lastBoardingLog = user.boardingLog[user.boardingLog.length - 1];
                weekOffDays = lastBoardingLog.weekoff || [];
            }
            const userKey = `${user.companyname}_${user.empcode}`;
            const { status, absentDays, leaveDays } = checkStatusForPast3Days(
                userId,
                user.empcode,
                user.companyname,
                weekOffDays,
                user?.doj
            );
            const noticePeriodStatus =
                noticePeriodMap[userKey]?.exitstatus === true
                    ? "Exit Confirmed"
                    : noticePeriodMap[userKey]?.approvedStatus === "true" &&
                        noticePeriodMap[userKey]?.cancelstatus === false &&
                        noticePeriodMap[userKey]?.continuestatus === false
                        ? "Approved"
                        : noticePeriodMap[userKey]?.approvedStatus === "true" &&
                            noticePeriodMap[userKey]?.cancelstatus === true
                            ? "Cancelled"
                            : noticePeriodMap[userKey]?.approvedStatus === "true" &&
                                noticePeriodMap[userKey]?.continuestatus === true
                                ? "Continue"
                                : noticePeriodMap[userKey]?.rejectStatus === "true"
                                    ? "Rejected"
                                    : noticePeriodMap[userKey]?.recheckStatus === "true"
                                        ? "Recheck"
                                        : noticePeriodMap[userKey]?.status || null;
            const livestatus = !status && !noticePeriodStatus ? "Live" : null;
            const profileImage = profileimage
                ? employeeDocumentsMap[userId] || ""
                : null;
            return {
                ...user,
                attendanceStatus: noticePeriodStatus ? true : false,
                noticePeriodStatus: noticePeriodStatus ? true : false,
                livestatus: livestatus ? true : false,
                status: determineStatus(status, noticePeriodStatus, livestatus),
                longAbsentCount: absentDays, // Long absent count
                longLeaveCount: leaveDays, // Long leave count
                profileimage: profileimage ? profileImage : "",
            };
        });

        finalArray = enrichedLeaveAttendanceUsers;
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finalArray) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({
        count: finalArray.length,
        allusers: finalArray,
    });
});

exports.getAlluserDataFilterLongAbsend = catchAsyncErrors(async (req, res) => {
    try {
        let filteredUsers, filterQuerys;
        const {
            company,
            branch,
            unit,
            team,
            filterin,
            module,
            submodule,
            mainpage,
            subpage,
            subsubpage,
            status,
        } = req.body;
        const today = moment();
        const pastThreeDaysISO = [
            today.clone().format("YYYY-MM-DD"),
            today.clone().subtract(1, "days").format("YYYY-MM-DD"),
            today.clone().subtract(2, "days").format("YYYY-MM-DD"),
            today.clone().subtract(3, "days").format("YYYY-MM-DD"),
        ];
        let filterQuery = {
            enquirystatus: {
                $nin: ["Enquiry Purpose"],
            },
            resonablestatus: {
                $nin: [
                    "Not Joined",
                    "Postponed",
                    "Rejected",
                    "Closed",
                    "Releave Employee",
                    "Absconded",
                    "Hold",
                    "Terminate",
                ],
            },
            doj: {
                $nin: pastThreeDaysISO, // Exclude users whose date of joining falls in the last three days
            },
        };

        if (Array.isArray(company) && company.length > 0) {
            filterQuery.company = { $in: company };
        }

        if (Array.isArray(branch) && branch.length > 0) {
            filterQuery.branch = { $in: branch };
        }

        if (Array.isArray(unit) && unit.length > 0) {
            filterQuery.unit = { $in: unit };
        }

        if (Array.isArray(team) && team.length > 0) {
            filterQuery.team = { $in: team };
        }

        const removeEmptyArrays = (obj) => {
            return Object.fromEntries(
                Object.entries(obj).filter(
                    ([key, value]) => !Array.isArray(value) || value.length > 0
                )
            );
        };

        filterQuerys = removeEmptyArrays(filterQuery);
        let result = await User.find(filterQuerys, {
            resonablestatus: 1,
            company: 1,
            branch: 1,
            unit: 1,
            team: 1,
            empcode: 1,
            companyname: 1,
            longleaveabsentaprooveddate: 1,
            boardingLog: 1, attendancemode: 1,// Include boardingLog in the result

            username: 1,
            originalpassword: 1,
            firstname: 1,
            lastname: 1,
            aadhar: 1,
            panno: 1,
            dob: 1,
            doj: 1,
            pstreet: 1,

            pcity: 1,
            ppincode: 1,
            pstate: 1,
            pcountry: 1,
        }).lean();
        filteredUsers = result;

        const currentDateChecklist = moment().format("DD-MM-YYYY");
        const pastThreeAttendaysDays = [
            today.clone().format("DD-MM-YYYY"),
            today.clone().subtract(1, "days").format("DD-MM-YYYY"),
            today.clone().subtract(2, "days").format("DD-MM-YYYY"),
            today.clone().subtract(3, "days").format("DD-MM-YYYY"),
        ];

        const pastThreeLeaveDays = [
            today.clone().format("DD/MM/YYYY"),
            today.clone().subtract(1, "days").format("DD/MM/YYYY"),
            today.clone().subtract(2, "days").format("DD/MM/YYYY"),
            today.clone().subtract(3, "days").format("DD/MM/YYYY"),
        ];

        const [attendance, allLeaveStatus, holidays, checklistData] =
            await Promise.all([
                Attendance.find(
                    {
                        date: {
                            $in: pastThreeAttendaysDays,
                        },
                    },
                    { date: 1, userid: 1 }
                ).lean(),

                ApplyLeave.find(
                    {
                        date: { $in: pastThreeLeaveDays },
                        status: { $nin: ["Rejected"] },
                    },
                    { employeename: 1, employeeid: 1, date: 1 }
                ).lean(),

                Holiday.find(
                    {
                        date: { $in: pastThreeDaysISO },
                    },
                    {
                        date: 1,
                        employee: 1,
                        company: 1,
                        applicablefor: 1,
                        unit: 1,
                        team: 1,
                    }
                ).lean(),
                MyCheckList.find({
                    module,
                    submodule,

                    mainpage,
                    subpage,
                    subsubpage,
                    // status: { $ne: "completed" },
                    longleaveabsentaprooveddatechecklist: { $in: [currentDateChecklist] },
                }),
            ]);
        const attendanceMap = attendance.reduce((acc, item) => {
            const userId = item.userid.toString();
            const date = moment(item.date, "DD-MM-YYYY").format("DD/MM/YYYY");
            if (!acc[userId]) {
                acc[userId] = [];
            }
            acc[userId].push(date);
            return acc;
        }, {});

        let allUserEmpname = result.map((user) => user.companyname)
        const myCheckList = await MyCheckList.find({ candidatename: { $in: allUserEmpname } }).lean();
        let leaveWithCheckList = allLeaveStatus.map((item) => {
            let foundData = myCheckList?.find(
                (dataNew) => dataNew.commonid == item._id
            );
            let areAllGroupsCompleted = foundData?.groups?.every(
                (itemNew) => (itemNew.data !== undefined && itemNew.data !== "") || itemNew.files !== undefined
            );

            if (areAllGroupsCompleted) {
                return {
                    ...item,
                    updatestatus: "Completed",
                };
            }
            return null;
        }).filter(item => item);

        // Create a map for fast lookup of leave records
        const leaveMap = leaveWithCheckList.reduce((acc, item) => {
            const userKey = `${item.employeeid}_${item.employeename}`;
            const leaveDates = item.date.map((date) =>
                moment(date, "DD/MM/YYYY").format("DD/MM/YYYY")
            );
            if (!acc[userKey]) {
                acc[userKey] = [];
            }
            acc[userKey].push(...leaveDates);
            return acc;
        }, {});

        const employeeMatchesUser = (user, holiday) => {
            return (
                holiday.company.includes(user.company) &&
                holiday.applicablefor.includes(user.branch) &&
                holiday.unit.includes(user.unit) &&
                holiday.team.includes(user.team) &&
                (holiday.employee.includes(user.companyname) ||
                    holiday.employee.includes("ALL"))
            );
        };

        const holidayMap = holidays.reduce((acc, item) => {
            const date = moment(item.date).format("DD/MM/YYYY");

            filteredUsers.forEach((user) => {
                if (employeeMatchesUser(user, item)) {
                    if (!acc[user.empcode]) {
                        acc[user.empcode] = [];
                    }
                    acc[user.empcode].push(date);
                }
            });

            return acc;
        }, {});


        const checkStatusForPast3Days = (
            userId,
            empcode,
            employeename,
            weekOffDays
        ) => {
            const userKey = `${empcode}_${employeename}`;
            let absentDays = 0;
            let leaveDays = 0;
            let holidayDays = 0;

            for (let date of pastThreeLeaveDays) {
                // const dayOfWeek = moment(date, "DD/MM/YYYY").format("dddd"); // Get day of the week

                // if (weekOffDays.includes(dayOfWeek)) {
                //   continue; // Skip week off days
                // }

                if (attendanceMap[userId] && attendanceMap[userId].includes(date)) {
                    continue; // User was present on this date
                } else if (leaveMap[userKey] && leaveMap[userKey].includes(date)) {
                    leaveDays++; // User was on leave on this date
                } else if (holidayMap[empcode] && holidayMap[empcode].includes(date)) {
                    holidayDays++; // Holiday on this date
                } else {
                    absentDays++; // User was absent on this date
                }
            }

            let status = null;
            if (absentDays >= 4) {
                status = "Long Absent";
            } else if (leaveDays >= 4) {
                status = "Long Leave";
            }

            return { status, absentDays, leaveDays, holidayDays };
        };

        const determineStatus = (attendanceStatus) => {
            return attendanceStatus ? attendanceStatus : null;
        };

        const enrichedLeaveAttendanceUsers = filteredUsers
            ?.map((user) => {
                const userId = user._id.toString();

                const checklistItem = checklistData.find(
                    (item) => item.commonid === userId
                );
                let weekOffDays = [];
                if (user.boardingLog && user.boardingLog.length > 0) {
                    const lastBoardingLog = user.boardingLog[user.boardingLog.length - 1];
                    weekOffDays = lastBoardingLog.weekoff || [];
                }

                const { status, absentDays, leaveDays } = checkStatusForPast3Days(
                    userId,
                    user.empcode,
                    user.companyname,
                    weekOffDays
                );

                return {
                    ...user,

                    attendanceStatus: !!status,
                    noticePeriodStatus: false,
                    livestatus: status ? false : null,
                    userstatus: determineStatus(status),
                    longAbsentCount: absentDays, // Long absent count
                    longLeaveCount: leaveDays, // Long leave count
                    checklistassigned: !!checklistItem,
                    longleaveabsentaprooveddatechecklist:
                        checklistItem?.longleaveabsentaprooveddatechecklist || [],
                };
            })
            .filter((user) => user.userstatus && user.userstatus !== "Long Leave"); // Filter out users without attendance status

        return res.status(200).json({
            filterallDatauser: enrichedLeaveAttendanceUsers,
            tableName: filterin,
        });
    } catch (err) {
        return res.status(500).json({ error: "Internal server error" });
    }
});

exports.getAlluserDataFilterLongAbsendCompleted = catchAsyncErrors(async (req, res) => {
    try {
        let filteredUsers, filterQuerys;
        const {
            company,
            branch,
            unit,
            team,
            filterin,
            module,
            submodule,
            mainpage,
            subpage,
            subsubpage,
            status,
        } = req.body;
        const today = moment();
        const pastThreeDaysISO = [
            today.clone().format("YYYY-MM-DD"),
            today.clone().subtract(1, "days").format("YYYY-MM-DD"),
            today.clone().subtract(2, "days").format("YYYY-MM-DD"),
            today.clone().subtract(3, "days").format("YYYY-MM-DD"),
        ];
        let filterQuery = {
            enquirystatus: {
                $nin: ["Enquiry Purpose"],
            },
            resonablestatus: {
                $nin: [
                    "Not Joined",
                    "Postponed",
                    "Rejected",
                    "Closed",
                    "Releave Employee",
                    "Absconded",
                    "Hold",
                    "Terminate",
                ],
            },
            doj: {
                $nin: pastThreeDaysISO, // Exclude users whose date of joining falls in the last three days
            },
        };

        if (Array.isArray(company) && company.length > 0) {
            filterQuery.company = { $in: company };
        }

        if (Array.isArray(branch) && branch.length > 0) {
            filterQuery.branch = { $in: branch };
        }

        if (Array.isArray(unit) && unit.length > 0) {
            filterQuery.unit = { $in: unit };
        }

        if (Array.isArray(team) && team.length > 0) {
            filterQuery.team = { $in: team };
        }

        const removeEmptyArrays = (obj) => {
            return Object.fromEntries(
                Object.entries(obj).filter(
                    ([key, value]) => !Array.isArray(value) || value.length > 0
                )
            );
        };

        filterQuerys = removeEmptyArrays(filterQuery);
        let result = await User.find(filterQuerys, {
            resonablestatus: 1,
            company: 1,
            branch: 1,
            unit: 1,
            team: 1,
            empcode: 1,
            companyname: 1,
            longleaveabsentaprooveddate: 1,
            boardingLog: 1, attendancemode: 1,// Include boardingLog in the result

            username: 1,
            originalpassword: 1,
            firstname: 1,
            lastname: 1,
            aadhar: 1,
            panno: 1,
            dob: 1,
            doj: 1,
            pstreet: 1,
            pcity: 1,
            ppincode: 1,
            pstate: 1,
            pcountry: 1,
        }).lean();

        const currentDateChecklist = moment().format("DD-MM-YYYY");
        const pastThreeAttendaysDays = [
            today.clone().format("DD-MM-YYYY"),
            today.clone().subtract(1, "days").format("DD-MM-YYYY"),
            today.clone().subtract(2, "days").format("DD-MM-YYYY"),
            today.clone().subtract(3, "days").format("DD-MM-YYYY"),
        ];

        const pastThreeLeaveDays = [
            today.clone().format("DD/MM/YYYY"),
            today.clone().subtract(1, "days").format("DD/MM/YYYY"),
            today.clone().subtract(2, "days").format("DD/MM/YYYY"),
            today.clone().subtract(3, "days").format("DD/MM/YYYY"),
        ];

        const [attendance, allLeaveStatus, holidays, checklistData] =
            await Promise.all([
                Attendance.find(
                    {
                        date: {
                            $in: pastThreeAttendaysDays,
                        },
                    },
                    { date: 1, userid: 1 }
                ).lean(),

                ApplyLeave.find(
                    {
                        date: { $in: pastThreeLeaveDays },
                        status: { $nin: ["Rejected"] },
                    },
                    { employeename: 1, employeeid: 1, date: 1 }
                ).lean(),

                Holiday.find(
                    {
                        date: { $in: pastThreeDaysISO },
                    },
                    {
                        date: 1,
                        employee: 1,
                        company: 1,
                        applicablefor: 1,
                        unit: 1,
                        team: 1,
                    }
                ).lean(),
                MyCheckList.find({
                    // subsubpage: "Long Absent Restriction List",
                    status: { $in: ["progress", "Completed"] },
                    module,
                    submodule,
                    mainpage,
                    subpage,
                    subsubpage,
                    // status: { $ne: "completed" },
                    longleaveabsentaprooveddatechecklist: { $in: [currentDateChecklist] },
                }),
            ]);

        // filteredUsers = result.filter(d => return checklistData.some(item => item.commonid === d._id  ));
        filteredUsers = result.filter(d => {
            return checklistData.some(item => item.commonid == d._id);
        });

        const attendanceMap = attendance.reduce((acc, item) => {
            const userId = item.userid.toString();
            const date = moment(item.date, "DD-MM-YYYY").format("DD/MM/YYYY");
            if (!acc[userId]) {
                acc[userId] = [];
            }
            acc[userId].push(date);
            return acc;
        }, {});

        let allUserEmpname = result.map((user) => user.companyname)
        const myCheckList = await MyCheckList.find({ candidatename: { $in: allUserEmpname } }).lean();
        let leaveWithCheckList = allLeaveStatus.map((item) => {
            let foundData = myCheckList?.find(
                (dataNew) => dataNew.commonid == item._id
            );
            let areAllGroupsCompleted = foundData?.groups?.every(
                (itemNew) => (itemNew.data !== undefined && itemNew.data !== "") || itemNew.files !== undefined
            );

            if (areAllGroupsCompleted) {
                return {
                    ...item,
                    updatestatus: "Completed",
                };
            }
            return null;
        }).filter(item => item);

        // Create a map for fast lookup of leave records
        const leaveMap = leaveWithCheckList.reduce((acc, item) => {
            const userKey = `${item.employeeid}_${item.employeename}`;
            const leaveDates = item.date.map((date) =>
                moment(date, "DD/MM/YYYY").format("DD/MM/YYYY")
            );
            if (!acc[userKey]) {
                acc[userKey] = [];
            }
            acc[userKey].push(...leaveDates);
            return acc;
        }, {});

        const employeeMatchesUser = (user, holiday) => {
            return (
                holiday.company.includes(user.company) &&
                holiday.applicablefor.includes(user.branch) &&
                holiday.unit.includes(user.unit) &&
                holiday.team.includes(user.team) &&
                (holiday.employee.includes(user.companyname) ||
                    holiday.employee.includes("ALL"))
            );
        };

        const holidayMap = holidays.reduce((acc, item) => {
            const date = moment(item.date).format("DD/MM/YYYY");

            filteredUsers.forEach((user) => {
                if (employeeMatchesUser(user, item)) {
                    if (!acc[user.empcode]) {
                        acc[user.empcode] = [];
                    }
                    acc[user.empcode].push(date);
                }
            });

            return acc;
        }, {});

        const checkStatusForPast3Days = (
            userId,
            empcode,
            employeename,
            weekOffDays
        ) => {
            const userKey = `${empcode}_${employeename}`;
            let absentDays = 0;
            let leaveDays = 0;
            let holidayDays = 0;

            for (let date of pastThreeLeaveDays) {
                // const dayOfWeek = moment(date, "DD/MM/YYYY").format("dddd"); // Get day of the week

                // if (weekOffDays.includes(dayOfWeek)) {
                //   continue; // Skip week off days
                // }

                if (attendanceMap[userId] && attendanceMap[userId].includes(date)) {
                    continue; // User was present on this date
                } else if (leaveMap[userKey] && leaveMap[userKey].includes(date)) {
                    leaveDays++; // User was on leave on this date
                } else if (holidayMap[empcode] && holidayMap[empcode].includes(date)) {
                    holidayDays++; // Holiday on this date
                } else {
                    absentDays++; // User was absent on this date
                }
            }

            let status = null;
            if (absentDays >= 4) {
                status = "Long Absent";
            } else if (leaveDays >= 4) {
                status = "Long Leave";
            }

            return { status, absentDays, leaveDays, holidayDays };
        };

        const determineStatus = (attendanceStatus) => {
            return attendanceStatus ? attendanceStatus : null;
        };

        const enrichedLeaveAttendanceUsers = filteredUsers
            ?.map((user) => {
                const userId = user._id.toString();

                const checklistItem = checklistData.find(
                    (item) => item.commonid === userId
                );
                let weekOffDays = [];
                if (user.boardingLog && user.boardingLog.length > 0) {
                    const lastBoardingLog = user.boardingLog[user.boardingLog.length - 1];
                    weekOffDays = lastBoardingLog.weekoff || [];
                }

                const { status, absentDays, leaveDays } = checkStatusForPast3Days(
                    userId,
                    user.empcode,
                    user.companyname,
                    weekOffDays
                );

                return {
                    ...user,

                    attendanceStatus: !!status,
                    noticePeriodStatus: false,
                    livestatus: status ? false : null,
                    userstatus: determineStatus(status),
                    longAbsentCount: absentDays, // Long absent count
                    longLeaveCount: leaveDays, // Long leave count
                    checklistassigned: !!checklistItem,
                    longleaveabsentaprooveddatechecklist:
                        checklistItem?.longleaveabsentaprooveddatechecklist,
                };
            })
            .filter((user) => user.userstatus && user.userstatus !== "Long Leave"); // Filter out users without attendance status

        return res.status(200).json({
            filterallDatauser: enrichedLeaveAttendanceUsers,
            tableName: filterin,
        });
    } catch (err) {
        return res.status(500).json({ error: "Internal server error" });
    }
});


exports.getAlluserDataFilter = catchAsyncErrors(async (req, res) => {
    try {
        let filteredUsers, filterQuerys;
        const { company, branch, unit, team, status, filterin, isCurrentStatus } =
            req.body;

        const filterQuery = {
            company: company,
            branch: branch,
            unit: unit,
            team: team,
        };

        filterQuery.workmode =
            filterin === "Employee" ? { $ne: "Internship" } : { $eq: "Internship" };

        if (Array.isArray(company) && company.length > 0) {
            filterQuery.company = { $in: company };
        }

        if (Array.isArray(branch) && branch.length > 0) {
            filterQuery.branch = { $in: branch };
        }

        if (Array.isArray(unit) && unit.length > 0) {
            filterQuery.unit = { $in: unit };
        }

        if (Array.isArray(team) && team.length > 0) {
            filterQuery.team = { $in: team };
        }

        const removeEmptyArrays = (obj) => {
            return Object.fromEntries(
                Object.entries(obj).filter(
                    ([key, value]) => !Array.isArray(value) || value.length > 0
                )
            );
        };

        filterQuerys = removeEmptyArrays(filterQuery);
        let result = await User.find(filterQuerys, {
            resonablestatus: 1,
            company: 1,
            branch: 1,
            unit: 1,
            team: 1,
            empcode: 1,
            companyname: 1,
            doj: 1,
            boardingLog: 1, // Include boardingLog in the result
        }).lean();
        filteredUsers =

            !isCurrentStatus && status.length > 0
                ? result
                    .map((data) => {
                        if (
                            status.length === 1 &&
                            status.includes("Live") &&
                            (data.resonablestatus === "" ||
                                !data.resonablestatus ||
                                data.resonablestatus === "Rejoined")

                        ) {
                            return data;
                        }
                        if (
                            status.length > 1 &&
                            status.includes("Live") &&
                            (!data.resonablestatus ||
                                data.resonablestatus === "Rejoined" ||
                                data.resonablestatus === "" ||
                                status.includes(data.resonablestatus))
                        ) {
                            return data;
                        }
                        if (
                            !status.includes("Live") &&
                            data.resonablestatus &&
                            data.resonablestatus !== "Rejoined" &&
                            data.resonablestatus !== "" &&
                            status.includes(data.resonablestatus)
                        ) {
                            return data;
                        }
                    })
                    .filter((data) => data !== undefined)
                : result;

        // Define the past 3 days range
        const today = moment();
        const pastThreeAttendaysDays = [
            today.clone().format("DD-MM-YYYY"),
            today.clone().subtract(1, "days").format("DD-MM-YYYY"),
            today.clone().subtract(2, "days").format("DD-MM-YYYY"),
            today.clone().subtract(3, "days").format("DD-MM-YYYY"),
        ];
        const pastThreeLeaveDays = [
            today.clone().format("DD/MM/YYYY"),
            today.clone().subtract(1, "days").format("DD/MM/YYYY"),
            today.clone().subtract(2, "days").format("DD/MM/YYYY"),
            today.clone().subtract(3, "days").format("DD/MM/YYYY"),
        ];
        const pastThreeDaysISO = [
            today.clone().format("YYYY-MM-DD"),
            today.clone().subtract(1, "days").format("YYYY-MM-DD"),
            today.clone().subtract(2, "days").format("YYYY-MM-DD"),
            today.clone().subtract(3, "days").format("YYYY-MM-DD"),
        ];

        const noticeperiodpipeline = [
            {
                // Sort by empname and then by createdAt in descending order
                $sort: { empname: 1, createdAt: -1 },
            },
            {
                // Group by empname and select the first document per group (most recent)
                $group: {
                    _id: "$empname", // Group by empname
                    mostRecentDocument: { $first: "$$ROOT" }, // Select the most recent document per empname
                },
            },
            {
                // Project the necessary fields from the most recent document
                $replaceRoot: { newRoot: "$mostRecentDocument" },
            },
            {
                $match: {
                    $or: [
                        {
                            exitstatus: true,
                        },
                        // Condition for "Approved" status
                        {
                            approvedStatus: "true",
                            cancelstatus: false,
                        },
                        // Condition for "Applied" status
                        {
                            status: "Applied",
                        },
                    ],
                    // Add the new conditions
                    rejectStatus: { $ne: "true" },
                    cancelstatus: { $ne: true },
                    continuestatus: { $ne: true },
                },
            },
            {
                $project: {
                    empname: 1,
                    empcode: 1,
                    status: 1,
                    rejectStatus: 1,
                    cancelstatus: 1,
                    approvedStatus: 1,
                    continuestatus: 1,
                    recheckStatus: 1,
                    exitstatus: 1,
                    createdAt: 1,
                },
            },
        ];

        const [attendance, allLeaveStatus, holidays, noticeperiodstatus] =
            await Promise.all([
                Attendance.find(
                    {
                        date: {
                            $in: pastThreeAttendaysDays,
                        },
                    },
                    { date: 1, userid: 1 }
                ).lean(),

                ApplyLeave.find(
                    {
                        date: { $in: pastThreeLeaveDays },
                        status: { $nin: ["Rejected"] },
                    },
                    { employeename: 1, employeeid: 1, date: 1 }
                ).lean(),

                Holiday.find(
                    {
                        date: { $in: pastThreeDaysISO },
                    },
                    {
                        date: 1,
                        employee: 1,
                        company: 1,
                        applicablefor: 1,
                        unit: 1,
                        team: 1,
                    }
                ).lean(),
                Noticeperiod.aggregate(noticeperiodpipeline).exec(),
            ]);

        // Create a map for fast lookup of attendance records
        const attendanceMap = attendance.reduce((acc, item) => {
            const userId = item.userid.toString();
            const date = moment(item.date, "DD-MM-YYYY").format("DD/MM/YYYY");
            if (!acc[userId]) {
                acc[userId] = [];
            }
            acc[userId].push(date);
            return acc;
        }, {});

        // Create a map for fast lookup of leave records
        let allUserEmpname = filteredUsers.map((user) => user.companyname)
        const myCheckList = await MyCheckList.find({ candidatename: { $in: allUserEmpname } }).lean();
        let leaveWithCheckList = allLeaveStatus.map((item) => {
            let foundData = myCheckList?.find(
                (dataNew) => dataNew.commonid == item._id
            );
            let areAllGroupsCompleted = foundData?.groups?.every(
                (itemNew) => (itemNew.data !== undefined && itemNew.data !== "") || itemNew.files !== undefined
            );

            if (areAllGroupsCompleted) {
                return {
                    ...item,
                    updatestatus: "Completed",
                };
            }
            return null;
        }).filter(item => item);

        // Create a map for fast lookup of leave records
        const leaveMap = leaveWithCheckList.reduce((acc, item) => {
            const userKey = `${item.employeeid}_${item.employeename}`;
            const leaveDates = item.date.map((date) =>
                moment(date, "DD/MM/YYYY").format("DD/MM/YYYY")
            );
            if (!acc[userKey]) {
                acc[userKey] = [];
            }
            acc[userKey].push(...leaveDates);
            return acc;
        }, {});

        // Create a map for fast lookup of holiday records
        const employeeMatchesUser = (user, holiday) => {
            return (
                holiday.company.includes(user.company) &&
                holiday.applicablefor.includes(user.branch) &&
                holiday.unit.includes(user.unit) &&
                holiday.team.includes(user.team) &&
                (holiday.employee.includes(user.companyname) ||
                    holiday.employee.includes("ALL"))
            );
        };
        const holidayMap = holidays.reduce((acc, item) => {
            const date = moment(item.date).format("DD/MM/YYYY");

            filteredUsers.forEach((user) => {
                if (employeeMatchesUser(user, item)) {
                    if (!acc[user.empcode]) {
                        acc[user.empcode] = [];
                    }

                    acc[user.empcode].push(date);
                }
            });

            return acc;
        }, {});

        // Create a map for fast lookup
        const noticePeriodMap = noticeperiodstatus.reduce((acc, item) => {
            const key = `${item.empname}_${item.empcode}`;
            acc[key] = item;
            return acc;
        }, {});
        // Function to check the status for the past 3 days
        const checkStatusForPast3Days = (
            userId,
            empcode,
            employeename,
            weekOffDays,
            doj
        ) => {
            const userKey = `${empcode}_${employeename}`;
            let absentDays = 0;
            let leaveDays = 0;
            let holidayDays = 0;
            const isNewJoiner = pastThreeDaysISO.includes(doj);
            for (let date of pastThreeLeaveDays) {
                // const dayOfWeek = moment(date, "DD/MM/YYYY").format("dddd"); // Get day of the week

                // if (weekOffDays.includes(dayOfWeek)) {
                //   continue; // Skip week off days
                // }
                if (attendanceMap[userId] && attendanceMap[userId].includes(date)) {
                    // User was present on this date
                    continue;
                } else if (leaveMap[userKey] && leaveMap[userKey].includes(date)) {
                    // User was on leave on this date
                    leaveDays++;
                } else if (holidayMap[empcode] && holidayMap[empcode].includes(date)) {
                    holidayDays++;
                } else {
                    // User was absent on this date
                    absentDays++;
                }
            }
            let status = null;
            if (isNewJoiner) {
                status = null;
            } else if (absentDays >= 4) {
                status = "Long Absent";
            } else if (leaveDays >= 4) {
                status = "Long Leave";
            }

            return { status, absentDays, leaveDays, holidayDays };
        };

        // Function to determine the status
        const determineStatus = (
            attendanceStatus,
            noticePeriodStatus,
            livestatus
        ) => {
            if (noticePeriodStatus === "Exit Confirmed") {
                return `Exit Confirmed`;
            } else if (!livestatus && noticePeriodStatus && attendanceStatus) {
                return `Notice Period ${noticePeriodStatus} and ${attendanceStatus}`;
            } else if (noticePeriodStatus) {
                return `Notice Period ${noticePeriodStatus}`;
            } else if (!noticePeriodStatus && attendanceStatus) {
                return attendanceStatus;
            } else if (!noticePeriodStatus && !attendanceStatus && livestatus) {
                return livestatus;
            } else {
                return "No Status";
            }
        };
        // Enrich users with status
        const enrichedLeaveAttendanceUsers = filteredUsers
            ?.map((user) => {
                const userId = user._id.toString();
                let weekOffDays = [];
                if (user.boardingLog && user.boardingLog.length > 0) {
                    const lastBoardingLog = user.boardingLog[user.boardingLog.length - 1];
                    weekOffDays = lastBoardingLog.weekoff || [];
                }
                const userKey = `${user.companyname}_${user.empcode}`;
                const { status, absentDays, leaveDays } = checkStatusForPast3Days(
                    userId,
                    user.empcode,
                    user.companyname,
                    weekOffDays,
                    user?.doj
                );
                const noticePeriodStatus =
                    noticePeriodMap[userKey]?.exitstatus === true
                        ? "Exit Confirmed"
                        : noticePeriodMap[userKey]?.approvedStatus === "true" &&
                            noticePeriodMap[userKey]?.cancelstatus === false &&
                            noticePeriodMap[userKey]?.continuestatus === false
                            ? "Approved"
                            : noticePeriodMap[userKey]?.approvedStatus === "true" &&
                                noticePeriodMap[userKey]?.cancelstatus === true
                                ? "Cancelled"
                                : noticePeriodMap[userKey]?.approvedStatus === "true" &&
                                    noticePeriodMap[userKey]?.continuestatus === true
                                    ? "Continue"
                                    : noticePeriodMap[userKey]?.rejectStatus === "true"
                                        ? "Rejected"
                                        : noticePeriodMap[userKey]?.recheckStatus === "true"
                                            ? "Recheck"
                                            : noticePeriodMap[userKey]?.status || null;
                const livestatus = !status && !noticePeriodStatus ? "Live" : null;

                return {
                    ...user,
                    attendanceStatus: noticePeriodStatus ? true : false,
                    noticePeriodStatus: noticePeriodStatus ? true : false,
                    livestatus: livestatus ? true : false,
                    userstatus: determineStatus(status, noticePeriodStatus, livestatus),
                    longAbsentCount: absentDays, // Long absent count
                    longLeaveCount: leaveDays, // Long leave count
                };
            })
            ?.filter((data) => {
                if (isCurrentStatus && status?.length > 0) {
                    if (status.includes("Live")) {
                        // Condition when "Live" is in the array
                        return data.userstatus === "Live";
                    }

                    if (status.includes("Long Absent")) {
                        // Condition when "Long Absent" or "Long Leave" is in the array
                        return (
                            data.userstatus === "Long Absent" ||
                            data.userstatus === "Notice Period Applied and Long Absent" ||
                            data.userstatus === "Notice Period Approved and Long Absent" ||
                            data.userstatus === "Notice Period Cancelled and Long Absent" ||
                            data.userstatus === "Notice Period Continue and Long Absent" ||
                            data.userstatus === "Notice Period Rejected and Long Absent" ||
                            data.userstatus === "Notice Period Recheck and Long Absent"
                        );
                    }
                    if (status.includes("Long Leave")) {
                        // Condition when "Long Absent" or "Long Leave" is in the array
                        return (
                            data.userstatus === "Long Leave" ||
                            data.userstatus === "Notice Period Applied and Long Leave" ||
                            data.userstatus === "Notice Period Approved and Long Leave" ||
                            data.userstatus === "Notice Period Cancelled and Long Leave" ||
                            data.userstatus === "Notice Period Continue and Long Leave" ||
                            data.userstatus === "Notice Period Rejected and Long Leave" ||
                            data.userstatus === "Notice Period Recheck and Long Leave"
                        );
                    }
                    if (status.includes("Notice Period Applied")) {
                        // Condition when "Long Absent" or "Long Leave" is in the array
                        return (
                            data.userstatus === "Notice Period Applied" ||
                            data.userstatus === "Notice Period Applied and Long Leave" ||
                            data.userstatus === "Notice Period Applied and Long Absent"
                        );
                    }
                    if (status.includes("Notice Period Approved")) {
                        // Condition when "Long Absent" or "Long Leave" is in the array

                        return (
                            data.userstatus === "Notice Period Approved" ||
                            data.userstatus === "Notice Period Approved and Long Leave" ||
                            data.userstatus === "Notice Period Approved and Long Absent"
                        );
                    }
                    if (status.includes("Exit Confirmed")) {
                        // Condition when "Long Absent" or "Long Leave" is in the array
                        return data.userstatus === "Exit Confirmed";
                    }

                    return false; // Default case if none of the conditions are met
                } else {
                    return data;
                }
            });
        return res.status(200).json({
            filterallDatauser: enrichedLeaveAttendanceUsers,
            tableName: filterin,
        });
    } catch (err) {
        return res.status(500).json({ error: "Internal server error" });
    }
});


//controller to get the ex-user names
exports.getFormerUserNames = catchAsyncErrors(async (req, res, next) => {
    let pass, users;
    try {
        users = await User.find(
            {
                resonablestatus: {
                    $in: [
                        "Not Joined",
                        "Postponed",
                        "Rejected",
                        "Closed",
                        "Releave Employee",
                        "Absconded",
                        "Hold",
                        "Terminate",
                    ],
                },
            },
            {
                companyname: 1,
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    return res.status(200).json({
        formerusers: users,
    });
});


exports.getOnBoardingSalaryFix = catchAsyncErrors(async (req, res, next) => {
    try {
        const {
            salaryrange,
            type,
            process,
            amountvalue,
            fromamount,
            toamount,
            company,
            branch,
            batchNumber,
            batchSize,
        } = req.body;

        const amountValue = parseFloat(amountvalue);
        const fromAmount = parseFloat(fromamount);
        const toAmount = parseFloat(toamount);
        const skip = (batchNumber - 1) * batchSize;
        const limit = batchSize;

        // Define the match conditions based on the inputs
        let matchConditions = {
            company: { $in: company },
            branch: { $in: branch },
        };

        if (type === "Process Wise") {
            matchConditions.salarycode = new RegExp("^" + process);
        }

        switch (salaryrange) {
            case "Less Than":
                matchConditions.totalValue = { $lt: amountValue };
                break;
            case "Greater Than":
                matchConditions.totalValue = { $gt: amountValue };
                break;
            case "Exact":
                matchConditions.totalValue = { $eq: amountValue };
                break;
            case "Between":
                matchConditions.totalValue = { $gte: fromAmount, $lte: toAmount };
                break;
        }

        // Perform the optimized aggregation query
        const results = await Salaryslab.aggregate([
            {
                $addFields: {
                    totalValue: {
                        $add: [
                            "$basic",
                            "$hra",
                            "$conveyance",
                            "$medicalallowance",
                            "$productionallowance",
                            "$otherallowance",
                        ],
                    },
                },
            },
            { $match: matchConditions },
            { $skip: skip },
            { $limit: limit },
            {
                $lookup: {
                    from: "targetpoints",
                    localField: "salarycode",
                    foreignField: "processcode",
                    as: "targetpoints",
                },
            },
            {
                $addFields: {
                    targetPointsValue: { $arrayElemAt: ["$targetpoints.points", 0] },
                },
            },
            {
                $project: {
                    targetPointsValue: 1,
                    totalValue: 1,
                    salarycode: 1,
                    company: 1,
                    branch: 1,
                    processqueue: 1,
                },
            },
        ]).exec();

        // Execute the process team query in parallel
        const processTeamData = await ProcessTeam.find(
            {
                company: { $in: company },
                branch: { $in: branch },
                process: { $in: results.map((r) => r.processqueue) },
            },
            { unit: 1, team: 1, company: 1, branch: 1, process: 1 }
        ).lean();

        // Combine the results
        const combinedArray = processTeamData.flatMap((mainItem) =>
            results.map((subItem) => ({
                ...mainItem,
                ...subItem,
                _id: new ObjectId(),
            }))
        );

        // Respond with the result
        return res.status(200).json({ results: combinedArray });
    } catch (err) {
        return res.status(500).json({
            message: "Internal Server Error",
            error: err.message,
        });
    }
});


exports.getAllTemplateUsers = catchAsyncErrors(async (req, res, next) => {
    try {
        const empDocs = await EmployeeDocuments.find({}, { 'files.name': 1, 'files.remark': 1, 'commonid': 1 }).lean();

        const pageSize = 100;
        let page = 0;
        let users;
        let allUsers = [];

        do {
            users = await User.find({}, {
                _id: 1, // Minimal data
                status: 1,
                resonablestatus: 1,
                reasonname: 1,
                lastworkday: 1,
                fathername: 1,
                mothername: 1,
                rejoin: 1,
                reasonablestatusremarks: 1,
                department: 1,
                dob: 1,
                gender: 1,
                maritalstatus: 1,
                bloodgroup: 1,
                location: 1,
                contactpersonal: 1,
                designationlog: 1,
                contactfamily: 1,
                ctaluk: 1,
                dom: 1,
                processlog: 1,
                boardingLog: 1, attendancemode: 1,
                company: 1,
                reasondate: 1,
                empreason: 1,
                percentage: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                username: 1,
                usernameautogenerate: 1,
                workmode: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,

                unit: 1,
                branch: 1,
                designation: 1,
                floor: 1,
                shift: 1,
                reportingto: 1,
                experience: 1,
                doj: 1,
                dot: 1,
                bankname: 1,
                bankdetails: 1,
                bankbranchname: 1,
                accountholdername: 1,
                accountnumber: 1,
                ifsccode: 1,
                shifttiming: 1,
                shiftgrouping: 1,
                legalname: 1,
                pdoorno: 1,
                pstreet: 1,
                candidateid: 1,
                parea: 1,
                plandmark: 1,
                ptaluk: 1,
                ppost: 1,
                ppincode: 1,
                pcountry: 1,
                pstate: 1,
                pcity: 1,
                cdoorno: 1,
                cstreet: 1,
                carea: 1,
                role: 1,
                clandmark: 1,
                ctaluk: 1,
                cpost: 1,
                cpincode: 1,
                ccountry: 1,
                cstate: 1,
                ccity: 1,
                reasondate: 1,
                process: 1,
                workstation: 1,
                weekoff: 1,
                originalpassword: 1,
                enquirystatus: 1,
                area: 1,
                enableworkstation: 1,
                wordcheck: 1,
                shiftallot: 1,
                firstname: 1,
                lastname: 1,
                employeecount: 1,
                emergencyno: 1,
                name: 1,
                salarysetup: 1,
                mode: 1,
                salarycode: 1,
                basic: 1,
                hra: 1,
                conveyance: 1,
                medicalallowance: 1,
                productionallowance: 1,
                otherallowance: 1,
                productionallowancetwo: 1,
                pffromdate: 1,
                pfenddate: 1,
                esifromdate: 1,
                esienddate: 1,
                pfesistatus: 1,
                aadhar: 1,
                panno: 1,
                eduTodo: 1,
                assignEndExpvalue: 1,
                endexpdate: 1,
                assignExpLog: 1,
                workhistTodo: 1,
                age: 1,
                bankdetails: 1,
                addAddQuaTodo: 1,
                referencetodo: 1,
                workstation: 1,
            }).lean().skip(page * pageSize).limit(pageSize);

            if (!users || users.length === 0) break;
            const mappedUsers = users.map((data, index) => {

                const foundData = empDocs.find((item) => item?.commonid?.toString() === data?._id?.toString());
                const employeedocumentfiles = foundData ? foundData.files.map((itemnew) => ({
                    name: itemnew.name,
                    remark: itemnew.remark
                })) : [];

                return { ...data, employeedocumentfiles };
            });

            allUsers = [...allUsers, ...mappedUsers];
            page++;
        } while (users.length === pageSize);

        if (allUsers.length === 0) {
            return next(new ErrorHandler("Users not found", 400));
        }

        // Implementing pagination in response
        const totalPages = Math.ceil(allUsers.length / pageSize);
        const currentPage = parseInt(req.query.page) || 1;
        const paginatedUsers = allUsers.slice((currentPage - 1) * pageSize, currentPage * pageSize);

        return res.status(200).json({ count: allUsers.length, users: allUsers, totalPages, currentPage });
    } catch (err) {
        return next(new ErrorHandler("An error occurred while fetching users", 500));
    }
});

//VerifiedList Update
exports.updateVerifyUser = catchAsyncErrors(async (req, res, next) => {
    const id = req.params.id;
    const upverifyuser = await User.findByIdAndUpdate(id, req.body,
        { new: true }
    );
    if (!upverifyuser) {
        return next(new ErrorHandler("User not found", 404));
    }
    return res.status(200).json({ message: "Updated successfully!", upverifyuser });
});
const getTotalMonthDaysUserPayrun = (rowdepartment, depMonthSet, ismonth, isyear, reasondate) => {
    const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];

    const totalDaysInMonth = new Date(isyear, ismonth, 0).getDate();

    // const depdays = depMonthSet && depMonthSet?.find((d) => d.department === rowdepartment && Number(d.month) === ismonth && Number(d.year) === isyear);
    const depdays = depMonthSet && depMonthSet?.find((d) => d.department === rowdepartment && d.monthname === monthNames[ismonth - 1] && Number(d.year) === isyear);

    if (reasondate != '') {
        const getDatesInRange = (fromDate, toDate) => {
            const oneDay = 24 * 60 * 60 * 1000; // hours*minutes*seconds*milliseconds
            const startDate = new Date(fromDate);
            const endDate = new Date(toDate);

            // Add one day to include the end date
            endDate.setDate(endDate.getDate() + 1);

            let count = 0;
            for (let date = startDate; date < endDate; date.setDate(date.getDate() + 1)) {
                count++;
            }

            return count;
        };
        const monthIndex = new Date(`${monthNames[ismonth - 1]} 1, ${isyear}`).getMonth();
        const monthStartdate = `${isyear}-${String(monthIndex + 1).padStart(2, '0')}-01`;

        const fromdate = depdays ? depdays.fromdate : monthStartdate;
        const tond = getDatesInRange(fromdate, reasondate);
        return tond;
    } else if (depdays) {
        return depdays.totaldays;
    } else {
        return totalDaysInMonth;
    }

};
const getTotalMonthsCurrentDateCountUserPayrun = (rowdoj, rowdepartment, depMonthSet, ismonth, isyear, reasondate) => {
    if (!rowdoj) {
        return '';
    }

    const [year, month, day] = rowdoj?.split('-').map(Number);
    const joiningDate = new Date(year, month - 1, day);
    const currentDate = new Date(isyear, ismonth - 1);

    let totalDays = 0;
    const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];

    // const depdays = depMonthSet?.filter((d) => d.department === rowdepartment && Number(d.month) === ismonth && Number(d.year) === isyear);

    const depdays = depMonthSet?.filter((d) => d.department === rowdepartment && d.monthname === monthNames[ismonth - 1] && Number(d.year) === isyear);
    const depdaysSingle = depMonthSet && depMonthSet?.find((d) => d.department === rowdepartment && d.monthname === monthNames[ismonth - 1] && Number(d.year) === isyear);

    if (reasondate != '' && reasondate != undefined && reasondate != null) {
        const getDatesInRange = (fromDate, toDate) => {
            const oneDay = 24 * 60 * 60 * 1000; // hours*minutes*seconds*milliseconds
            const startDate = new Date(fromDate);
            const endDate = new Date(toDate);

            // Add one day to include the end date
            endDate.setDate(endDate.getDate() + 1);

            let count = 0;
            for (let date = startDate; date < endDate; date.setDate(date.getDate() + 1)) {
                count++;
            }

            return count;
        };
        //FIND MONTH FIRSTDATE
        const monthIndex = new Date(`${monthNames[ismonth - 1]} 1, ${isyear}`).getMonth();
        const monthStartdate = `${isyear}-${String(monthIndex + 1).padStart(2, '0')}-01`;
        const fromdate = depdaysSingle ? depdaysSingle.fromdate : monthStartdate;

        //FIND MONTH LASTDATE
        const monthIndexLastDate = new Date(`${monthNames[ismonth - 1]} 1, ${year}`).getMonth();
        // Create a Date object for the first day of the next month
        const nextMonth = new Date(year, monthIndexLastDate + 1, 1);
        // Subtract one day to get the last day of the current month
        const lastDayOfMonth = new Date(nextMonth - 1);
        // Format the date as "YYYY-MM-DD"
        const monthEndDate = lastDayOfMonth.toISOString().split('T')[0];

        const deptMonthEndDate = depdaysSingle ? depdaysSingle.todate : monthEndDate;
        const todayDateNow = new Date().toISOString().split('T')[0];
        const endDateFinal = new Date(reasondate) > new Date(deptMonthEndDate) ? (new Date(deptMonthEndDate) > new Date() ? todayDateNow : deptMonthEndDate) : reasondate;
        const finalFromdate = new Date(rowdoj) > new Date(fromdate) ? rowdoj : fromdate;
        const tond = getDatesInRange(finalFromdate, endDateFinal);
        return tond;
    } else if (depdays && depdays.length > 0) {
        depdays.forEach((dep) => {
            const fromDate = new Date(dep.fromdate);
            const toDate = new Date(dep.todate);

            // Adjust the time to midnight for joiningDate and toDate
            joiningDate.setHours(0, 0, 0, 0);
            toDate.setHours(0, 0, 0, 0);
            fromDate.setHours(0, 0, 0, 0);

            if (joiningDate < fromDate) {
                if (toDate >= currentDateAttStatus) {
                    // If the joining date is before the department's fromdate
                    const daysInDepartment = Math.ceil((currentDateAttStatus - fromDate) / (1000 * 60 * 60 * 24)); // Add 1 to include the ending day
                    totalDays += daysInDepartment;
                } else if (toDate <= currentDateAttStatus) {
                    // If the joining date is before the department's fromdate
                    const daysInDepartment = Math.ceil((toDate - fromDate) / (1000 * 60 * 60 * 24)); // Add 1 to include the ending day
                    totalDays += daysInDepartment + 1;
                }
            } else {
                if (toDate >= currentDateAttStatus) {
                    // If the joining date is after or on the department's fromdate and toDate is greater than or equal to currentDate
                    const daysInDepartment = Math.ceil((currentDateAttStatus - joiningDate) / (1000 * 60 * 60 * 24)); // Add 1 to include the ending day
                    totalDays += daysInDepartment;
                } else if (toDate <= currentDateAttStatus) {
                    // If the joining date is after or on the department's fromdate and toDate is less than or equal to currentDate
                    const daysInDepartment = Math.ceil((toDate - joiningDate) / (1000 * 60 * 60 * 24)); // Add 1 to include the ending day
                    totalDays += daysInDepartment + (toDate === joiningDate ? 0 : 1);
                }
            }
        });
    } else {
        // Calculate the start date of the month based on the selected month
        const monthfromDate = new Date(isyear, ismonth - 1, 1);
        const monthEndDate = new Date(monthfromDate);
        monthEndDate.setMonth(monthEndDate.getMonth() + 1);
        monthEndDate.setDate(monthEndDate.getDate() - 1);
        if (joiningDate < monthfromDate) {
            if (monthEndDate >= currentDateAttStatus) {
                // If the joining date is before the department's fromdate
                const daysInDepartment = Math.ceil((currentDateAttStatus - monthfromDate) / (1000 * 60 * 60 * 24)); // Add 1 to include the ending day
                totalDays += daysInDepartment;
            } else if (monthEndDate <= currentDateAttStatus) {
                // If the joining date is before the department's fromdate
                const daysInDepartment = Math.ceil((monthEndDate - monthfromDate) / (1000 * 60 * 60 * 24)) + 1; // Add 1 to include the ending day
                totalDays += daysInDepartment;
            }
        } else {
            if (monthEndDate >= currentDateAttStatus) {
                // If the joining date is after or on the department's fromdate and toDate is greater than or equal to currentDate
                const daysInDepartment = Math.ceil((currentDateAttStatus - joiningDate) / (1000 * 60 * 60 * 24)); // Add 1 to include the ending day
                totalDays += daysInDepartment;
            } else if (monthEndDate <= currentDateAttStatus) {
                // If the joining date is after or on the department's fromdate and toDate is less than or equal to currentDate
                const daysInDepartment = Math.ceil((monthEndDate - joiningDate) / (1000 * 60 * 60 * 24)); // Add 1 to include the ending day
                totalDays += daysInDepartment;
            }
        }
    }

    // Check if totalDays is negative and return 0 in that case
    return totalDays < 0 ? 0 : totalDays;
};

exports.getAllUserAttendancePayRun = catchAsyncErrors(async (req, res, next) => {
    let resultshiftallot = [];
    let graceTime;
    let clockOutHours;
    let lateclockincount;
    let earlyclockoutcount;
    let onclockout;
    let earlyclockin;
    let earlyclockout;
    let lateclockin;
    let afterlateclockin;
    let beforeearlyclockout;
    let finaluser = [],
        users;
    const { ismonth, isyear, department } = req.body;

    try {

        await User.collection.createIndex({ companyname: 1, enquirystatus: 1 });
        await DepartmentMonth.collection.createIndex({ monthname: 1, year: 1 });
        await Attendance.collection.createIndex({ userid: 1, date: 1 });

        const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];

        let querydeptmonth = {
            monthname: monthNames[ismonth - 1],
            year: isyear,
        };
        // if (req.body.department.length > 0) {
        //   querydeptmonth.department = { $in: req.body.department };
        // }

        function getMonthStartAndEndDate(monthname, year) {
            // Create a mapping of month names to their 0-based indices
            const monthMap = {
                January: 0,
                February: 1,
                March: 2,
                April: 3,
                May: 4,
                June: 5,
                July: 6,
                August: 7,
                September: 8,
                October: 9,
                November: 10,
                December: 11,
            };

            // Get the month index
            const monthIndex = monthMap[monthname];

            if (monthIndex === undefined) {
                throw new Error('Invalid month name provided.');
            }

            // Start date is the first day of the month
            const monthStartDate = new Date(year, monthIndex, 1);

            // End date is the last day of the month (calculated as the day before the first day of the next month)
            const firstDayNextMonth = new Date(year, monthIndex + 1, 1);
            const monthEndDate = new Date(firstDayNextMonth - 1);

            // Return start and end dates in YYYY-MM-DD format
            return {
                startDate: monthStartDate.toISOString().split('T')[0], // YYYY-MM-DD
                endDate: monthEndDate.toISOString().split('T')[0], // YYYY-MM-DD
            };
        }

        // Example usage
        const { monthStartDate, monthEndDate } = getMonthStartAndEndDate(monthNames[ismonth - 1], Number(isyear));

        let [usersAll, depMonthSet, controlcriteria, shift, holidays, leavetype] = await Promise.all([
            User.find(
                {
                    companyname: { $in: req.body.employees },
                    enquirystatus: {
                        $nin: ['Enquiry Purpose'],
                    },
                },
                {
                    company: 1,
                    branch: 1,
                    unit: 1,
                    team: 1,
                    department: 1,
                    doj: 1,
                    empcode: 1,
                    companyname: 1,
                    team: 1,
                    floor: 1,
                    username: 1,
                    designation: 1,
                    // shift: 1,
                    weekoff: 1,
                    shiftallot: 1,
                    shifttiming: 1,
                    boardingLog: 1,
                    reasondate: 1,
                    resonablestatus: 1,
                    departmentlog: 1,
                }
            ),
            DepartmentMonth.find(querydeptmonth, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 }),
            ControlCriteria.find(),
            Shift.find({}, { name: 1, fromhour: 1, tohour: 1, frommin: 1, tomin: 1, fromtime: 1, totime: 1 }),
            Holiday.find({}, { date: 1, company: 1, applicablefor: 1, unit: 1, team: 1, employee: 1, noofdays: 1 }),
            Leavetype.find({}, { leavetype: 1, code: 1 }),
        ]);

        function filterLatestLogs(monthArray, departmentlog) {
            // Step 1: Sort logs by startdate
            const sortedLogs = [...departmentlog].sort((a, b) => new Date(a.startdate) - new Date(b.startdate));

            // Step 2: Assign an effective end date (next log startdate - 1 day)
            sortedLogs.forEach((log, index) => {
                if (index < sortedLogs.length - 1) {
                    log.enddate = new Date(new Date(sortedLogs[index + 1].startdate).getTime() - 86400000); // 1 day before next log's startdate
                } else {
                    log.enddate = new Date("9999-12-31"); // Default max end date for the last log
                }
            });

            // Step 3: Filter logs based on monthArray and department
            const filteredLogs = sortedLogs.filter(log => {
                return monthArray.some(month => {
                    const fromDate = new Date(month.fromdate);
                    const toDate = new Date(month.todate);
                    const startDate = new Date(log.startdate);
                    const endDate = new Date(log.enddate);

                    return startDate <= toDate && endDate >= fromDate && log.department === month.department;
                });
            });

            // Step 4: Select the latest log per department based on updateddatetime
            const latestLogs = {};
            filteredLogs.forEach(log => {
                const dept = log.department;
                if (!latestLogs[dept] || new Date(log.updateddatetime) > new Date(latestLogs[dept].updateddatetime)) {
                    latestLogs[dept] = log;
                }
            });

            return Object.values(latestLogs);
        }
        function filterLatestLogsTeam(monthArray, teamLog, department) {
            // Step 1: Sort logs by startdate
            const sortedLogs = [...teamLog].sort((a, b) => new Date(a.startdate) - new Date(b.startdate));

            // Step 2: Assign an effective end date (next log startdate - 1 day)
            sortedLogs.forEach((log, index) => {
                if (index < sortedLogs.length - 1) {
                    log.enddate = new Date(new Date(sortedLogs[index + 1].startdate).getTime() - 86400000); // 1 day before next log's startdate
                } else {
                    log.enddate = new Date("9999-12-31"); // Default max end date for the last log
                }
            });

            // Step 3: Filter logs based on monthArray and department
            const filteredLogs = sortedLogs.filter(log => {
                return monthArray.some(month => {
                    const fromDate = new Date(month.fromdate);
                    const toDate = new Date(month.todate);
                    const startDate = new Date(log.startdate);
                    const endDate = new Date(log.enddate);

                    return startDate <= toDate && endDate >= fromDate && department === month.department;
                });
            });

            // Step 4: Select the latest log per department based on updateddatetime
            const latestLogs = {};
            filteredLogs.forEach(log => {
                const dept = log.department;
                if (!latestLogs[dept] || new Date(log.updateddatetime) > new Date(latestLogs[dept].updateddatetime)) {
                    latestLogs[dept] = log;
                }
            });

            return Object.values(latestLogs);
        }

        users = usersAll
            .map((user) => {
                const item = { ...user._doc };
                let filteredBoarding = user.boardingLog.filter((log) => log.logcreation !== 'shift' && log.ischangeteam);

                const finalDepartment = filterLatestLogs(depMonthSet, user.departmentlog).length > 0 ? filterLatestLogs(depMonthSet, user.departmentlog, item.companyname)[(filterLatestLogs(depMonthSet, user.departmentlog).length) - 1]?.department : ""
                item.department = finalDepartment

                item.team = filterLatestLogsTeam(depMonthSet, filteredBoarding, finalDepartment).length > 0 ? filterLatestLogsTeam(depMonthSet, filteredBoarding, finalDepartment)[filterLatestLogsTeam(depMonthSet, filteredBoarding, finalDepartment).length - 1]?.team : ""


                return item;
            })
            .filter((d) => {
                const userDepartmentDate = depMonthSet.find((dms) => d.department === dms.department);
                const fromdate = userDepartmentDate ? new Date(userDepartmentDate.fromdate) : monthStartDate;
                const todate = userDepartmentDate ? new Date(userDepartmentDate.todate) : monthEndDate;
                const dojcompare = d.department == 'Internship' && d.departmentlog.length > 1 ? true : fromdate >= new Date(d.doj) || todate >= new Date(d.doj);
                return dojcompare && (d.reasondate === '' || !d.reasondate || new Date(d.reasondate) >= fromdate || new Date(d.reasondate) >= todate) && department.includes(item.department);
            });


        const resultDateArray = depMonthSet.reduce(
            (acc, curr) => {
                // Compare and update the earliest fromdate
                if (new Date(curr.fromdate) < new Date(acc.fromdate)) {
                    acc.fromdate = curr.fromdate;
                }
                // Compare and update the latest todate
                if (new Date(curr.todate) > new Date(acc.todate)) {
                    acc.todate = curr.todate;
                }
                return acc;
            },
            {
                fromdate: depMonthSet[0].fromdate, // Start with the first fromdate
                todate: depMonthSet[0].todate, // Start with the first todate
            }
        );

        function formatDate(dateString) {
            const [day, month, year] = dateString.split('-');
            return `${year}-${month}-${day}`;
        }

        let attFromDate = resultDateArray.fromdate;
        let attToDate = resultDateArray.todate;

        function getAllDatesBetween(attFromDate, attToDate) {
            // Parse the input dates
            const startDate = new Date(attFromDate);
            const endDate = new Date(attToDate);

            const dateArray = [];
            const currentDate = new Date(startDate);

            // Loop through dates from start to end
            while (currentDate <= endDate) {
                const day = String(currentDate.getDate()).padStart(2, '0'); // Ensure 2 digits
                const month = String(currentDate.getMonth() + 1).padStart(2, '0'); // Months are 0-based
                const year = currentDate.getFullYear();
                dateArray.push(`${day}-${month}-${year}`);

                // Move to the next day
                currentDate.setDate(currentDate.getDate() + 1);
            }

            return dateArray;
        }

        const dateArray = getAllDatesBetween(attFromDate, attToDate);

        const userIds = usersAll.map((user) => user._id);
        const userCds = usersAll.map((user) => user.companyname);

        const [attendance, allLeaveStatus, permission] = await Promise.all([
            Attendance.find({ userid: { $in: userIds }, date: { $in: dateArray } }),
            ApplyLeave.find({ employeename: { $in: userCds } }),
            Permission.find({ employeename: { $in: userCds } }, { employeeid: 1, date: 1, status: 1, applytype: 1, compensationstatus: 1, compensationapplytype: 1, requesthours: 1 }),
        ]);

        // graceTime = controlcriteria[0].gracetime;
        clockOutHours = controlcriteria[0].clockout;
        lateclockincount = controlcriteria[0].lateclockincount;
        earlyclockoutcount = controlcriteria[0].earlyclockoutcount;
        onclockout = controlcriteria[0].onclockout;
        earlyclockin = controlcriteria[0].earlyclockin;
        lateclockin = controlcriteria[0].lateclockin;
        earlyclockout = controlcriteria[0].earlyclockout;
        afterlateclockin = controlcriteria[0].afterlateclockin;
        beforeearlyclockout = controlcriteria[0].afterlateclockin;

        const fromDateSet = [...new Set(depMonthSet.map((d) => d.fromdate))];


        finaluser = users?.flatMap((item, index) => {
            let isEmployeeGrace = controlcriteria[0].todos && controlcriteria[0].todos.find((d) => d.company === item.company && d.branch === item.branch && d.unit === item.unit && d.team === item.team && d.employeename === item.companyname);

            if (isEmployeeGrace) {
                graceTime = isEmployeeGrace.employeegracetime;
            } else {
                graceTime = controlcriteria[0].gracetime;
            }

            let userDates = [];

            // Remove duplicate entries with the most recent entry
            const uniqueEntriesDep = {};
            item.departmentlog?.forEach((entry) => {
                const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                const key = entry.startdate;

                if (!(key in uniqueEntriesDep)) {
                    uniqueEntriesDep[key] = entry;
                }
            });

            const comparedDate = depMonthSet?.filter((d) => d.department === item.department);

            const dojDate = item.boardingLog.length > 0 ? item.boardingLog[0].startdate : item.doj;

            if (comparedDate && comparedDate.length > 0) {
                comparedDate?.forEach((dep) => {
                    if (!dep.fromdate && !dep.todate) {
                        return '';
                    }

                    if (!item.doj) {
                        return '';
                    }

                    const [year2, month2, day2] = dojDate?.split('-').map(Number);
                    const joiningDate = new Date(year2, month2 - 1, day2);
                    const [year1, month1, day1] = dep.fromdate?.split('-').map(Number);
                    const [year, month, day] = dep.todate?.split('-').map(Number);
                    const lastDate = new Date(year, month - 1, day);
                    const firstDate = new Date(year1, month1 - 1, day1);

                    if (joiningDate < firstDate) {
                        // Check if the shift date is before or equal to the current date
                        if (lastDate >= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(firstDate);
                            // Loop through the dates in the range
                            while (startDate <= currentDateAttStatus) {
                                userDates.push({
                                    formattedDate: format(startDate, 'dd/MM/yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        } else if (lastDate <= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(firstDate);
                            // Loop through the dates in the range
                            while (startDate <= lastDate) {
                                userDates.push({
                                    formattedDate: format(startDate, 'dd/MM/yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        }
                    } else {
                        // Check if the shift date is before or equal to the current date
                        if (lastDate >= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(joiningDate);
                            // Loop through the dates in the range
                            while (startDate <= currentDateAttStatus) {
                                userDates.push({
                                    formattedDate: format(startDate, 'dd/MM/yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        } else if (lastDate <= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(joiningDate);
                            // Loop through the dates in the range
                            while (startDate <= lastDate) {
                                userDates.push({
                                    formattedDate: format(startDate, 'dd/MM/yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        }
                    }
                });
            } else {
                const [year2, month2, day2] = item.doj?.split('-').map(Number);
                const joiningDate = new Date(year2, month2 - 1, day2);
                // Calculate the start date of the month based on the selected month
                const startDate = new Date(isyear, ismonth - 1, 1);

                const endDate = new Date(startDate);
                endDate.setMonth(endDate.getMonth() + 1);
                endDate.setDate(endDate.getDate() - 1);

                if (joiningDate < startDate) {
                    // Check if the shift date is before or equal to the current date
                    if (endDate >= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            userDates.push({
                                formattedDate: format(currentDate1, 'dd/MM/yyyy'),
                                dayName: format(currentDate1, 'EEEE'),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    } else if (endDate <= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            userDates.push({
                                formattedDate: format(currentDate1, 'dd/MM/yyyy'),
                                dayName: format(currentDate1, 'EEEE'),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    }
                } else {
                    // Check if the shift date is before or equal to the current date
                    if (endDate >= currentDateAttStatus) {
                        // If matched, push the range from 'fromdate' to 'todate'
                        const startDate = new Date(joiningDate);
                        // Loop through the dates in the range
                        while (startDate <= currentDateAttStatus) {
                            userDates.push({
                                formattedDate: format(startDate, 'dd/MM/yyyy'),
                                dayName: format(startDate, 'EEEE'),
                                dayCount: startDate.getDate(),
                            });
                            startDate.setDate(startDate.getDate() + 1);
                        }
                    } else if (endDate <= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            userDates.push({
                                formattedDate: format(currentDate1, 'dd/MM/yyyy'),
                                dayName: format(currentDate1, 'EEEE'),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    }
                }
            }

            item.shiftallot?.map((allot) => {
                resultshiftallot.push({ ...allot });
            });

            const filteredMatchingDoubleShiftItem = resultshiftallot?.filter((val) => val && val.empcode === item.empcode && val.adjstatus === 'Approved');

            // Filter out the dates that have matching 'Shift Adjustment' todates
            let removedUserDates = userDates.filter((date) => {
                // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
                const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem.find((item) => item && item.todate === date.formattedDate && item.adjustmenttype === 'Shift Adjustment');

                // If there is no matching 'Shift Adjustment', keep the date
                return !matchingShiftAdjustmentToDate;
            });

            // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
            let uniqueEntries = new Set();

            // Iterate over removedUserDates and add unique entries to the Set
            removedUserDates.forEach((date) => {
                uniqueEntries.add(
                    JSON.stringify({
                        formattedDate: date.formattedDate,
                        dayName: date.dayName,
                        dayCount: date.dayCount,
                        shiftMode: 'Main Shift',
                        weekNumberInMonth: date.weekNumberInMonth,
                    })
                );
            });

            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach((item) => {
                const [day, month, year] = item._doc.adjdate?.split('/');
                let newFormattedDate = new Date(`${year}-${month}-${day}`);

                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(
                        JSON.stringify({
                            formattedDate: item._doc.adjdate,
                            dayName: moment(item._doc.adjdate, 'DD/MM/YYYY').format('dddd'),
                            dayCount: parseInt(moment(item._doc.adjdate, 'DD/MM/YYYY').format('DD')),
                            shiftMode: 'Second Shift',
                            weekNumberInMonth:
                                getWeekNumberInMonth(newFormattedDate) === 1
                                    ? `${getWeekNumberInMonth(newFormattedDate)}st Week`
                                    : getWeekNumberInMonth(newFormattedDate) === 2
                                        ? `${getWeekNumberInMonth(newFormattedDate)}nd Week`
                                        : getWeekNumberInMonth(newFormattedDate) === 3
                                            ? `${getWeekNumberInMonth(newFormattedDate)}rd Week`
                                            : getWeekNumberInMonth(newFormattedDate) > 3
                                                ? `${getWeekNumberInMonth(newFormattedDate)}th Week`
                                                : '',
                        })
                    );
                }
            });

            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries).map((entry) => JSON.parse(entry));

            function sortUserDates(dates) {
                return dates.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);
            const createdUserDates = sortedCreatedUserDates?.filter((d) => {
                const filterData = userDates.some((val) => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date) => {
                let filteredRowData = resultshiftallot?.filter((val) => val.empcode == item.empcode);
                const matchingItem = filteredRowData?.find((item) => item && item.adjdate == date.formattedDate);
                const matchingItemAllot = filteredRowData?.find((item) => item && formatDate(item.date) == date.formattedDate);
                const matchingDoubleShiftItem = filteredRowData.find((item) => item && item.todate === date.formattedDate);
                const matchingRemovedItem = filteredRowData.find((item) => item.removedshiftdate === date.formattedDate);
                const matchingAssignShiftItem = filteredRowData?.find(item => item.adjdate === date.formattedDate && item.adjstatus === 'Approved' && item.adjustmenttype === 'Assign Shift');

                const filterBoardingLog =
                    item.boardingLog &&
                    item.boardingLog?.filter((item) => {
                        return item.logcreation === 'user' || item.logcreation === 'shift';
                        // return item;
                    });

                const attendanceFiltered = attendance.filter((d) => {
                    const datevalue = formatDate(d.date);
                    return d.username == item.username && new Date(datevalue) >= new Date(attFromDate) && new Date(datevalue) <= new Date(attToDate);
                });

                const depMonthSetFiltered = depMonthSet.filter((d) => d.department === item.department);
                // Check if the dayName is Sunday or Monday    
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, item.departmentlog, depMonthSetFiltered) === 'Week Off' ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                const isHadreasondate = item.reasondate != '' ? item.reasondate : '';

                const row = {
                    id: `${item._id.toString()}_${date.formattedDate}_${date.shiftMode}`,
                    userid: item._id.toString(),
                    company: item.company,
                    branch: item.branch,
                    unit: item.unit,
                    team: item.team,
                    department: item.department,
                    username: item.companyname,
                    empcode: item.empcode,
                    weekoff: item.weekoff,
                    boardingLog: item.boardingLog,
                    shiftallot: item.shiftallot,
                    doj: item.doj,
                    shift: getShiftForDateProdDay(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered, matchingRemovedItem, matchingAssignShiftItem),
                    date: `${date.formattedDate} ${date.dayName} ${date.dayCount}`,
                    role: item.role,
                    rowformattedDate: date.formattedDate,
                    dayName: date.dayName,
                    shiftMode: date.shiftMode,
                    reasondate: item.reasondate,
                    clockin: checkGetClockInTime(
                        attendanceFiltered,
                        item._id.toString(),
                        date.formattedDate,
                        getShiftForDateProdDay(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered, matchingRemovedItem, matchingAssignShiftItem),
                        date.shiftMode
                    ),
                    clockout: checkGetClockOutTime(
                        attendanceFiltered,
                        item._id.toString(),
                        date.formattedDate,
                        getShiftForDateProdDay(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered, matchingRemovedItem, matchingAssignShiftItem),
                        date.shiftMode
                    ),
                    clockinstatus: checkClockInStatus(
                        checkGetClockInTime(
                            attendanceFiltered,
                            item._id.toString(),
                            date.formattedDate,
                            getShiftForDateProdDay(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered, matchingRemovedItem, matchingAssignShiftItem),
                            date.shiftMode
                        ),
                        getShiftForDateProdDay(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered, matchingRemovedItem, matchingAssignShiftItem),
                        graceTime,
                        allLeaveStatus,
                        holidays,
                        checkGetClockInDate(attendanceFiltered, item._id.toString(), date.formattedDate, date.shiftMode),
                        item.branch,
                        item.empcode,
                        item.company,
                        date.formattedDate,
                        item.unit,
                        item.team,
                        item.companyname,
                        earlyclockin,
                        lateclockin,
                        afterlateclockin,
                        leavetype,
                        permission,
                        checkGetClockOutTime(
                            attendanceFiltered,
                            item._id.toString(),
                            date.formattedDate,
                            getShiftForDateProdDay(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered, matchingRemovedItem, matchingAssignShiftItem),
                            date.shiftMode
                        ),
                        date.shiftMode,
                        checkWeekOffPresentStatus(attendanceFiltered, item._id.toString(), date.formattedDate, date.shiftMode)
                    ),
                    clockoutstatus: checkClockOutStatus(
                        checkGetClockOutTime(
                            attendanceFiltered,
                            item._id.toString(),
                            date.formattedDate,
                            getShiftForDateProdDay(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered, matchingRemovedItem, matchingAssignShiftItem),
                            date.shiftMode
                        ),
                        checkGetClockInTime(
                            attendanceFiltered,
                            item._id.toString(),
                            date.formattedDate,
                            getShiftForDateProdDay(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered, matchingRemovedItem, matchingAssignShiftItem),
                            date.shiftMode
                        ),
                        getShiftForDateProdDay(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered, matchingRemovedItem, matchingAssignShiftItem),
                        clockOutHours,
                        checkGetClockInDate(attendanceFiltered, item._id.toString(), date.formattedDate, date.shiftMode),
                        allLeaveStatus,
                        holidays,
                        item.branch,
                        item.empcode,
                        item.company,
                        date.formattedDate,
                        item.unit,
                        item.team,
                        item.companyname,
                        onclockout,
                        earlyclockout,
                        beforeearlyclockout,
                        checkGetClockInAutoStatus(attendanceFiltered, item._id.toString(), date.formattedDate, date.shiftMode),
                        leavetype,
                        permission,
                        date.shiftMode,
                        checkWeekOffPresentStatus(attendanceFiltered, item._id.toString(), date.formattedDate, date.shiftMode)
                    ),
                    attendanceautostatus: checkAttendanceStatus(attendanceFiltered, item._id.toString(), date.formattedDate, date.shiftMode),
                    lateclockincount: lateclockincount,
                    earlyclockoutcount: earlyclockoutcount,
                    totalnumberofdays: getTotalMonthDaysUser(item.department, depMonthSetFiltered, ismonth, isyear),
                    empshiftdays: getTotalMonthDaysForEmpUser(item.doj, item.department, depMonthSetFiltered, ismonth, isyear),
                    totalcounttillcurrendate: getTotalMonthsCurrentDateCountUser(item.doj, item.department, depMonthSetFiltered, ismonth, isyear),
                    totalshift: getTotalShiftHoursUser(item._id.toString(), createdUserDates, attendanceFiltered, getShiftForDateProdDay(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered, matchingRemovedItem, matchingAssignShiftItem)),
                    weekoffpresentstatus: checkWeekOffPresentStatus(attendanceFiltered, item._id.toString(), date.formattedDate, date.shiftMode),
                };
                return row;
            });

            return userRows;
        });
    } catch (err) {
        return next(new ErrorHandler('Records not found!', 404));
    }

    if (!finaluser) {
        return next(new ErrorHandler('Users not found', 400));
    }

    return res.status(200).json({ finaluser });
});
exports.updatePayrunListInnerDataUser = catchAsyncErrors(async (req, res, next) => {

    const { outerId, month, value, year, date, fieldName } = req.body; // Extract the inner ID, month, value, year, date, and dynamic field name from the request body

    const update = {
        $push: {
            [fieldName]: { month, value, year, date }
        }
    };


    const options = {

        new: true
    };


    let upayrunlist = await User.findOneAndUpdate(
        { _id: outerId },
        update,
        options
    );


    if (!upayrunlist) {
        return next(new ErrorHandler("Data not found!", 404));
    }

    return res.status(200).json({ message: "Updated successfully", upayrunlist });
});

exports.undoPayrunListInnerDataUser = catchAsyncErrors(async (req, res, next) => {

    const { outerId, fieldName } = req.body;


    const update = {
        $set: {
            [fieldName]: []
        }
    };


    const options = {

        new: true
    };


    let upayrunlist = await User.findOneAndUpdate(
        { _id: outerId },
        update,
        options
    );


    if (!upayrunlist) {
        return next(new ErrorHandler("Data not found!", 404));
    }

    return res.status(200).json({ message: "Updated successfully", upayrunlist });
});


exports.getUserDocumentPrep = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {
        users = await User.find(
            {
                companyname: req.body.name,
            },
            {
                companyname: 1,
                company: 1,
                branch: 1,
                unit: 1,
                team: 1,
                designation: 1,
                id: 1,
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: users.length, users });
});

//emp login status
exports.getAllUserLoginStatus = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {

        users = await User.find(
            {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
                resonablestatus: {
                    $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
                // $where: function() {
                //     return this.loginUserStatus && this.loginUserStatus.length > 0;
                //   }
            },
            {
                empcode: 1,
                companyname: 1,
                username: 1,
                branch: 1,
                unit: 1,
                designation: 1,
                team: 1,
                department: 1,
                company: 1,
                extratime: 1,
                extrastatus: 1,
                extradate: 1,
                loginUserStatus: 1, wfhcount: 1, wfhstatus: 1
            }
        );
    } catch (err) {
        return next(new ErrorHandler("User not found!", 404));
    }
    if (!users) {
        return next(new ErrorHandler("User not found!", 404));
    }
    return res.status(200).json({
        users,
    });
});

// Employee LoginStatus Filter
exports.getAllUserLoginStatusFilter = catchAsyncErrors(async (req, res, next) => {
    let users;
    const { aggregationPipeline, assignbranch } = req.body;
    try {
        const branchFilters = assignbranch?.map(branchObj => ({
            company: branchObj.company,
            branch: branchObj.branch,
            unit: branchObj.unit,
        })) || [];

        const matchStage = branchFilters.length ? [{ $match: { $or: branchFilters } }] : [];
        const projectStage = [
            {
                $project: {
                    empcode: 1,
                    companyname: 1,
                    username: 1,
                    branch: 1,
                    unit: 1,
                    designation: 1,
                    team: 1,
                    department: 1,
                    company: 1,
                    extratime: 1,
                    extrastatus: 1,
                    extradate: 1,
                    loginUserStatus: 1,
                    wfhcount: 1,
                    wfhstatus: 1,
                    _id: 1, // Exclude `_id` if not needed
                }
            }
        ];
        const updatedAggregationPipeline = [...matchStage, ...aggregationPipeline, ...projectStage];
        users = await User.aggregate(updatedAggregationPipeline);
        // users = await User.find(
        //     {

        //         enquirystatus: {
        //             $nin: ["Enquiry Purpose"],
        //         },
        //         resonablestatus: {
        //             $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
        //         },
        //         // $where: function() {
        //         //     return this.loginUserStatus && this.loginUserStatus.length > 0;
        //         //   }
        //     },
        //     {
        //         empcode: 1,
        //         companyname: 1,
        //         username: 1,
        //         branch: 1,
        //         unit: 1,
        //         designation: 1,
        //         team: 1,
        //         department: 1,
        //         company: 1,
        //         extratime: 1,
        //         extrastatus: 1,
        //         extradate: 1,
        //         loginUserStatus: 1, wfhcount: 1, wfhstatus: 1
        //     }
        // );
    } catch (err) {
        return next(new ErrorHandler("User not found!", 404));
    }
    if (!users) {
        return next(new ErrorHandler("User not found!", 404));
    }
    return res.status(200).json({
        users,
    });
});




exports.getAllUserEnquiryLive = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {
        users = await User.find(
            {
                resonablestatus: {
                    $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
            },
            {
                company: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                floor: 1,
                username: 1,
                unit: 1,
                branch: 1,
                designation: 1,
                department: 1,
                empcode: 1
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }
    return res.status(200).json({ users });
});
exports.getAllUserClockinAndClockoutStatusDocumentPreparation = catchAsyncErrors(async (req, res, next) => {
    let users;
    let controlcriteria;
    let depMonthSet;
    let attendance;
    let allLeaveStatus;
    let leavetype;
    let permission;
    let holidays;
    let resultshiftallot = [];
    let graceTime;
    let clockOutHours;
    let lateclockincount;
    let earlyclockoutcount;
    let onclockout;
    let earlyclockin;
    let earlyclockout;
    let lateclockin;
    let afterlateclockin;
    let beforeearlyclockout;
    let finaluser = [];
    const { userDates, person } = req.body;

    const formattedUserDates = userDates.map((data) => moment(data.formattedDate, "DD/MM/YYYY").format("DD-MM-YYYY"));

    try {
        users = await User.find(
            {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
                resonablestatus: {
                    $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
                username: person
            }, {
            company: 1,
            branch: 1,
            unit: 1,
            team: 1,
            department: 1,
            doj: 1,
            empcode: 1,
            companyname: 1,
            team: 1,
            floor: 1,
            username: 1,
            designation: 1,
            weekoff: 1,
            shiftallot: 1,
            shifttiming: 1,
            boardingLog: 1, attendancemode: 1,
            departmentlog: 1,
        }
        );
        controlcriteria = await ControlCriteria.find();
        depMonthSet = await DepartmentMonth.find({}, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 });

        attendance = await Attendance.find({
            date: { $in: formattedUserDates },
            username: person
        });
        const userCds = users.map(user => user.companyname);
        allLeaveStatus = await ApplyLeave.find({ employeename: { $in: userCds } });
        holidays = await Holiday.find({}, { date: 1, company: 1, applicablefor: 1, unit: 1, team: 1, employee: 1, noofdays: 1 });
        leavetype = await Leavetype.find({}, { leavetype: 1, code: 1 });
        permission = await Permission.find({ employeename: { $in: userCds } }, { employeeid: 1, date: 1, status: 1, applytype: 1, compensationstatus: 1, compensationapplytype: 1, requesthours: 1, shiftmode: 1, });

        // graceTime = controlcriteria[0].gracetime;
        clockOutHours = controlcriteria[0].clockout;
        lateclockincount = controlcriteria[0].lateclockincount;
        earlyclockoutcount = controlcriteria[0].earlyclockoutcount;
        onclockout = controlcriteria[0].onclockout;
        earlyclockin = controlcriteria[0].earlyclockin;
        lateclockin = controlcriteria[0].lateclockin;
        earlyclockout = controlcriteria[0].earlyclockout;
        afterlateclockin = controlcriteria[0].afterlateclockin;
        beforeearlyclockout = controlcriteria[0].afterlateclockin;

        finaluser = users?.flatMap((item, index) => {

            let isEmployeeGrace = controlcriteria[0].todos && controlcriteria[0].todos.find(d => d.company === item.company &&
                d.branch === item.branch && d.unit === item.unit && d.team === item.team &&
                d.employeename === item.companyname
            )

            if (isEmployeeGrace) {
                graceTime = isEmployeeGrace.employeegracetime;
            }
            else {
                graceTime = controlcriteria[0].gracetime;
            }

            item.shiftallot?.map(allot => {
                resultshiftallot.push({ ...allot })
            })

            const filteredMatchingDoubleShiftItem = resultshiftallot?.filter(val => val && val?._doc?.empcode === item?._doc?.empcode && val?._doc?.adjstatus === 'Approved');
            const dojDate = item?._doc?.boardingLog.length > 0 ?
                new Date(item?._doc?.boardingLog[0].startdate)
                : new Date(item?._doc?.doj);
            // Filter out the dates that have matching 'Shift Adjustment' todates
            let removedUserDates = userDates.filter(date => {
                // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
                const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem.find(item => item && item?._doc?.todate === date.formattedDate && item?._doc?.adjustmenttype === 'Shift Adjustment');

                // If there is no matching 'Shift Adjustment', keep the date
                return !matchingShiftAdjustmentToDate;
            });

            // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
            let uniqueEntries = new Set();

            // Iterate over removedUserDates and add unique entries to the Set
            userDates.forEach(date => {
                uniqueEntries.add(JSON.stringify({
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    shiftMode: 'Main Shift',
                    weekNumberInMonth: date.weekNumberInMonth,
                }));
            });

            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach(item => {
                const [day, month, year] = item._doc.adjdate?.split('/')
                let newFormattedDate = new Date(`${year}-${month}-${day}`);

                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(JSON.stringify({
                        formattedDate: item._doc.adjdate,
                        dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
                        dayCount: parseInt(moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")),
                        shiftMode: 'Second Shift',
                        weekNumberInMonth: (getWeekNumberInMonth(newFormattedDate) === 1 ? `${getWeekNumberInMonth(newFormattedDate)}st Week` :
                            getWeekNumberInMonth(newFormattedDate) === 2 ? `${getWeekNumberInMonth(newFormattedDate)}nd Week` :
                                getWeekNumberInMonth(newFormattedDate) === 3 ? `${getWeekNumberInMonth(newFormattedDate)}rd Week` :
                                    getWeekNumberInMonth(newFormattedDate) > 3 ? `${getWeekNumberInMonth(newFormattedDate)}th Week` : '')
                    }));
                }
            });

            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries).map(entry => JSON.parse(entry));

            function sortUserDates(dates) {
                return dates.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);
            const createdUserDates = sortedCreatedUserDates?.filter(d => {
                const filterData = userDates.some(val => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date) => {
                let filteredRowData = resultshiftallot?.filter((val) => val?._doc?.empcode == item?._doc?.empcode);
                const matchingItem = filteredRowData?.find(item => item && item?._doc?.adjdate == date.formattedDate);
                const matchingItemAllot = filteredRowData?.find(item => item && formatDate(item?._doc?.date) == date.formattedDate);
                const matchingDoubleShiftItem = filteredRowData?.find(item => item && item?._doc?.todate === date.formattedDate);
                const matchingRemovedItem = filteredRowData?.find(item => item?._doc?.removedshiftdate === date.formattedDate);
                const matchingAssignShiftItem = filteredRowData?.find(item => item?._doc?.adjdate === date.formattedDate && item?._doc?.adjstatus === 'Approved' && item?._doc?.adjustmenttype === 'Assign Shift');

                const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                    // return item;
                });

                // Remove duplicate entries with the most recent entry
                const uniqueEntriesDep = {};
                item?._doc?.departmentlog?.forEach(entry => {
                    const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                    const key = entry.startdate;
                    if (!(key in uniqueEntriesDep)) {
                        uniqueEntriesDep[key] = entry;
                    }
                });

                const uniqueDepLog = Object.values(uniqueEntriesDep);
                const [columnDay, columnMonth, columnYear] = date.formattedDate?.split('/');
                const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

                // Find the relevant log entry for the given date     
                const relevantDepLogEntry = uniqueDepLog
                    .filter(log => log.startdate <= finalDate)
                    .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item?._doc?.weekoff?.includes(date.dayName);
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                const row = {
                    id: `${item?._doc?._id.toString()}_${date.formattedDate}_${date.shiftMode}`,
                    userid: item?._doc?._id.toString(),
                    company: item?._doc?.company,
                    branch: item?._doc?.branch,
                    unit: item?._doc?.unit,
                    team: item?._doc?.team,
                    doj: dojDate,
                    department: relevantDepLogEntry && relevantDepLogEntry?.department,
                    username: item?._doc?.companyname,
                    empcode: item?._doc?.empcode,
                    weekoff: item?._doc?.weekoff,
                    boardingLog: item?._doc?.boardingLog,
                    shiftallot: item?._doc?.shiftallot,
                    shift: getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                    date: `${date.formattedDate} ${date.dayName} ${date.dayCount}`,
                    rowformattedDate: date.formattedDate,
                    dayName: date.dayName,
                    shiftMode: date.shiftMode,
                    clockin: checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        date.shiftMode,
                    ),
                    clockout: checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        date.shiftMode,
                    ),
                    clockinstatus: checkClockInStatus(
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        graceTime, allLeaveStatus, holidays,
                        checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,), item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname,
                        earlyclockin, lateclockin, afterlateclockin, leavetype, permission,
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    clockoutstatus: checkClockOutStatus(
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        clockOutHours, checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        allLeaveStatus, holidays, item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname, onclockout,
                        earlyclockout, beforeearlyclockout,
                        checkGetClockInAutoStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        leavetype, permission, date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    attendanceautostatus: checkAttendanceStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    lateclockincount: lateclockincount,
                    earlyclockoutcount: earlyclockoutcount,
                    weekoffpresentstatus: checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                };


                return row;
            });

            return userRows;

        });
    } catch (err) {
        console.log(err , 'err')
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finaluser) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ finaluser });
});
exports.getAllUserClockinAndClockoutStatusForMontLopCalFilterDocPrep = catchAsyncErrors(async (req, res, next) => {
    let users;
    let controlcriteria;
    let attendance;
    let allLeaveStatus;
    let leavetype;
    let permission;
    let holidays;
    let resultshiftallot = [];
    let depMonthSet;
    let graceTime;
    let clockOutHours;
    let lateclockincount;
    let earlyclockoutcount;
    let onclockout;
    let earlyclockin;
    let earlyclockout;
    let lateclockin;
    let afterlateclockin;
    let beforeearlyclockout;
    let finaluser = [];
    const { ismonth, isyear, username } = req.body;

    try {
        users = await User.find(
            {
                company: req.body.company,
                branch: req.body.branch,
                unit: req.body.unit,
                username: username,
                department: req.body.department,
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
                resonablestatus: {
                    $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
            }, {
            company: 1,
            branch: 1,
            unit: 1,
            team: 1,
            department: 1,
            doj: 1,
            empcode: 1,
            companyname: 1,
            team: 1,
            floor: 1,
            username: 1,
            designation: 1,
            weekoff: 1,
            shiftallot: 1,
            shifttiming: 1,
            boardingLog: 1, attendancemode: 1,
            departmentlog: 1,
        }
        );
        depMonthSet = await DepartmentMonth.find({}, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 });
        controlcriteria = await ControlCriteria.find();

        const userIds = users.map(user => user._id);
        attendance = await Attendance.find({ userid: { $in: userIds } });
        const userCds = users.map(user => user.companyname);
        allLeaveStatus = await ApplyLeave.find({ employeename: { $in: userCds } });
        holidays = await Holiday.find({}, { date: 1, company: 1, applicablefor: 1, unit: 1, team: 1, employee: 1, noofdays: 1 });
        leavetype = await Leavetype.find({}, { leavetype: 1, code: 1 });
        permission = await Permission.find({ employeename: { $in: userCds } }, { employeeid: 1, date: 1, status: 1, applytype: 1, compensationstatus: 1, compensationapplytype: 1, requesthours: 1, shiftmode: 1, });

        // graceTime = controlcriteria[0].gracetime;
        clockOutHours = controlcriteria[0].clockout;
        lateclockincount = controlcriteria[0].lateclockincount;
        earlyclockoutcount = controlcriteria[0].earlyclockoutcount;
        onclockout = controlcriteria[0].onclockout;
        earlyclockin = controlcriteria[0].earlyclockin;
        lateclockin = controlcriteria[0].lateclockin;
        earlyclockout = controlcriteria[0].earlyclockout;
        afterlateclockin = controlcriteria[0].afterlateclockin;
        beforeearlyclockout = controlcriteria[0].afterlateclockin;

        const monthNames = ["January", "February", "March", "April", "May", "June",
            "July", "August", "September", "October", "November", "December"
        ];

        finaluser = users?.flatMap((item, index) => {

            let isEmployeeGrace = controlcriteria[0].todos && controlcriteria[0].todos.find(d => d.company === item.company &&
                d.branch === item.branch && d.unit === item.unit && d.team === item.team &&
                d.employeename === item.companyname
            )

            if (isEmployeeGrace) {
                graceTime = isEmployeeGrace.employeegracetime;
            }
            else {
                graceTime = controlcriteria[0].gracetime;
            }

            let userDates = [];

            // Remove duplicate entries with the most recent entry
            const uniqueEntriesDep = {};
            item.departmentlog?.forEach(entry => {
                const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                const key = entry.startdate;
                if (!(key in uniqueEntriesDep)) {
                    uniqueEntriesDep[key] = entry;
                }
            });
            const foundDepartment = depMonthSet?.find((d) => Number(d.year) === isyear && d.monthname === monthNames[ismonth - 1]);
            const uniqueDepLog = Object.values(uniqueEntriesDep);
            const relevantDepLogEntry = uniqueDepLog
                .filter(log => new Date(log.startdate) <= new Date(foundDepartment && foundDepartment.fromdate))
                .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

            const comparedDate = depMonthSet?.filter((d) => d.department === (relevantDepLogEntry && relevantDepLogEntry.department) && Number(d.year) === isyear && d.monthname === monthNames[ismonth - 1]);
            const dojDate = item?._doc?.boardingLog.length > 0 ?
                item?._doc?.boardingLog[0].startdate
                : item?._doc?.doj;

            if (comparedDate && comparedDate.length > 0) {
                comparedDate?.forEach((dep) => {
                    if (!dep.fromdate && !dep.todate) {
                        return '';
                    }

                    if (!item?._doc?.doj) {
                        return "";
                    }

                    const [year2, month2, day2] = dojDate?.split('-').map(Number);
                    const joiningDate = new Date(year2, month2 - 1, day2);
                    const [year1, month1, day1] = dep.fromdate?.split('-').map(Number);
                    const [year, month, day] = dep.todate?.split('-').map(Number);
                    const lastDate = new Date(year, month - 1, day);
                    const firstDate = new Date(year1, month1 - 1, day1);

                    if (joiningDate < firstDate) {
                        // Check if the shift date is before or equal to the current date
                        if (lastDate >= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(firstDate);
                            // Loop through the dates in the range
                            while (startDate <= currentDateAttStatus) {
                                userDates.push({
                                    formattedDate: format(startDate, 'dd/MM/yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        } else if (lastDate <= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(firstDate);
                            // Loop through the dates in the range
                            while (startDate <= lastDate) {
                                userDates.push({
                                    formattedDate: format(startDate, 'dd/MM/yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        }
                    } else {
                        // Check if the shift date is before or equal to the current date
                        if (lastDate >= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(joiningDate);
                            // Loop through the dates in the range
                            while (startDate <= currentDateAttStatus) {
                                userDates.push({
                                    formattedDate: format(startDate, 'dd/MM/yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        }
                        else if (lastDate <= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(joiningDate);
                            // Loop through the dates in the range
                            while (startDate <= lastDate) {
                                userDates.push({
                                    formattedDate: format(startDate, 'dd/MM/yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        }
                    }
                });
            }
            else {
                const [year2, month2, day2] = dojDate?.split('-').map(Number);
                const joiningDate = new Date(year2, month2 - 1, day2);
                // Calculate the start date of the month based on the selected month
                const startDate = new Date(isyear, ismonth - 1, 1);

                const endDate = new Date(startDate);
                endDate.setMonth(endDate.getMonth() + 1);
                endDate.setDate(endDate.getDate() - 1);

                if (joiningDate < startDate) {
                    // Check if the shift date is before or equal to the current date
                    if (endDate >= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            userDates.push({
                                formattedDate: format(currentDate1, 'dd/MM/yyyy'),
                                dayName: format(currentDate1, 'EEEE'),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    } else if (endDate <= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            userDates.push({
                                formattedDate: format(currentDate1, 'dd/MM/yyyy'),
                                dayName: format(currentDate1, 'EEEE'),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    }
                } else {
                    // Check if the shift date is before or equal to the current date
                    if (endDate >= currentDateAttStatus) {
                        // If matched, push the range from 'fromdate' to 'todate'
                        const startDate = new Date(joiningDate);
                        // Loop through the dates in the range
                        while (startDate <= currentDateAttStatus) {
                            userDates.push({
                                formattedDate: format(startDate, 'dd/MM/yyyy'),
                                dayName: format(startDate, 'EEEE'),
                                dayCount: startDate.getDate(),
                            });
                            startDate.setDate(startDate.getDate() + 1);
                        }
                    } else if (endDate <= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            userDates.push({
                                formattedDate: format(currentDate1, 'dd/MM/yyyy'),
                                dayName: format(currentDate1, 'EEEE'),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    }
                }
            }

            item.shiftallot?.map(allot => {
                resultshiftallot.push({ ...allot })
            })

            const filteredMatchingDoubleShiftItem = resultshiftallot?.filter(val => val && val?._doc?.empcode === item?._doc?.empcode && val?._doc?.adjstatus === 'Approved');

            // Filter out the dates that have matching 'Shift Adjustment' todates
            let removedUserDates = userDates.filter(date => {
                // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
                const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem.find(item => item && item?._doc?.todate === date.formattedDate && item?._doc?.adjustmenttype === 'Shift Adjustment');

                // If there is no matching 'Shift Adjustment', keep the date
                return !matchingShiftAdjustmentToDate;
            });

            // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
            let uniqueEntries = new Set();

            // Iterate over removedUserDates and add unique entries to the Set
            userDates.forEach(date => {
                uniqueEntries.add(JSON.stringify({
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    shiftMode: 'Main Shift',
                    weekNumberInMonth: date.weekNumberInMonth,
                }));
            });

            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach(item => {
                const [day, month, year] = item._doc.adjdate?.split('/')
                let newFormattedDate = new Date(`${year}-${month}-${day}`);

                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(JSON.stringify({
                        formattedDate: item._doc.adjdate,
                        dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
                        dayCount: parseInt(moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")),
                        shiftMode: 'Second Shift',
                        weekNumberInMonth: (getWeekNumberInMonth(newFormattedDate) === 1 ? `${getWeekNumberInMonth(newFormattedDate)}st Week` :
                            getWeekNumberInMonth(newFormattedDate) === 2 ? `${getWeekNumberInMonth(newFormattedDate)}nd Week` :
                                getWeekNumberInMonth(newFormattedDate) === 3 ? `${getWeekNumberInMonth(newFormattedDate)}rd Week` :
                                    getWeekNumberInMonth(newFormattedDate) > 3 ? `${getWeekNumberInMonth(newFormattedDate)}th Week` : '')
                    }));
                }
            });

            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries).map(entry => JSON.parse(entry));

            function sortUserDates(dates) {
                return dates.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);
            const createdUserDates = sortedCreatedUserDates?.filter(d => {
                const filterData = userDates.some(val => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date) => {
                let filteredRowData = resultshiftallot?.filter((val) => val?._doc?.empcode == item?._doc?.empcode);
                const matchingItem = filteredRowData?.find(item => item && item?._doc?.adjdate == date.formattedDate);
                const matchingItemAllot = filteredRowData?.find(item => item && formatDate(item?._doc?.date) == date.formattedDate);
                const matchingDoubleShiftItem = filteredRowData?.find(item => item && item?._doc?.todate === date.formattedDate);
                const matchingRemovedItem = filteredRowData?.find(item => item?._doc?.removedshiftdate === date.formattedDate);
                const matchingAssignShiftItem = filteredRowData?.find(item => item?._doc?.adjdate === date.formattedDate && item?._doc?.adjstatus === 'Approved' && item?._doc?.adjustmenttype === 'Assign Shift');

                const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                    // return item;
                });

                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item?._doc?.weekoff?.includes(date.dayName);
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                const row = {
                    id: `${item?._doc?._id.toString()}_${date.formattedDate}_${date.shiftMode}`,
                    userid: item?._doc?._id.toString(),
                    company: item?._doc?.company,
                    branch: item?._doc?.branch,
                    unit: item?._doc?.unit,
                    team: item?._doc?.team,
                    doj: dojDate,
                    department: relevantDepLogEntry && relevantDepLogEntry?.department,
                    username: item?._doc?.companyname,
                    empcode: item?._doc?.empcode,
                    weekoff: item?._doc?.weekoff,
                    boardingLog: item?._doc?.boardingLog,
                    shiftallot: item?._doc?.shiftallot,
                    shift: getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                    date: `${date.formattedDate} ${date.dayName} ${date.dayCount}`,
                    role: item?._doc?.role,
                    rowformattedDate: date.formattedDate,
                    dayName: date.dayName,
                    shiftMode: date.shiftMode,
                    clockin: checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        date.shiftMode,
                    ),
                    clockout: checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        date.shiftMode,
                    ),
                    clockinstatus: checkClockInStatus(
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        graceTime, allLeaveStatus, holidays,
                        checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,), item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname,
                        earlyclockin, lateclockin, afterlateclockin, leavetype, permission,
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    clockoutstatus: checkClockOutStatus(
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        clockOutHours, checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        allLeaveStatus, holidays, item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname, onclockout,
                        earlyclockout, beforeearlyclockout,
                        checkGetClockInAutoStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        leavetype, permission, date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    attendanceautostatus: checkAttendanceStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    lateclockincount: lateclockincount,
                    earlyclockoutcount: earlyclockoutcount,
                    totalnumberofdays: getTotalMonthDaysUser(item?._doc?.department, depMonthSet, ismonth, isyear),
                    empshiftdays: getTotalMonthDaysForEmpUser(dojDate, item?._doc?.department, depMonthSet, ismonth, isyear),
                    totalcounttillcurrendate: getTotalMonthsCurrentDateCountUser(dojDate, item?._doc?.department, depMonthSet, ismonth, isyear),
                    totalshift: getTotalShiftHoursUser(item?._doc?._id.toString(), createdUserDates, attendance),
                    weekoffpresentstatus: checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                };

                return row;
            });

            return userRows;

        });

    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finaluser) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ finaluser });
});

//visitor scan

exports.getAllUsersVisitorRegister = catchAsyncErrors(async (req, res, next) => {
    let users;

    try {
        users = await User.find(
            {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
                resonablestatus: {
                    $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
                company: req.body.company,
                branch: req.body.branch,
            },

            { companyname: 1, unit: 1 }

        );
    } catch (err) {
        return next(new ErrorHandler("Data not found", 404));
    }

    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: users.length, users });
});

exports.getAllUserClockinAndClockoutStatusLoginCheck = catchAsyncErrors(async (req, res, next) => {
    let users;
    let depMonthSet;
    let shift;
    let finaluser = [];
    let finalresdata = [];
    // const { userDates } = req.body;
    const currDate = new Date();
    var today = new Date();
    var todayDate = new Date();
    var dd = String(today.getDate()).padStart(2, "0");
    var mm = String(today.getMonth() + 1).padStart(2, "0"); // January is 0!
    var yyyy = today.getFullYear();
    today = yyyy + "-" + mm + "-" + dd;
    var todayDateFormat = `${dd}/${mm}/${yyyy}`;

    // Get yesterday's date
    var yesterday = new Date(todayDate);
    yesterday.setDate(todayDate.getDate() - 1);
    var ddp = String(yesterday.getDate()).padStart(2, "0");
    var mmp = String(yesterday.getMonth() + 1).padStart(2, "0"); // January is 0!
    var yyyyp = yesterday.getFullYear();
    var yesterdayDate = yyyyp + "-" + mmp + "-" + ddp;
    var yesterdayDateFormat = `${ddp}/${mmp}/${yyyyp}`;

    let startMonthDate = new Date(yesterdayDate);
    let endMonthDate = new Date(today);
    const daysArray = [];

    while (startMonthDate <= endMonthDate) {
        const formattedDate = `${String(startMonthDate.getDate()).padStart(
            2,
            "0"
        )}/${String(startMonthDate.getMonth() + 1).padStart(
            2,
            "0"
        )}/${startMonthDate.getFullYear()}`;
        const dayName = startMonthDate.toLocaleDateString("en-US", {
            weekday: "long",
        });
        const dayCount = startMonthDate.getDate();
        const shiftMode = "Main Shift";

        daysArray.push({ formattedDate, dayName, dayCount, shiftMode });

        // Move to the next day
        startMonthDate.setDate(startMonthDate.getDate() + 1);
    }


    const userDates = daysArray;

    try {
        users = await User.find(
            {
                empcode: req.body.empcode,
                resonablestatus: {
                    $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
            }, {
            company: 1,
            branch: 1,
            unit: 1,
            team: 1,
            department: 1,
            doj: 1,
            empcode: 1,
            companyname: 1,
            team: 1,
            floor: 1,
            username: 1,
            designation: 1,
            weekoff: 1,
            shiftallot: 1,
            shifttiming: 1,
            boardingLog: 1, attendancemode: 1,
            departmentlog: 1,
        }
        );
        depMonthSet = await DepartmentMonth.find({}, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 });


        const beforefinaluser = users?.flatMap((item, index) => {

            const filteredMatchingDoubleShiftItem = item.shiftallot?.filter(val => val && val?._doc?.empcode === item?._doc?.empcode && val?._doc?.adjstatus === 'Approved');

            const dojDate = item?._doc?.boardingLog.length > 0 ?
                new Date(item?._doc?.boardingLog[0].startdate)
                : new Date(item?._doc?.doj);

            // Filter out the dates that have matching 'Shift Adjustment' todates
            let removedUserDates = userDates?.filter(date => {
                // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
                const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem.find(item => item && item?._doc?.todate === date.formattedDate && item?._doc?.adjustmenttype === 'Shift Adjustment');

                // If there is no matching 'Shift Adjustment', keep the date
                return !matchingShiftAdjustmentToDate;
            });
            // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
            let uniqueEntries = new Set();

            // Iterate over removedUserDates and add unique entries to the Set
            userDates?.forEach(date => {
                uniqueEntries.add(JSON.stringify({
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    shiftMode: 'Main Shift',
                    weekNumberInMonth: date.weekNumberInMonth
                }));
            });
            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach(item => {
                const [day, month, year] = item._doc.adjdate?.split('/')
                let newFormattedDate = new Date(`${year}-${month}-${day}`);

                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(JSON.stringify({
                        formattedDate: item._doc.adjdate,
                        dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
                        dayCount: parseInt(moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")),
                        shiftMode: 'Second Shift',
                        weekNumberInMonth: (getWeekNumberInMonth(newFormattedDate) === 1 ? `${getWeekNumberInMonth(newFormattedDate)}st Week` :
                            getWeekNumberInMonth(newFormattedDate) === 2 ? `${getWeekNumberInMonth(newFormattedDate)}nd Week` :
                                getWeekNumberInMonth(newFormattedDate) === 3 ? `${getWeekNumberInMonth(newFormattedDate)}rd Week` :
                                    getWeekNumberInMonth(newFormattedDate) > 3 ? `${getWeekNumberInMonth(newFormattedDate)}th Week` : '')
                    }));
                }
            });
            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries)?.map(entry => JSON.parse(entry));
            function sortUserDates(dates) {
                return dates?.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);
            const createdUserDates = sortedCreatedUserDates?.filter(d => {
                const filterData = userDates.some(val => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date) => {
                let filteredRowData = item.shiftallot?.filter((val) => val?._doc?.empcode == item?._doc?.empcode);
                const matchingItem = item.shiftallot?.find(item => item && item?._doc?.adjdate == date.formattedDate);
                const matchingItemAllot = item.shiftallot?.find(item => item && formatDate(item?._doc?.date) == date.formattedDate);
                const matchingDoubleShiftItem = item.shiftallot?.find(item => item && item?._doc?.todate === date.formattedDate);
                const matchingRemovedItem = filteredRowData?.find(item => item?._doc?.removedshiftdate === date.formattedDate);
                const matchingAssignShiftItem = filteredRowData?.find(item => item?._doc?.adjdate === date.formattedDate && item?._doc?.adjstatus === 'Approved' && item?._doc?.adjustmenttype === 'Assign Shift');

                const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                    // return item;
                });

                // Remove duplicate entries with the most recent entry
                const uniqueEntriesDep = {};
                item?._doc?.departmentlog?.forEach(entry => {
                    const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                    const key = entry.startdate;
                    if (!(key in uniqueEntriesDep)) {
                        uniqueEntriesDep[key] = entry;
                    }
                });

                const uniqueDepLog = Object.values(uniqueEntriesDep);
                const [columnDay, columnMonth, columnYear] = date.formattedDate?.split('/');
                const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

                // Find the relevant log entry for the given date     
                const relevantDepLogEntry = uniqueDepLog
                    .filter(log => log.startdate <= finalDate)
                    .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item?._doc?.weekoff?.includes(date.dayName);
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                const row = {
                    shift: getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                    doj: dojDate,
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    weekNumberInMonth: date.weekNumberInMonth,
                    shiftMode: date.shiftMode,
                    leavestatus: '',
                    shiftcount: '',
                };
                return row;
            });
            return userRows;

        });
        const checking = beforefinaluser?.findIndex(data => data?.shift === "Week Off")
        const dataPick = checking < 1 ? checking : checking - 1
        const dateFormatCheck = beforefinaluser[dataPick]?.formattedDate;
        const [start, end] = beforefinaluser[dataPick]?.shift?.split('to') || [];

        const getEndDateTime = (formattedDate, shift) => {
            const [start, end] = shift?.split('to') || [];

            if (formattedDate && start && end) {
                // Convert date from DD/MM/YYYY to YYYY/MM/DD
                const formattedDateISO = formattedDate.split('/').reverse().join('-');

                // Function to convert 12-hour time to 24-hour time
                const convertTo24HourFormat = (time) => {
                    let [hours, minutes] = time.slice(0, -2).split(':');
                    const period = time.slice(-2);
                    if (period.toUpperCase() === 'PM' && hours !== '12') {
                        hours = parseInt(hours, 10) + 12;
                    } else if (period.toUpperCase() === 'AM' && hours === '12') {
                        hours = '00';
                    }
                    return `${hours}:${minutes}:00`;
                };

                const start24Hour = convertTo24HourFormat(start);
                const end24Hour = convertTo24HourFormat(end);

                const startDate = new Date(`${formattedDateISO}T${start24Hour}`);
                const endDate = new Date(`${formattedDateISO}T${end24Hour}`);

                // Handle case where end time is past midnight
                if (endDate < startDate) {
                    endDate.setDate(endDate.getDate() + 1);
                }

                return endDate;
            }

            return null;
        };

        const shiftDetailsYes = beforefinaluser[dataPick]?.shift;

        const endDateYess = moment(getEndDateTime(dateFormatCheck, shiftDetailsYes)).format("DD/MM/YYYY");
        const handleWeekOffShift = (shiftDetails) => {
            let currentDate = new Date(getEndDateTime(dateFormatCheck, shiftDetailsYes));
            currentDate.setHours(currentDate.getHours() + 4);
            for (let i = 1; i < shiftDetails.length; i++) {
                const currentShift = shiftDetails[i];
                if (currentShift.shift === 'Week Off') {
                    const previousShift = shiftDetails[i - 1];
                    const endDatePreviousShift = getEndDateTime(previousShift.formattedDate, previousShift.shift);
                    const endDatePreviousShiftFormatted = moment(endDatePreviousShift).format('DD/MM/YYYY');

                    if (endDatePreviousShiftFormatted === currentShift.formattedDate
                        && (currentDate >= new Date())
                    ) {
                        currentShift.shift = previousShift?.shift;
                        return;
                    } else {
                        currentShift.shift = 'Week Off';
                        return;
                    }
                }
            }
        };

        handleWeekOffShift(beforefinaluser);

        finaluser = [...new Set(beforefinaluser)]


        if (finaluser[0]?.shift?.includes("Not Allotted")) {
            finalresdata = finaluser.map((data, i) => {
                return { ...data, shift: data.shift === "Not Allotted" ? finaluser[1]?.shift : data.shift }
            })

        }

    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finaluser) {
        return next(new ErrorHandler("Users not found", 400));
    }
    return res.status(200).json({ finaluser: finaluser[0]?.shift?.includes("Not Allotted") ? finalresdata : finaluser });
});
//log updates
//update any log
exports.updateAnyLogValues = catchAsyncErrors(async (req, res, next) => {
    const { logid, logname } = req.query;
    const updateFields = req.body;

    try {
        const query = {};
        query[`${logname}._id`] = logid;

        const updateObj = { $set: {} };
        for (const key in updateFields) {
            updateObj.$set[`${logname}.$.${key}`] = updateFields[key];
        }

        const uploaddata = await User.findOneAndUpdate(query, updateObj, {
            new: true,
        });

        if (uploaddata) {
            return res
                .status(200)
                .json({ message: "Updated successfully", succcess: true });
        } else {
            return next(new ErrorHandler("Something went wrong", 500));
        }
    } catch (err) {
        return next(new ErrorHandler("Internal Server Error", 500));
    }
});

//delete any log
exports.deleteAnyLog = catchAsyncErrors(async (req, res, next) => {
    const { logid, logname } = req.query;
    try {
        const query = {};
        query[`${logname}._id`] = logid;

        const update = {
            $pull: {
                [logname]: { _id: logid },
            },
        };

        const deletedata = await User.findOneAndUpdate(query, update, {
            new: true,
        });

        if (deletedata) {
            return res
                .status(200)
                .json({ message: "Deleted successfully", succcess: true });
        } else {
            return next(new ErrorHandler("Something went wrong", 500));
        }
    } catch (err) {
        return next(new ErrorHandler("Internal Server Error", 500));
    }
});
exports.deleteShiftAnyLog = catchAsyncErrors(async (req, res, next) => {
    const { logid, logname } = req.query;
    try {
        const query = {};
        query[`${logname}._id`] = logid;

        const update = {
            $pull: {
                [logname]: { _id: logid },
            },
        };

        const deletedata = await User.findOneAndUpdate(query, update, {
            new: true,
        });

        if (deletedata) {
            return res
                .status(200)
                .json({ message: "Deleted successfully", succcess: true });
        } else {
            return next(new ErrorHandler("Something went wrong", 500));
        }
    } catch (err) {
        return next(new ErrorHandler("Internal Server Error", 500));
    }
});
exports.getAllUserProductionDayShiftFilter = catchAsyncErrors(async (req, res, next) => {
    let users;
    let controlcriteria;
    let depMonthSet;
    let resultshiftallot = [];
    let finaluser = [];
    let query;
    const { userDates } = req.body;

    try {
        query = {
            company: { $in: req.body.company },
            branch: { $in: req.body.branch },
            unit: { $in: req.body.unit },
            team: { $in: req.body.team },
            companyname: { $in: req.body.empname },
            enquirystatus: { $nin: ['Enquiry Purpose'] },
            // resonablestatus: { $ne: "" }, // Include only when resonablestatus is not empty
            $or: [
                { reasondate: { $exists: false } }, // Include if reasondate doesn't exist
                { reasondate: '' }, // Include if reasondate doesn't exist
                { reasondate: { $gte: req.body.fromdate } }, // Include if reasondate is greater than or equal to fromdate
            ],
        };
        users = await User.find(query, {
            company: 1,
            branch: 1,
            unit: 1,
            reasondate: 1,
            team: 1,
            department: 1,
            doj: 1,
            empcode: 1,
            companyname: 1,
            team: 1,
            floor: 1,
            username: 1,
            designation: 1,
            weekoff: 1,
            shiftallot: 1,
            shifttiming: 1,
            boardingLog: 1,
            attendancemode: 1,
            reasondate: 1,
            departmentlog: 1,
        });
        controlcriteria = await ControlCriteria.find();
        depMonthSet = await DepartmentMonth.find({}, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 });

        const userCds = users.map((user) => user.companyname);
        allLeaveStatus = await ApplyLeave.find({ employeename: { $in: userCds } });

        finaluser = users?.flatMap((item, index) => {
            let isEmployeeGrace = controlcriteria[0].todos && controlcriteria[0].todos.find((d) => d.company === item.company && d.branch === item.branch && d.unit === item.unit && d.team === item.team && d.employeename === item.companyname);

            if (isEmployeeGrace) {
                graceTime = isEmployeeGrace.employeegracetime;
            } else {
                graceTime = controlcriteria[0].gracetime;
            }

            item.shiftallot?.map((allot) => {
                resultshiftallot.push({ ...allot });
            });

            const filteredMatchingDoubleShiftItem = resultshiftallot?.filter((val) => val && val?._doc?.empcode === item?._doc?.empcode && val?._doc?.adjstatus === 'Approved');
            const dojDate = item?._doc?.boardingLog.length > 0 ? new Date(item?._doc?.boardingLog[0].startdate) : new Date(item?._doc?.doj);

            // Filter out the dates that have matching 'Shift Adjustment' todates
            // let removedUserDates = userDates?.filter((date) => {
            //   // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
            //   const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem.find((item) => item && item?._doc?.todate === date.formattedDate && item?._doc?.adjustmenttype === 'Shift Adjustment');

            //   // If there is no matching 'Shift Adjustment', keep the date
            //   return !matchingShiftAdjustmentToDate;
            // });

            // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
            let uniqueEntries = new Set();

            // Iterate over removedUserDates and add unique entries to the Set
            userDates?.forEach((date) => {
                uniqueEntries.add(
                    JSON.stringify({
                        formattedDate: date.formattedDate,
                        dayName: date.dayName,
                        dayCount: date.dayCount,
                        shiftMode: 'Main Shift',
                        weekNumberInMonth: date.weekNumberInMonth,
                    })
                );
            });

            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach((item) => {
                const [day, month, year] = item._doc.adjdate?.split('/');
                let newFormattedDate = new Date(`${year}-${month}-${day}`);

                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(
                        JSON.stringify({
                            formattedDate: item._doc.adjdate,
                            dayName: moment(item._doc.adjdate, 'DD/MM/YYYY').format('dddd'),
                            dayCount: parseInt(moment(item._doc.adjdate, 'DD/MM/YYYY').format('DD')),
                            shiftMode: 'Second Shift',
                            weekNumberInMonth:
                                getWeekNumberInMonth(newFormattedDate) === 1
                                    ? `${getWeekNumberInMonth(newFormattedDate)}st Week`
                                    : getWeekNumberInMonth(newFormattedDate) === 2
                                        ? `${getWeekNumberInMonth(newFormattedDate)}nd Week`
                                        : getWeekNumberInMonth(newFormattedDate) === 3
                                            ? `${getWeekNumberInMonth(newFormattedDate)}rd Week`
                                            : getWeekNumberInMonth(newFormattedDate) > 3
                                                ? `${getWeekNumberInMonth(newFormattedDate)}th Week`
                                                : '',
                        })
                    );
                }
            });

            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries)?.map((entry) => JSON.parse(entry));

            function sortUserDates(dates) {
                return dates.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);

            const createdUserDates = sortedCreatedUserDates?.filter((d) => {
                const filterData = userDates.some((val) => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });

            const createdUserDatesNext = sortedCreatedUserDates?.filter((d) => {
                const filterData = userDates.some((val) => {
                    const [day, month, year] = val.formattedDate.split('/').map(Number);
                    const currdate = new Date(year, month - 1, day); // Month is 0-indexed in JavaScript

                    // Add one day
                    currdate.setDate(currdate.getDate() + 1);

                    // Format the new date as DD/MM/YYYY
                    const newDay = String(currdate.getDate()).padStart(2, '0');
                    const newMonth = String(currdate.getMonth() + 1).padStart(2, '0'); // Month is 0-indexed
                    const newYear = currdate.getFullYear();

                    const nextDateFormatted = `${newDay}/${newMonth}/${newYear}`;

                    return nextDateFormatted === d.formattedDate;
                });
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date, index) => {
                const nextdate = createdUserDates[index + 1];
                let filteredRowData = resultshiftallot?.filter((val) => val?._doc?.empcode == item?._doc?.empcode);
                const matchingItem = filteredRowData?.find((item) => item && item?._doc?.adjdate == date.formattedDate);
                const matchingItemAllot = filteredRowData?.find((item) => item && formatDate(item?._doc?.date) == date.formattedDate);
                const matchingDoubleShiftItem = filteredRowData?.find((item) => item && item?._doc?.todate === date.formattedDate);
                const matchingRemovedItem = filteredRowData?.find((item) => item.removedshiftdate === date.formattedDate);
                const matchingAssignShiftItem = filteredRowData?.find(item => item?._doc?.adjdate === date.formattedDate && item?._doc?.adjstatus === 'Approved' && item?._doc?.adjustmenttype === 'Assign Shift');

                const filterBoardingLog =
                    item?._doc?.boardingLog &&
                    item?._doc?.boardingLog?.filter((item) => {
                        return item.logcreation === 'user' || item.logcreation === 'shift';
                        // return item;
                    });

                // Remove duplicate entries with the most recent entry
                const uniqueEntriesDep = {};
                item?._doc?.departmentlog?.forEach((entry) => {
                    const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                    const key = entry.startdate;
                    if (!(key in uniqueEntriesDep)) {
                        uniqueEntriesDep[key] = entry;
                    }
                });

                const uniqueDepLog = Object.values(uniqueEntriesDep);
                const [columnDay, columnMonth, columnYear] = date.formattedDate?.split('/');
                const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

                // Find the relevant log entry for the given date
                const relevantDepLogEntry = uniqueDepLog.filter((log) => log.startdate <= finalDate).sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

                //Next Date
                const matchingItemNext = nextdate ? filteredRowData?.find((item) => item && item?._doc?.adjdate == nextdate.formattedDate) : '';
                const matchingItemAllotNext = nextdate ? filteredRowData?.find((item) => item && formatDate(item?._doc?.date) == nextdate.formattedDate) : '';
                const matchingDoubleShiftItemNext = nextdate ? filteredRowData?.find((item) => item && item?._doc?.todate === nextdate.formattedDate) : '';
                // const isWeekOffNext = nextdate ? item?._doc?.weekoff?.includes(nextdate.dayName) : "";
                const isWeekOffNext = nextdate ? (getWeekOffDay(date, filterBoardingLog, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet) === 'Week Off' ? true : false) : '';
                const isWeekOffWithAdjustmentNext = nextdate ? isWeekOffNext && matchingItem : '';
                const isWeekOffWithManualNext = nextdate ? isWeekOffNext && matchingItemAllot : '';

                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item?._doc?.weekoff?.includes(date.dayName);
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet) === 'Week Off' ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                const row = {
                    id: `${item?._doc?._id.toString()}_${date.formattedDate}_${date.shiftMode}`,
                    userid: item?._doc?._id.toString(),
                    company: item?._doc?.company,
                    branch: item?._doc?.branch,
                    unit: item?._doc?.unit,
                    team: item?._doc?.team,
                    doj: dojDate,
                    department: relevantDepLogEntry && relevantDepLogEntry?.department,
                    username: item?._doc?.companyname,
                    empcode: item?._doc?.empcode,
                    weekoff: item?._doc?.weekoff,
                    boardingLog: item?._doc?.boardingLog,
                    shiftallot: item?._doc?.shiftallot,
                    shift: getShiftForDateDayShift(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                    shifttiming: getShiftForDateDayShift(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                    nextshift: nextdate ? getShiftForDateDayShift(nextdate, matchingItemNext, matchingItemAllotNext, isWeekOffWithAdjustmentNext, isWeekOffWithManualNext, filterBoardingLog, isWeekOffNext, matchingDoubleShiftItemNext, item?._doc?.departmentlog, depMonthSet, matchingRemovedItem, matchingAssignShiftItem) : '',

                    date: `${date.formattedDate} ${date.dayName} ${date.dayCount}`,
                    rowformattedDate: date.formattedDate,
                    dayName: date.dayName,
                    shiftMode: date.shiftMode,
                    reasondate: item?._doc?.reasondate,
                };

                return row;
            });

            return userRows;
        });
        // finaluser;
        // .filter((item) => new Date(item.reasondate) <= new Date(req.body.fromdate));
    } catch (err) {
        return next(new ErrorHandler('Records not found!', 404));
    }

    if (!finaluser) {
        return next(new ErrorHandler('Users not found', 400));
    }

    return res.status(200).json({ finaluser });
});
// get All user => /api/users
exports.getAllUsersEmployee = catchAsyncErrors(async (req, res, next) => {
    let users;

    try {
        users = await User.find(
            {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
            },
            {
                company: 1,
                branch: 1,
                unit: 1,
                team: 1,
                companyname: 1,
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: users.length, users });
});

const calculateShiftWorkingHours = (shifttime) => {
    if (shifttime !== "Week Off" && shifttime !== "Not Allotted" && shifttime !== undefined && shifttime !== "undefined" && shifttime !== "") {
        // Parse start and end times
        const startTime = parseTime(shifttime?.split('to')[0]);
        const endTime = parseTime(shifttime?.split('to')[1]);
        let startTimeWithPM = shifttime?.split('to')[0];

        // Function to calculate hours, minutes, and seconds
        const calculateTimeDifference = (start, end) => {
            const diffInMs = end - start;
            const diffInHours = Math.floor(diffInMs / (1000 * 60 * 60));
            const diffInMinutes = Math.floor((diffInMs % (1000 * 60 * 60)) / (1000 * 60));
            const diffInSeconds = Math.floor((diffInMs % (1000 * 60)) / 1000);

            // Ensure two-digit formatting for hours, minutes, and seconds
            const formattedHours = String(diffInHours).padStart(2, "0");
            const formattedMinutes = String(diffInMinutes).padStart(2, "0");
            const formattedSeconds = String(diffInSeconds).padStart(2, "0");

            return `${formattedHours}:${formattedMinutes}:${formattedSeconds}`;
        };

        if (startTimeWithPM?.includes('PM')) {
            // Handle shifts that span midnight
            if (endTime < startTime) {
                endTime.setDate(endTime.getDate() + 1); // Move end time to the next day
            }

            // Return the formatted time difference with hours, minutes, and seconds
            return calculateTimeDifference(startTime, endTime);

        } else {
            // Return the formatted time difference with hours, minutes, and seconds
            return calculateTimeDifference(startTime, endTime);
        }
    } else {
        return "00:00:00";
    }
};

const calculateShiftBeforeOtHours = (shifttime, clockintime, isBeforeEnable, BeforeTime) => {
    if (shifttime !== "Week Off" && shifttime !== "Not Allotted" && shifttime !== undefined && shifttime !== "undefined" && shifttime !== "") {
        if (clockintime !== "00:00:00") {
            // Parse shift start time, clock-in time, and calculate compareBeforeTime
            const shiftStartTime = parseTime(shifttime?.split('to')[0]);
            const clockInTime = parseTime(clockintime);

            // Calculate the "before time" by subtracting BeforeTime (in minutes) from shiftStartTime
            const beforeTimeInMilliseconds = BeforeTime * 60000;
            const compareBeforeTime = new Date(shiftStartTime?.getTime() - beforeTimeInMilliseconds);

            // Check if before time feature is enabled
            if (isBeforeEnable) {
                // If clock-in time is before compareBeforeTime, calculate overtime
                if (clockInTime < compareBeforeTime) {
                    const overtimeInMs = compareBeforeTime - clockInTime;

                    // Convert milliseconds to hours, minutes, and seconds
                    const overtimeHours = Math.floor(overtimeInMs / (1000 * 60 * 60));
                    const overtimeMinutes = Math.floor((overtimeInMs % (1000 * 60 * 60)) / (1000 * 60));
                    const overtimeSeconds = Math.floor((overtimeInMs % (1000 * 60)) / 1000);

                    // Ensure two-digit formatting for hours, minutes, and seconds
                    const formattedOvertimeHours = String(overtimeHours).padStart(2, "0");
                    const formattedOvertimeMinutes = String(overtimeMinutes).padStart(2, "0");
                    const formattedOvertimeSeconds = String(overtimeSeconds).padStart(2, "0");

                    // Return overtime in HH:MM:SS format
                    return `${formattedOvertimeHours}:${formattedOvertimeMinutes}:${formattedOvertimeSeconds}`;
                } else {
                    return "00:00:00";
                }
            } else {
                return "00:00:00";
            }
        } else {
            return "00:00:00";
        }
    } else {
        return "00:00:00";
    }
};

const calculateShiftAfterOtHours = (shifttime, clockouttime, isAfterEnable, AfterTime) => {
    if (shifttime !== "Week Off" && shifttime !== "Not Allotted" && shifttime !== undefined && shifttime !== "undefined" && shifttime !== "") {
        if (clockouttime !== "00:00:00") {
            // Parse shift end time, clock-out time, and calculate compareAfterTime
            const shiftEndTime = parseTime(shifttime?.split('to')[1]);
            const clockOutTime = parseTime(clockouttime);

            // Calculate the "after time" by adding AfterTime (in minutes) to shiftEndTime
            const afterTimeInMilliseconds = AfterTime * 60000;
            const compareAfterTime = new Date(shiftEndTime?.getTime() + afterTimeInMilliseconds);

            // Check if after time feature is enabled
            if (isAfterEnable) {
                // If clock-out time is after compareAfterTime, calculate overtime
                if (clockOutTime > compareAfterTime) {
                    const overtimeInMs = clockOutTime - compareAfterTime;

                    // Convert milliseconds to hours, minutes, and seconds
                    const overtimeHours = Math.floor(overtimeInMs / (1000 * 60 * 60));
                    const overtimeMinutes = Math.floor((overtimeInMs % (1000 * 60 * 60)) / (1000 * 60));
                    const overtimeSeconds = Math.floor((overtimeInMs % (1000 * 60)) / 1000);

                    // Ensure two-digit formatting for hours, minutes, and seconds
                    const formattedOvertimeHours = String(overtimeHours).padStart(2, "0");
                    const formattedOvertimeMinutes = String(overtimeMinutes).padStart(2, "0");
                    const formattedOvertimeSeconds = String(overtimeSeconds).padStart(2, "0");

                    // Return overtime in HH:MM:SS format
                    return `${formattedOvertimeHours}:${formattedOvertimeMinutes}:${formattedOvertimeSeconds}`;
                } else {
                    return "00:00:00";
                }
            } else {
                return "00:00:00";
            }
        } else {
            return "00:00:00";
        }
    } else {
        return "00:00:00";
    }
};

const calculateTotalOtHours = (beforeOtTime, afterOtTime) => {
    // Function to convert HH:MM:SS format into total seconds
    const timeToSeconds = (timeStr) => {
        const [hours, minutes, seconds] = timeStr.split(":").map(Number);
        return hours * 3600 + minutes * 60 + (seconds || 0);
    };

    // Convert seconds back to HH:MM:SS format
    const secondsToTime = (totalSeconds) => {
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;
        return `${String(hours).padStart(2, "0")}:${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}`;
    };

    // Convert both times to total seconds
    const beforeSeconds = timeToSeconds(beforeOtTime);
    const afterSeconds = timeToSeconds(afterOtTime);

    // Sum the seconds
    const totalSeconds = beforeSeconds + afterSeconds;

    // Convert total seconds back to HH:MM:SS format
    return secondsToTime(totalSeconds);
};

const calculateAfterShiftShortHours = (shifttime, clockintime) => {
    if (shifttime !== "Week Off" && shifttime !== "Not Allotted" && shifttime !== undefined && shifttime !== "undefined" && shifttime !== "" && clockintime !== "00:00:00") {
        // Parse shift start time and clock-in time
        const shiftStartTime = parseTime(shifttime.split('to')[0].trim());
        const clockInTime = parseTime(clockintime);

        // If the user clocked in after the shift start time, calculate short time
        if (clockInTime > shiftStartTime) {
            const shortTimeInMs = clockInTime - shiftStartTime;

            // Convert milliseconds to hours, minutes, and seconds
            const shortHours = Math.floor(shortTimeInMs / (1000 * 60 * 60));
            const shortMinutes = Math.floor((shortTimeInMs % (1000 * 60 * 60)) / (1000 * 60));
            const shortSeconds = Math.floor((shortTimeInMs % (1000 * 60)) / 1000);

            // Ensure two-digit formatting for hours, minutes, and seconds
            const formattedHours = String(shortHours).padStart(2, "0");
            const formattedMinutes = String(shortMinutes).padStart(2, "0");
            const formattedSeconds = String(shortSeconds).padStart(2, "0");

            // Return short time in HH:MM:SS format
            return `${formattedHours}:${formattedMinutes}:${formattedSeconds}`;
        } else {
            return "00:00:00";
        }
    } else {
        return "00:00:00";
    }
};


const calculateBeforeShiftShortHours = (shifttime, clockouttime) => {
    if (shifttime !== "Week Off" && shifttime !== "Not Allotted" && shifttime && shifttime !== "undefined" && clockouttime !== "00:00:00") {
        const startTime = parseTime(shifttime?.split('to')[0].trim());
        let shiftEndTime = parseTime(shifttime?.split('to')[1].trim());
        let clockOutTime = parseTime(clockouttime);
        const startTimePeriod = shifttime?.split('to')[0].includes('PM') ? "PM" : "AM";

        // Adjust dates based on shift type and clockout time
        if (startTimePeriod === "AM" && clockouttime.includes("AM")) {
            // Day shift: Start AM, ClockOut AM -> Add 1 day to ClockOut
            clockOutTime.setDate(clockOutTime.getDate() + 1);
        } else if (startTimePeriod === "PM" && clockouttime.includes("AM")) {
            // Night shift: Start PM, ClockOut AM -> Add 1 day to ClockOut
            clockOutTime.setDate(clockOutTime.getDate() + 1);
        } else if (startTimePeriod === "PM" && clockouttime.includes("PM") && shiftEndTime < startTime) {
            // Night shift: Start PM, ClockOut PM but shift crosses midnight
            shiftEndTime.setDate(shiftEndTime.getDate() + 1);
        }
        // Check if clock out was before shift end
        if (clockOutTime < shiftEndTime) {
            const shortTimeInMs = shiftEndTime - clockOutTime;

            const shortHours = Math.floor(shortTimeInMs / (1000 * 60 * 60));
            const shortMinutes = Math.floor((shortTimeInMs % (1000 * 60 * 60)) / (1000 * 60));
            const shortSeconds = Math.floor((shortTimeInMs % (1000 * 60)) / 1000);

            const formattedHours = String(shortHours).padStart(2, "0");
            const formattedMinutes = String(shortMinutes).padStart(2, "0");
            const formattedSeconds = String(shortSeconds).padStart(2, "0");

            return `${formattedHours}:${formattedMinutes}:${formattedSeconds}`;
        } else {
            return "00:00:00";
        }
    } else {
        return "00:00:00";
    }
};
const calculateTotalShortHours = (shiftAfterShortTime, shiftBeforeShortTime) => {
    // Function to convert HH:MM:SS format into total seconds
    const timeToSeconds = (timeStr) => {
        const [hours, minutes, seconds] = timeStr.split(":").map(Number);
        return hours * 3600 + minutes * 60 + (seconds || 0);
    };

    // Convert seconds back to HH:MM:SS format
    const secondsToTime = (totalSeconds) => {
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;
        return `${String(hours).padStart(2, "0")}:${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}`;
    };

    // Convert both times to total seconds
    const afterSeconds = timeToSeconds(shiftAfterShortTime);
    const beforeSeconds = timeToSeconds(shiftBeforeShortTime);

    // Sum the seconds
    const totalSeconds = afterSeconds + beforeSeconds;

    // Convert total seconds back to HH:MM:SS format
    return secondsToTime(totalSeconds);
};


exports.getAllUserProductionDayShiftAttendanceFilter = catchAsyncErrors(async (req, res, next) => {
    let finaluser = [];
    let enableOtBefore;
    let enableOtAfter;
    let enableOtBeforeValue;
    let enableOtAfterValue;
    const { userDates, employee } = req.body;

    const formattedUserDates = userDates.map((data) => moment(data.formattedDate, "DD/MM/YYYY").format("DD-MM-YYYY"));

    let query = {
        companyname: { $in: employee },
        enquirystatus: {
            $nin: ["Enquiry Purpose"],
        },
    };

    try {
        const [users, controlcriteria, depMonthSets, attendances,] = await Promise.all([
            User.find(query,
                {
                    company: 1,
                    branch: 1,
                    unit: 1,
                    team: 1,
                    department: 1,
                    doj: 1,
                    empcode: 1,
                    companyname: 1,
                    team: 1,
                    floor: 1,
                    username: 1,
                    designation: 1,
                    weekoff: 1,
                    shiftallot: 1,
                    shifttiming: 1,
                    boardingLog: 1,
                    attendancemode: 1,
                    reasondate: 1,
                    departmentlog: 1,
                    designationlog: 1,
                }
            ),
            ControlCriteria.find(),
            DepartmentMonth.find({}, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 }),
            Attendance.find({ date: { $in: formattedUserDates }, }),
        ])
        const userCds = users.map(user => user.companyname);
        allLeaveStatus = await ApplyLeave.find({ employeename: { $in: userCds } });

        finaluser = users?.flatMap((item, index) => {

            let isEmployeeOtHours = controlcriteria[0].todos && controlcriteria[0].othourstodos.find(d => d.company === item.company &&
                d.branch === item.branch && d.unit === item.unit && d.team === item.team &&
                d.employeename === item.companyname
            )

            if (isEmployeeOtHours) {
                enableOtBefore = isEmployeeOtHours.enableshiftbeforeothours
                enableOtAfter = isEmployeeOtHours.enableshitafterothours
                enableOtBeforeValue = isEmployeeOtHours.enableshiftbeforeothoursvalue
                enableOtAfterValue = isEmployeeOtHours.enableshitafterothoursvalue
            } else {
                enableOtBefore = controlcriteria[0].enableshiftbeforeothours
                enableOtAfter = controlcriteria[0].enableshitafterothours
                enableOtBeforeValue = controlcriteria[0].enableshiftbeforeothoursvalue
                enableOtAfterValue = controlcriteria[0].enableshitafterothoursvalue
            }

            const filteredMatchingDoubleShiftItem = item.shiftallot?.filter(val => val && val?._doc?.empcode === item?._doc?.empcode && val?._doc?.adjstatus === 'Approved');
            const dojDate = item?._doc?.boardingLog.length > 0 ?
                item?._doc?.boardingLog[0].startdate
                : item?._doc?.doj;

            // Filter out the dates that have matching 'Shift Adjustment' todates
            let removedUserDates = userDates?.filter(date => {
                // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
                const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem.find(item => item && item?._doc?.todate === date.formattedDate && item?._doc?.adjustmenttype === 'Shift Adjustment');

                // If there is no matching 'Shift Adjustment', keep the date
                return !matchingShiftAdjustmentToDate;
            });

            // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
            let uniqueEntries = new Set();

            // Iterate over removedUserDates and add unique entries to the Set
            userDates.forEach(date => {
                uniqueEntries.add(JSON.stringify({
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    shiftMode: 'Main Shift',
                    weekNumberInMonth: date.weekNumberInMonth
                }));
            });

            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach(item => {
                const [day, month, year] = item._doc.adjdate?.split('/')
                let newFormattedDate = new Date(`${year}-${month}-${day}`);

                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(JSON.stringify({
                        formattedDate: item._doc.adjdate,
                        dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
                        dayCount: parseInt(moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")),
                        shiftMode: 'Second Shift',
                        weekNumberInMonth: (getWeekNumberInMonth(newFormattedDate) === 1 ? `${getWeekNumberInMonth(newFormattedDate)}st Week` :
                            getWeekNumberInMonth(newFormattedDate) === 2 ? `${getWeekNumberInMonth(newFormattedDate)}nd Week` :
                                getWeekNumberInMonth(newFormattedDate) === 3 ? `${getWeekNumberInMonth(newFormattedDate)}rd Week` :
                                    getWeekNumberInMonth(newFormattedDate) > 3 ? `${getWeekNumberInMonth(newFormattedDate)}th Week` : '')
                    }));
                }
            });

            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries)?.map(entry => JSON.parse(entry));

            function sortUserDates(dates) {
                return dates.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);

            const createdUserDates = sortedCreatedUserDates?.filter(d => {
                const filterData = userDates.some(val => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date, index) => {
                const nextdate = createdUserDates[index + 1]
                let filteredRowData = item?._doc?.shiftallot?.filter((val) => val?._doc?.empcode == item?._doc?.empcode);
                const matchingItem = filteredRowData?.find(item => item && item?._doc?.adjdate == date.formattedDate);
                const matchingItemAllot = filteredRowData?.find(item => item && formatDate(item?._doc?.date) == date.formattedDate);
                const matchingDoubleShiftItem = filteredRowData?.find(item => item && item?._doc?.todate === date.formattedDate);
                const matchingRemovedItem = filteredRowData?.find(item => item?._doc?.removedshiftdate === date.formattedDate);
                const matchingAssignShiftItem = filteredRowData?.find(item => item?._doc?.adjdate === date.formattedDate && item?._doc?.adjstatus === 'Approved' && item?._doc?.adjustmenttype === 'Assign Shift');

                const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                    // return item;
                });

                // Remove duplicate entries with the most recent entry
                const uniqueEntriesDep = {};
                item?._doc?.departmentlog?.forEach(entry => {
                    const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                    const key = entry.startdate;
                    if (!(key in uniqueEntriesDep)) {
                        uniqueEntriesDep[key] = entry;
                    }
                });

                const uniqueDepLog = Object.values(uniqueEntriesDep);
                const [columnDay, columnMonth, columnYear] = date.formattedDate?.split('/');
                const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

                // Find the relevant log entry for the given date     
                const relevantDepLogEntry = uniqueDepLog
                    .filter(log => log.startdate <= finalDate)
                    .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

                const depMonthSet = depMonthSets.filter(d => d.department === (relevantDepLogEntry && relevantDepLogEntry?.department))
                const attendance = attendances.filter(d => d.username === item?._doc?.username)

                //Next Date
                const matchingItemNext = nextdate ? filteredRowData?.find(item => item && item?._doc?.adjdate == nextdate.formattedDate) : "";
                const matchingItemAllotNext = nextdate ? filteredRowData?.find(item => item && formatDate(item?._doc?.date) == nextdate.formattedDate) : "";
                const matchingDoubleShiftItemNext = nextdate ? filteredRowData?.find(item => item && item?._doc?.todate === nextdate.formattedDate) : "";
                // const isWeekOffNext = nextdate ? item?._doc?.weekoff?.includes(nextdate.dayName) : "";
                const isWeekOffNext = nextdate ? (getWeekOffDay(date, filterBoardingLog, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet) === "Week Off" ? true : false) : "";
                const isWeekOffWithAdjustmentNext = nextdate ? isWeekOffNext && matchingItem : "";
                const isWeekOffWithManualNext = nextdate ? isWeekOffNext && matchingItemAllot : "";

                // Check if the dayName is Sunday or Monday
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                const row = {
                    id: `${item?._doc?._id.toString()}_${date.formattedDate}_${date.shiftMode}`,
                    userid: item?._doc?._id.toString(),
                    company: item?._doc?.company,
                    branch: item?._doc?.branch,
                    unit: item?._doc?.unit,
                    team: item?._doc?.team,
                    department: (relevantDepLogEntry && relevantDepLogEntry?.department),
                    username: item?._doc?.companyname,
                    empcode: item?._doc?.empcode,
                    weekoff: item?._doc?.weekoff,
                    boardingLog: item?._doc?.boardingLog,
                    shiftallot: item?._doc?.shiftallot,
                    reasondate: item?._doc?.reasondate,
                    doj: dojDate,
                    shift: getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                    nextshift: nextdate ? getShiftForDate(nextdate, matchingItemNext, matchingItemAllotNext, isWeekOffWithAdjustmentNext, isWeekOffWithManualNext, filterBoardingLog, isWeekOffNext, matchingDoubleShiftItemNext, item?._doc?.departmentlog, depMonthSet) : "",

                    date: `${date.formattedDate} ${date.dayName} ${date.dayCount}`,
                    rowformattedDate: date.formattedDate,
                    dayName: date.dayName,
                    shiftMode: date.shiftMode,
                    clockin: checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        date.shiftMode,
                    ),
                    clockout: checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        date.shiftMode,
                    ),
                    shiftworkinghours: calculateShiftWorkingHours(getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem)),
                    shiftbeforeothours: calculateShiftBeforeOtHours(
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                            getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                            date.shiftMode,),
                        enableOtBefore, enableOtBeforeValue
                    ),
                    shiftafterothours: calculateShiftAfterOtHours(
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                            getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                            date.shiftMode,
                        ),
                        enableOtAfter, enableOtAfterValue
                    ),
                    totalothours: calculateTotalOtHours(
                        calculateShiftBeforeOtHours(
                            getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                            checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                                getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                                date.shiftMode,),
                            enableOtBefore, enableOtBeforeValue
                        ),
                        calculateShiftAfterOtHours(
                            getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                            checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                                getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                                date.shiftMode,
                            ),
                            enableOtAfter, enableOtAfterValue
                        ),
                    ),
                    shiftbeforeshorthours: calculateAfterShiftShortHours(
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                            getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                            date.shiftMode,),
                    ),
                    shiftaftershorthours: calculateBeforeShiftShortHours(
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                            getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                            date.shiftMode,
                        ),
                    ),
                    totalshorthours: calculateTotalShortHours(
                        calculateAfterShiftShortHours(
                            getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                            checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                                getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                                date.shiftMode,),
                        ),
                        calculateBeforeShiftShortHours(
                            getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                            checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                                getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                                date.shiftMode,
                            ),
                        ),
                    )
                };
                return row;
            });
            return userRows;
        });
        // finaluser.filter(item => new Date(item.reasondate) <= new Date(req.body.fromdate))
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finaluser) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ finaluser });
});

exports.getAllUserstatusDepCheck = catchAsyncErrors(async (req, res, next) => {
    let usersstatus;

    try {
        usersstatus = await User.find(
            { department: req?.body?.department },
            {

                resonablestatus: 1,
                department: 1,
                company: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                username: 1,
                usernameautogenerate: 1,

                email: 1,
                unit: 1,
                branch: 1,
                department: 1,
                username: 1,
                designation: 1,
                team: 1,
                role: 1,

                legalname: 1,
                callingname: 1,


                workstation: 1,
                area: 1,
                firstname: 1,
                lastname: 1

            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!usersstatus) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: usersstatus.length, usersstatus });
});



exports.getAllUserLoginStatusAction = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {

        users = await User.find(
            {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
                resonablestatus: {
                    $in: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
            },
            {
                empcode: 1,
                companyname: 1,
                username: 1,
                branch: 1,
                unit: 1,
                designation: 1,
                team: 1,
                department: 1,
                company: 1,
                extratime: 1,
                extrastatus: 1,
                extradate: 1,
                loginUserStatus: 1, wfhcount: 1, wfhstatus: 1
            }
        );
    } catch (err) {
        return next(new ErrorHandler("User not found!", 404));
    }
    if (!users) {
        return next(new ErrorHandler("User not found!", 404));
    }
    return res.status(200).json({
        users,
    });
});



exports.getAllUserLoginExpStatus = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {

        users = await User.aggregate([
            {
                $match: {
                    enquirystatus: {
                        $nin: ["Enquiry Purpose"]
                    },
                    resonablestatus: {
                        $nin: [
                            "Not Joined",
                            "Postponed",
                            "Rejected",
                            "Closed",
                            "Releave Employee",
                            "Absconded",
                            "Hold",
                            "Terminate"
                        ]
                    },
                    extratimestatus: {
                        $in: [
                            "onetime-used",
                            "manual-used",
                            "permanent-used"
                        ]
                    }
                }
            },
            {
                $lookup: {
                    from: "individualsettings",
                    localField: "companyname",
                    foreignField: "companyname",
                    as: "result"
                }
            },
            {
                $project: {
                    companyname: 1,
                    _id: 1,
                    empcode: 1,
                    companyname: 1,
                    username: 1,
                    branch: 1,
                    unit: 1,
                    designation: 1,
                    team: 1,
                    department: 1,
                    company: 1,
                    extratime: 1,
                    extrastatus: 1,
                    extratimestatus: 1,
                    extradate: 1,
                    loginUserStatus: 1,
                    extraTimeStatus: 1,
                    loginapprestriction: {
                        $cond: {
                            if: { $gt: [{ $size: "$result" }, 0] },
                            then: {
                                $arrayElemAt: [
                                    "$result.loginapprestriction",
                                    0
                                ]
                            },
                            else: null
                        }
                    }
                }
            },
            {
                $lookup: {
                    from: "adminoverallsettings",
                    pipeline: [
                        { $match: {} },
                        {
                            $project: {
                                loginapprestriction: 1,
                                _id: 1,
                                empcode: 1,
                                companyname: 1,
                                username: 1,
                                branch: 1,
                                unit: 1,
                                designation: 1,
                                team: 1,
                                department: 1,
                                company: 1,
                                extratime: 1,
                                extrastatus: 1,
                                extratimestatus: 1,
                                extradate: 1,
                                loginUserStatus: 1,
                                extraTimeStatus: 1
                            }
                        }
                    ],
                    as: "adminResult"
                }
            },
            {
                $addFields: {
                    loginapprestriction: {
                        $cond: {
                            if: {
                                $eq: ["$loginapprestriction", null]
                            },
                            then: {
                                $arrayElemAt: [
                                    "$adminResult.loginapprestriction",
                                    0
                                ]
                            },
                            else: "$loginapprestriction"
                        }
                    }
                }
            },
            {
                $project: {
                    _id: 1,
                    empcode: 1,
                    companyname: 1,
                    username: 1,
                    branch: 1,
                    unit: 1,
                    designation: 1,
                    team: 1,
                    department: 1,
                    company: 1,
                    extratime: 1,
                    extrastatus: 1,
                    extratimestatus: 1,
                    extradate: 1,
                    loginUserStatus: 1,
                    extraTimeStatus: 1,
                    loginapprestriction: 1
                }
            }
        ]);

    } catch (err) {
        return next(new ErrorHandler("User not found!", 404));
    }
    // if (!users) {
    //     return next(new ErrorHandler("User not found!", 404));
    // }
    return res.status(200).json({
        users,
    });
});


exports.getAllProfileImage = catchAsyncErrors(async (req, res, next) => {
    let allusers;

    try {
        allusers = await User.aggregate([
            {
                $match: {
                    enquirystatus: { $nin: ["Enquiry Purpose"] },
                    resonablestatus: {
                        $nin: [
                            "Not Joined",
                            "Postponed",
                            "Rejected",
                            "Closed",
                            "Releave Employee",
                            "Absconded",
                            "Hold",
                            "Terminate",
                        ],
                    },
                },
            },
            {
                $addFields: {
                    userIdStr: { $toString: "$_id" }, // Convert the ObjectId to string
                },
            },
            {
                $lookup: {
                    from: "employeedocuments",
                    localField: "userIdStr", // Use the string version of _id
                    foreignField: "commonid", // Match against the string commonid
                    as: "profileimage",
                },
            },
            {
                $addFields: {
                    profileimage: {
                        $ifNull: [{ $arrayElemAt: ["$profileimage.profileimage", 0] }, ""],
                    },
                },
            },
            {
                $project: {
                    empcode: 1,
                    companyname: 1,
                    email: 1,
                    contactfamily: 1,
                    contactpersonal: 1,
                    emergencyno: 1,
                    profileimage: 1,
                },
            },
        ]);
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!allusers) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: allusers.length, allusers });
});

// exports.getAllUserClockinAndClockoutStatusCheckLogin = catchAsyncErrors(async (req, res, next) => {
//     let users;
//     let depMonthSet;
//     let finaluser = [];
//     let finalresdata = [];

//     const { userDates } = req.body;

//     try {
//         users = await User.find(
//             {
//                 empcode: req.body.empcode,
//                 resonablestatus: {
//                     $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
//                 },
//             }, {
//             company: 1,
//             branch: 1,
//             unit: 1,
//             team: 1,
//             department: 1,
//             doj: 1,
//             empcode: 1,
//             companyname: 1,
//             team: 1,
//             floor: 1,
//             username: 1,
//             designation: 1,
//             weekoff: 1,
//             shiftallot: 1,
//             shifttiming: 1,
//             boardingLog: 1, attendancemode: 1,
//             departmentlog: 1,
//         }
//         );
//         depMonthSet = await DepartmentMonth.find({}, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 });

//         const beforefinaluser = users?.flatMap((item, index) => {

//             const filteredMatchingDoubleShiftItem = item.shiftallot?.filter(val => val && val?._doc?.empcode === item?._doc?.empcode && val?._doc?.adjstatus === 'Approved');
//             const dojDate = item?._doc?.boardingLog.length > 0 ?
//                 new Date(item?._doc?.boardingLog[0].startdate)
//                 : new Date(item?._doc?.doj);
//             // Filter out the dates that have matching 'Shift Adjustment' todates
//             let removedUserDates = userDates?.filter(date => {
//                 // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
//                 const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem.find(item => item && item?._doc?.todate === date.formattedDate && item?._doc?.adjustmenttype === 'Shift Adjustment');

//                 // If there is no matching 'Shift Adjustment', keep the date
//                 return !matchingShiftAdjustmentToDate;
//             });

//             // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
//             let uniqueEntries = new Set();

//             // Iterate over removedUserDates and add unique entries to the Set
//             userDates?.forEach(date => {
//                 uniqueEntries.add(JSON.stringify({
//                     formattedDate: date.formattedDate,
//                     dayName: date.dayName,
//                     dayCount: date.dayCount,
//                     shiftMode: 'Main Shift',
//                     weekNumberInMonth: date.weekNumberInMonth
//                 }));
//             });

//             // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
//             filteredMatchingDoubleShiftItem.forEach(item => {
//                 const [day, month, year] = item._doc.adjdate?.split('/')
//                 let newFormattedDate = new Date(`${year}-${month}-${day}`);

//                 if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
//                     uniqueEntries.add(JSON.stringify({
//                         formattedDate: item._doc.adjdate,
//                         dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
//                         dayCount: parseInt(moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")),
//                         shiftMode: 'Second Shift',
//                         weekNumberInMonth: (getWeekNumberInMonth(newFormattedDate) === 1 ? `${getWeekNumberInMonth(newFormattedDate)}st Week` :
//                             getWeekNumberInMonth(newFormattedDate) === 2 ? `${getWeekNumberInMonth(newFormattedDate)}nd Week` :
//                                 getWeekNumberInMonth(newFormattedDate) === 3 ? `${getWeekNumberInMonth(newFormattedDate)}rd Week` :
//                                     getWeekNumberInMonth(newFormattedDate) > 3 ? `${getWeekNumberInMonth(newFormattedDate)}th Week` : '')
//                     }));
//                 }
//             });

//             // Convert Set back to an array of objects
//             let createdUserDatesUnique = Array.from(uniqueEntries)?.map(entry => JSON.parse(entry));

//             function sortUserDates(dates) {
//                 return dates.sort((a, b) => {
//                     if (a.formattedDate === b.formattedDate) {
//                         // If dates are the same, sort by shift mode
//                         if (a.shiftMode < b.shiftMode) return -1;
//                         if (a.shiftMode > b.shiftMode) return 1;
//                         return 0;
//                     } else {
//                         // Otherwise, sort by date
//                         const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
//                         const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
//                         return dateA - dateB;
//                     }
//                 });
//             }

//             // Sort the array
//             const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);
//             const createdUserDates = sortedCreatedUserDates?.filter(d => {
//                 const filterData = userDates.some(val => val.formattedDate === d.formattedDate);
//                 if (filterData) {
//                     return d;
//                 }
//             });

//             // Map each user date to a row
//             const userRows = createdUserDates?.map((date) => {

//                 const matchingItem = item.shiftallot?.find(item => item && item?._doc?.adjdate == date.formattedDate);
//                 const matchingItemAllot = item.shiftallot?.find(item => item && formatDate(item?._doc?.date) == date.formattedDate);
//                 const matchingDoubleShiftItem = item.shiftallot?.find(item => item && item?._doc?.todate === date.formattedDate);
//                 const matchingRemovedItem = item.shiftallot?.find(item => item?._doc?.removedshiftdate === date.formattedDate);
//                 const matchingAssignShiftItem = item.shiftallot?.find(item => item?._doc?.adjdate === date.formattedDate && item?._doc?.adjstatus === 'Approved' && item?._doc?.adjustmenttype === 'Assign Shift');

//                 const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
//                     return item.logcreation === "user" || item.logcreation === "shift";
//                     // return item;
//                 });

//                 // Remove duplicate entries with the most recent entry
//                 const uniqueEntriesDep = {};
//                 item?._doc?.departmentlog?.forEach(entry => {
//                     const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
//                     const key = entry.startdate;
//                     if (!(key in uniqueEntriesDep)) {
//                         uniqueEntriesDep[key] = entry;
//                     }
//                 });

//                 const uniqueDepLog = Object.values(uniqueEntriesDep);
//                 const [columnDay, columnMonth, columnYear] = date.formattedDate?.split('/');
//                 const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

//                 // Find the relevant log entry for the given date     
//                 const relevantDepLogEntry = uniqueDepLog
//                     .filter(log => log.startdate <= finalDate)
//                     .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

//                 // Check if the dayName is Sunday or Monday
//                 // const isWeekOff = item?._doc?.weekoff?.includes(date.dayName);
//                 const isWeekOff = getWeekOffDay(date, filterBoardingLog, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet) === "Week Off" ? true : false;
//                 const isWeekOffWithAdjustment = isWeekOff && matchingItem;
//                 const isWeekOffWithManual = isWeekOff && matchingItemAllot;

//                 const row = {
//                     shift: getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
//                     formattedDate: date.formattedDate,
//                     doj: dojDate,
//                     dayName: date.dayName,
//                     dayCount: date.dayCount,
//                     weekNumberInMonth: date.weekNumberInMonth,
//                     shiftMode: date.shiftMode,
//                     leavestatus: '',
//                     shiftcount: '',
//                 };
//                 return row;
//             });
//             return userRows;
//         });
//         finaluser = [...new Set(beforefinaluser)]

//         if (finaluser[0]?.shift?.includes("Not Allotted")) {
//             finalresdata = finaluser.map((data, i) => {
//                 return { ...data, shift: data.shift === "Not Allotted" ? finaluser[1]?.shift : data.shift }
//             })

//         }

//     } catch (err) {
//         return next(new ErrorHandler("Records not found!", 404));
//     }

//     if (!finaluser) {
//         return next(new ErrorHandler("Users not found", 400));
//     }
//     return res.status(200).json({ finaluser: finaluser[0]?.shift?.includes("Not Allotted") ? finalresdata : finaluser });
// });


exports.getAllUserClockinAndClockoutStatusCheckLogin = catchAsyncErrors(async (req, res, next) => {
    let users;
    let depMonthSet;
    let shift;
    let finaluser = [];

    const { userDates } = req.body;

    try {
        users = await User.find(
            {
                empcode: req.body.empcode,
                resonablestatus: {
                    $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
            }, {
            company: 1,
            branch: 1,
            unit: 1,
            team: 1,
            department: 1,
            doj: 1,
            empcode: 1,
            companyname: 1,
            team: 1,
            floor: 1,
            username: 1,
            designation: 1,
            weekoff: 1,
            shiftallot: 1,
            shifttiming: 1,
            boardingLog: 1, attendancemode: 1,
            departmentlog: 1,
        }
        );
        depMonthSet = await DepartmentMonth.find({}, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 });
        shift = await Shift.find({}, { name: 1, fromhour: 1, tohour: 1, frommin: 1, tomin: 1, fromtime: 1, totime: 1 });

        const beforefinaluser = users?.flatMap((item, index) => {

            const filteredMatchingDoubleShiftItem = item.shiftallot?.filter(val => val && val?._doc?.empcode === item?._doc?.empcode && val?._doc?.adjstatus === 'Approved');
            const dojDate = item?._doc?.boardingLog.length > 0 ?
                new Date(item?._doc?.boardingLog[0].startdate)
                : new Date(item?._doc?.doj);
            // Filter out the dates that have matching 'Shift Adjustment' todates
            let removedUserDates = userDates?.filter(date => {
                // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
                const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem.find(item => item && item?._doc?.todate === date.formattedDate && item?._doc?.adjustmenttype === 'Shift Adjustment');

                // If there is no matching 'Shift Adjustment', keep the date
                return !matchingShiftAdjustmentToDate;
            });

            // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
            let uniqueEntries = new Set();

            // Iterate over removedUserDates and add unique entries to the Set
            removedUserDates?.forEach(date => {
                uniqueEntries.add(JSON.stringify({
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    shiftMode: 'Main Shift',
                    weekNumberInMonth: date.weekNumberInMonth
                }));
            });

            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach(item => {
                const [day, month, year] = item._doc.adjdate?.split('/')
                let newFormattedDate = new Date(`${year}-${month}-${day}`);

                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(JSON.stringify({
                        formattedDate: item._doc.adjdate,
                        dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
                        dayCount: parseInt(moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")),
                        shiftMode: 'Second Shift',
                        weekNumberInMonth: (getWeekNumberInMonth(newFormattedDate) === 1 ? `${getWeekNumberInMonth(newFormattedDate)}st Week` :
                            getWeekNumberInMonth(newFormattedDate) === 2 ? `${getWeekNumberInMonth(newFormattedDate)}nd Week` :
                                getWeekNumberInMonth(newFormattedDate) === 3 ? `${getWeekNumberInMonth(newFormattedDate)}rd Week` :
                                    getWeekNumberInMonth(newFormattedDate) > 3 ? `${getWeekNumberInMonth(newFormattedDate)}th Week` : '')
                    }));
                }
            });

            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries)?.map(entry => JSON.parse(entry));

            function sortUserDates(dates) {
                return dates.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);
            const createdUserDates = sortedCreatedUserDates?.filter(d => {
                const filterData = userDates.some(val => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date) => {

                const matchingItem = item.shiftallot?.find(item => item && item?._doc?.adjdate == date.formattedDate);
                const matchingItemAllot = item.shiftallot?.find(item => item && formatDate(item?._doc?.date) == date.formattedDate);
                const matchingDoubleShiftItem = item.shiftallot?.find(item => item && item?._doc?.todate === date.formattedDate);
                const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                    // return item;
                });

                // Remove duplicate entries with the most recent entry
                const uniqueEntriesDep = {};
                item?._doc?.departmentlog?.forEach(entry => {
                    const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                    const key = entry.startdate;
                    if (!(key in uniqueEntriesDep)) {
                        uniqueEntriesDep[key] = entry;
                    }
                });

                const uniqueDepLog = Object.values(uniqueEntriesDep);
                const [columnDay, columnMonth, columnYear] = date.formattedDate?.split('/');
                const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

                // Find the relevant log entry for the given date     
                const relevantDepLogEntry = uniqueDepLog
                    .filter(log => log.startdate <= finalDate)
                    .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item?._doc?.weekoff?.includes(date.dayName);
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                const row = {
                    shift: getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, relevantDepLogEntry && relevantDepLogEntry?.department, depMonthSet),
                    formattedDate: date.formattedDate,
                    doj: dojDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    weekNumberInMonth: date.weekNumberInMonth,
                    shiftMode: date.shiftMode,
                    leavestatus: '',
                    shiftcount: '',
                };
                return row;
            });
            return userRows;
        });
        finaluser = [...new Set(beforefinaluser)]
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finaluser) {
        return next(new ErrorHandler("Users not found", 400));
    }
    return res.status(200).json({ finaluser });
});

function getShiftType(shift) {
    if (!shift || (typeof shift === "string" && !shift.includes("to"))) {
        return "Invalid Shift Format";
    }
    const [startTime, endTime] = shift.split("to");

    if (startTime.includes("PM") && endTime.includes("AM")) {
        return "Night Shift";
    } else if (startTime.includes("AM") && endTime.includes("PM")) {
        return "Day Shift";
    } else {
        return "Invalid Shift Format";
    }
}



exports.getUserClockinAndClockoutStatus = async ({ employee, userDates }) => {

    let allLeaveStatus;
    let permission;
    let resultshiftallot = [];
    let graceTime;
    let clockOutHours;
    let lateclockincount;
    let earlyclockoutcount;
    let onclockout;
    let earlyclockin;
    let earlyclockout;
    let lateclockin;
    let afterlateclockin;
    let beforeearlyclockout;
    let finaluser = [];
    // const { userDates, company, branch, unit, department, employee } = req.body;
    // const { userDates, employee } = req.body;
    const formattedUserDates = userDates.map((data) => moment(data.formattedDate, "DD/MM/YYYY").format("DD-MM-YYYY"));

    let query = {
        username: { $in: employee },
        enquirystatus: {
            $nin: ["Enquiry Purpose"],
        },

    }

    try {
        const [users, controlcriteria, depMonthSets, attendances] = await Promise.all([
            User.find(query,
                {
                    company: 1,
                    branch: 1,
                    unit: 1,
                    team: 1,
                    department: 1,
                    doj: 1,
                    empcode: 1,
                    companyname: 1,
                    team: 1,
                    floor: 1,
                    username: 1,
                    designation: 1,
                    weekoff: 1,
                    shiftallot: 1,
                    shifttiming: 1,
                    boardingLog: 1,
                    attendancemode: 1,
                    reasondate: 1,
                    departmentlog: 1,
                    designationlog: 1,
                }
            ),
            ControlCriteria.find(),
            DepartmentMonth.find({}, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 }),
            Attendance.find({
                date: { $in: formattedUserDates },
            }),
        ]);

        const userCds = users.map(user => user.companyname);
        allLeaveStatus = await ApplyLeave.find({ employeename: { $in: userCds } });
        permission = await Permission.find({ employeename: { $in: userCds } }, { employeeid: 1, date: 1, status: 1, applytype: 1, compensationstatus: 1, compensationapplytype: 1, requesthours: 1, shiftmode: 1, });

        clockOutHours = controlcriteria[0].clockout;
        clockInHours = controlcriteria[0].clockin;
        lateclockincount = controlcriteria[0].lateclockincount;
        earlyclockoutcount = controlcriteria[0].earlyclockoutcount;
        onclockout = controlcriteria[0].onclockout;
        earlyclockin = controlcriteria[0].earlyclockin;
        lateclockin = controlcriteria[0].lateclockin;
        earlyclockout = controlcriteria[0].earlyclockout;
        afterlateclockin = controlcriteria[0].afterlateclockin;
        beforeearlyclockout = controlcriteria[0].afterlateclockin;

        finaluser = users?.flatMap((item, index) => {

            let isEmployeeGrace = controlcriteria[0].todos && controlcriteria[0].todos.find(d => d.company === item.company &&
                d.branch === item.branch && d.unit === item.unit && d.team === item.team &&
                d.employeename === item.companyname
            )

            if (isEmployeeGrace) {
                graceTime = isEmployeeGrace.employeegracetime;
            }
            else {
                graceTime = controlcriteria[0].gracetime;
            }

            item.shiftallot?.map(allot => {
                resultshiftallot.push({ ...allot })
            })

            const filteredMatchingDoubleShiftItem = resultshiftallot?.filter(val => val && val?._doc?.empcode === item?._doc?.empcode && val?._doc?.adjstatus === 'Approved');
            const dojDate = item?._doc?.boardingLog.length > 0 ?
                item?._doc?.boardingLog[0].startdate
                : item?._doc?.doj;

            let removedUserDates = userDates?.filter(date => {
                const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem.find(item => item && item?._doc?.todate === date.formattedDate && item?._doc?.adjustmenttype === 'Shift Adjustment');
                return !matchingShiftAdjustmentToDate;
            });
            let uniqueEntries = new Set();
            userDates?.forEach(date => {
                uniqueEntries.add(JSON.stringify({
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    shiftMode: 'Main Shift',
                    weekNumberInMonth: date.weekNumberInMonth
                }));
            });

            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach(item => {
                const [day, month, year] = item._doc.adjdate?.split('/')
                let newFormattedDate = new Date(`${year}-${month}-${day}`);

                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(JSON.stringify({
                        formattedDate: item._doc.adjdate,
                        dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
                        dayCount: parseInt(moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")),
                        shiftMode: 'Second Shift',
                        weekNumberInMonth: (getWeekNumberInMonth(newFormattedDate) === 1 ? `${getWeekNumberInMonth(newFormattedDate)}st Week` :
                            getWeekNumberInMonth(newFormattedDate) === 2 ? `${getWeekNumberInMonth(newFormattedDate)}nd Week` :
                                getWeekNumberInMonth(newFormattedDate) === 3 ? `${getWeekNumberInMonth(newFormattedDate)}rd Week` :
                                    getWeekNumberInMonth(newFormattedDate) > 3 ? `${getWeekNumberInMonth(newFormattedDate)}th Week` : '')
                    }));
                }
            });

            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries)?.map(entry => JSON.parse(entry));

            function sortUserDates(dates) {
                return dates.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);
            const createdUserDates = sortedCreatedUserDates?.filter(d => {
                const filterData = userDates.some(val => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date) => {
                let filteredRowData = resultshiftallot?.filter((val) => val?._doc?.empcode == item?._doc?.empcode);
                const matchingItem = filteredRowData?.find(item => item && item?._doc?.adjdate == date.formattedDate);
                const matchingItemAllot = filteredRowData?.find(item => item && formatDate(item?._doc?.date) == date.formattedDate);
                const matchingDoubleShiftItem = filteredRowData?.find(item => item && item?._doc?.todate === date.formattedDate);
                const matchingRemovedItem = filteredRowData?.find(item => item?._doc?.removedshiftdate === date.formattedDate);
                const matchingAssignShiftItem = filteredRowData?.find(item => item?._doc?.adjdate === date.formattedDate && item?._doc?.adjstatus === 'Approved' && item?._doc?.adjustmenttype === 'Assign Shift');

                const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                    // return item;
                });

                // Remove duplicate entries with the most recent entry
                const uniqueEntriesDep = {};
                item?._doc?.departmentlog?.forEach(entry => {
                    const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                    const key = entry.startdate;
                    if (!(key in uniqueEntriesDep)) {
                        uniqueEntriesDep[key] = entry;
                    }
                });

                const uniqueDepLog = Object.values(uniqueEntriesDep);
                const [columnDay, columnMonth, columnYear] = date.formattedDate?.split('/');
                const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

                // Find the relevant log entry for the given date     
                const relevantDepLogEntry = uniqueDepLog
                    .filter(log => log.startdate <= finalDate)
                    .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

                // Remove duplicate entries with the most recent entry
                const uniqueEntriesDesig = {};
                item?._doc?.designationlog?.forEach(entry => {
                    const entryDate = new Date(entry.startdate);
                    const key = entry.startdate;
                    if (!(key in uniqueEntriesDesig)) {
                        uniqueEntriesDesig[key] = entry;
                    }
                });

                const uniqueDesigLog = Object.values(uniqueEntriesDesig);

                // Find the relevant log entry for the given date     
                const relevantDesigLogEntry = uniqueDesigLog
                    .filter(log => log.startdate <= finalDate)
                    .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

                const depMonthSet = depMonthSets.filter(d => d.department === (relevantDepLogEntry && relevantDepLogEntry?.department))
                const attendance = attendances.filter(d => d.username === item?._doc?.username)

                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item?._doc?.weekoff?.includes(date.dayName);
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;
                function convertToDateTime(timeRange, dateStr) {
                    let [startTimeStr, endTimeStr] = timeRange.split("to").map(t => t.trim());
                    let [day, month, year] = dateStr.split("/").map(n => n.trim());

                    // Convert to a proper date format
                    let formattedDate = `${year}-${month}-${day}`;
                    let startTime = new Date(`${formattedDate}T${convertTo24Hour(startTimeStr)}`);
                    let endTime = new Date(`${formattedDate}T${convertTo24Hour(endTimeStr)}`);

                    let orgStartTime = new Date(`${formattedDate}T${convertTo24Hour(startTimeStr)}`);
                    let orgEndTime = new Date(`${formattedDate}T${convertTo24Hour(endTimeStr)}`);
                    // console.log(moment(startTime).format("DD-MM-YYYY hh:mm a"), endTime, 'Parsed startTime and endTime');

                    if (isNaN(startTime) || isNaN(endTime)) {
                        // console.error("Invalid date format");
                        return null;
                    }


                    // Handle cases where endTime is on the next day
                    if (endTime <= startTime) {
                        endTime.setDate(endTime.getDate() + 1);
                    }
                    if (orgEndTime <= orgStartTime) {
                        orgEndTime.setDate(orgEndTime.getDate() + 1);
                    }

                    startTime.setHours(startTime.getHours() - Number(clockInHours));
                    endTime.setHours(endTime.getHours() + Number(clockOutHours));
                    return { startTime, endTime, orgStartTime, orgEndTime, date: moment(startTime).format("DD-MM-YYYY"), formattedStartTime: moment(startTime).format("DD-MM-YYYY hh:mm a"), formattedEndTime: moment(endTime).format("DD-MM-YYYY hh:mm a") };
                }

                // Convert 12-hour format with AM/PM to 24-hour format
                function convertTo24Hour(timeStr) {
                    let match = timeStr && timeStr.match(/^(\d{1,2}):?(\d{2})?\s*([APap][Mm])$/);

                    if (!match) return null;

                    let [_, hours, minutes, modifier] = match;
                    hours = parseInt(hours, 10);
                    minutes = minutes ? parseInt(minutes, 10) : 0;

                    if (modifier.toLowerCase() === "pm" && hours !== 12) {
                        hours += 12;
                    }
                    if (modifier.toLowerCase() === "am" && hours === 12) {
                        hours = 0;
                    }

                    return `${String(hours).padStart(2, "0")}:${String(minutes).padStart(2, "0")}:00`;
                }

                const shiftTiming = getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem);
                const row = {
                    id: `${item?._doc?._id.toString()}_${date.formattedDate}_${date.shiftMode}`,
                    username: item?._doc?.companyname,
                    rowusername: item?._doc?.username,
                    weekoff: item?._doc?.weekoff,
                    shifttype : getShiftType(shiftTiming),
                    shift: shiftTiming,
                    rowformattedDate: date.formattedDate,
                    shiftMode: date.shiftMode,
                    shiftdate: shiftTiming ?
                        convertToDateTime(shiftTiming, date.formattedDate) : "",
                    weekoffpresentstatus: checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                };

                return row;
            });

            return userRows;

        });

    } catch (err) {
        console.log(err, "err")
        return new ErrorHandler("Records not found!", 404);
    }

    if (!finaluser) {
        return new ErrorHandler("Users not found", 400);
    }

    return { finaluser };
};

exports.checkEmployeeEmptyFields = async (req, res) => {
    try {
        const { id } = req.query;

        // Fetch the user document first
        const document = await User.findById(id).lean();

        if (!document) {
            return res.status(404).json({ message: "Document not found" });
        }

        // Fetch employeedocument and assignbranch concurrently
        const [employeedocument, assignbranch] = await Promise.all([
            EmployeeDocuments.findOne({ commonid: document._id.toString() }).lean(),
            AssignBranch.findOne({
                employee: document.companyname,
                employeecode: document.empcode,
            }).lean(),
        ]);

        const emptyFields = new Set(); // Using Set to avoid duplicate entries

        const checkEmpty = (obj, prefix = "") => {
            for (const key in obj) {
                const value = obj[key];

                if (Array.isArray(value) && key === "workstation") {
                    if (value.length === 0) {
                        emptyFields.add("workstationprimary");
                        emptyFields.add("workstationsecondary");
                    } else {
                        if (value.includes("Please Select Primary Work Station")) {
                            emptyFields.add("workstationprimary");
                        }
                        if (value.length === 1) {
                            emptyFields.add("workstationsecondary");
                        }
                    }
                } else if (Array.isArray(value) && key === "boardingLog") {
                    if (value.length === 0) {
                        emptyFields.add("weekoff");
                    } else if (value.length > 0) {
                        if (value[value?.length - 1]?.weekoff?.length === 0) {
                            emptyFields.add("weekoff");
                        }
                    }
                } else if (
                    value === "" || // Check for empty string
                    value === "undefined" || // Check for "undefined" as a string
                    value === undefined || // Check for actual undefined
                    (Array.isArray(value) && value.length === 0) || // Check for empty array
                    (typeof value === "number" && value === 0) // Check for number equal to 0
                ) {
                    emptyFields.add(prefix + key);
                } else if (
                    typeof value === "object" &&
                    value !== null &&
                    !Array.isArray(value)
                ) {
                    // Recursively check nested objects
                    checkEmpty(value, `${prefix}${key}.`);
                }
            }

            if (obj.workmode !== "Internship") {
                emptyFields.delete(`${prefix}intStartDate`);
                emptyFields.delete(`${prefix}intEndDate`);
                emptyFields.delete(`${prefix}modeOfInt`);
                emptyFields.delete(`${prefix}intDuration`);
            }
            if (obj.maritalstatus !== "Married") {
                emptyFields.delete(`${prefix}dom`);
            }
        };

        checkEmpty(document);

        // Post-processing conditions after the loop
        if (document.panstatus === "Have PAN") {
            emptyFields.delete("panrefno");
        }

        if (document.panstatus === "Applied") {
            emptyFields.delete("panno");
        }

        if (document.panstatus === "Yet to Apply") {
            emptyFields.delete("panno");
            emptyFields.delete("panrefno");
        }

        // Check for employeedocument fields
        if (!employeedocument) {
            emptyFields.add("profileimage");
            emptyFields.add("employeedocuments");
        } else {
            if (!employeedocument.profileimage) emptyFields.add("profileimage");
            if (employeedocument.files.length === 0)
                emptyFields.add("employeedocuments");
        }

        // Check for assignbranch
        if (!assignbranch) {
            emptyFields.add("assignbranch");
        }
        return res.status(200).json({
            message: "Check completed",
            emptyFields: [...emptyFields], // Convert Set back to array
        });
    } catch (err) {
        return res.status(500).json({
            message: "Internal Server Error",
            error: err.message,
        });
    }
};
exports.getUserCredentials = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {
        users = await User.find(
            {
                username: req.body.username,
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
                resonablestatus: {
                    $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
            },
            {
                username: 1,
                email: 1,
                companyname: 1,
                id: 1,
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Data not found", 404));
    }

    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: users.length, users });
});
exports.getAllUserTemporaryLoginStatus = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {
        users = await User.aggregate([
            {
                $lookup: {
                    from: "individualsettings",
                    localField: "companyname",
                    foreignField: "companyname",
                    as: "result"
                }
            },
            {
                $project: {
                    companyname: 1,
                    _id: 1,
                    empcode: 1,
                    company: 1,
                    branch: 1,
                    unit: 1,
                    team: 1,
                    designation: 1,
                    department: 1,
                    extrastatus: 1,
                    extradate: 1,
                    extratime: 1,
                    extramode: 1,
                    loginapprestriction: {
                        $cond: {
                            if: { $gt: [{ $size: "$result" }, 0] },
                            then: {
                                $arrayElemAt: [
                                    "$result.loginapprestriction",
                                    0
                                ]
                            },
                            else: null
                        }
                    }
                }
            },
            {
                $lookup: {
                    from: "adminoverallsettings",
                    pipeline: [
                        { $match: {} },
                        {
                            $project: {
                                loginapprestriction: 1,
                                companyname: 1,
                                _id: 1,
                                empcode: 1,
                                company: 1,
                                branch: 1,
                                unit: 1,
                                team: 1,
                                designation: 1,
                                department: 1,
                                extramode: 1,
                                extrastatus: 1,
                                extradate: 1,
                                extratime: 1
                            }
                        }
                    ],
                    as: "adminResult"
                }
            },
            {
                $addFields: {
                    loginapprestriction: {
                        $cond: {
                            if: {
                                $eq: ["$loginapprestriction", null]
                            },
                            then: {
                                $arrayElemAt: [
                                    "$adminResult.loginapprestriction",
                                    0
                                ]
                            },
                            else: "$loginapprestriction"
                        }
                    }
                }
            },
            // Add this $match stage to filter out unwanted enquirystatus and resonablestatus
            {
                $match: {
                    enquirystatus: {
                        $nin: ["Enquiry Purpose"]
                    },
                    resonablestatus: {
                        $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"]
                    }
                }
            },
            {
                $project: {
                    companyname: 1,
                    _id: 1,
                    empcode: 1,
                    company: 1,
                    branch: 1,
                    unit: 1,
                    team: 1,
                    designation: 1,
                    department: 1,
                    extrastatus: 1,
                    extradate: 1,
                    extratime: 1,
                    extramode: 1,
                    loginapprestriction: 1
                }
            }
        ]);
    } catch (err) {
        return next(new ErrorHandler("User not found!", 404));
    }
    return res.status(200).json({
        users,
    });
});


exports.dynamicQueryUserController = async (req, res) => {
    try {
        const { aggregationPipeline } = req.body;

        const users = await User.aggregate(aggregationPipeline);

        return res.status(200).json({
            users,
        });
    } catch (err) {
        return res.status(500).json({ error: "Internal server error" });
    }
};


exports.getAllUsersexceldataAssignbranch = catchAsyncErrors(async (req, res, next) => {

    const { assignbranch, month, year } = req.body;

    const query = {
        workmode: { $ne: "Internship" },

        // companyname: "VINITHA.NATESAN",
    }



    if (assignbranch.length > 0) {
        query.$or = assignbranch.map(item => ({
            company: item.company,
            branch: item.branch,
            unit: item.unit,
            workmode: { $ne: "Internship" },
            // companyname: "KANAGARAJ.RAJAMANI",
            enquirystatus: { $nin: ["Enquiry Purpose"] },

            // resonablestatus: {
            //     $nin: [
            //         "Not Joined",
            //         "Postponed",
            //         "Rejected",
            //         "Closed",
            //         "Releave Employee",
            //         "Absconded",
            //         "Hold",
            //         "Terminate"
            //     ],
            // }
        }))
    }

    let users, usersAll, depMonthSet;
    try {
        depMonthSet = await DepartmentMonth.find({ monthname: month, year: year }, { department: 1, fromdate: 1, todate: 1 });
        usersAll = await User.find(query,
            {

            }
        );
        const fromDateSet = [...new Set(depMonthSet.map(d => d.fromdate))];
        users = usersAll.map(item => {
            let findUserDeprtment = item.department;

            if (item.departmentlog && item.departmentlog.length > 1) {
                // const findDept = item.departmentlog.find(dept => fromDateSet.includes(dept.startdate) );
                const sortedDepartmentLog = item.departmentlog.sort((a, b) => new Date(b.startdate) - new Date(a.startdate));

                const findDept = sortedDepartmentLog.find(dept =>
                    fromDateSet.includes(dept.startdate) ||
                    fromDateSet.some(fromDate => new Date(fromDate) > new Date(dept.startdate))
                );
                findUserDeprtment = findDept ? findDept.department : "";
            } else if (item.departmentlog && item.departmentlog.length > 0) {
                findUserDeprtment = new Date(item.doj) >= new Date(item.departmentlog[0].startdate) ? item.departmentlog[0].department : ""
            }
            let findfromtodate = depMonthSet.find(d => d.department === findUserDeprtment)
            let fromdate = findfromtodate ? findfromtodate.fromdate : ""
            let todate = findfromtodate ? findfromtodate.todate : ""
            if (item.reasondate == "" || (item.resonablestatus !== "" && new Date(item.reasondate) >= new Date(fromdate))) {
                return {
                    ...item._doc, // Use _doc to avoid including Mongoose metadata
                    department: findUserDeprtment,
                };
            }

            // return null; // Exclude users who don't match the department
        }).filter(item => item !== null);

    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    // if (!users || users.length === 0) {
    //     return next(new ErrorHandler("Users not found", 400));
    // }
    return res.status(200).json({ count: users.length, users });
});


exports.getAllUsersexceldataByAssign = catchAsyncErrors(async (req, res, next) => {
    const { assignbranch } = req.body;

    const query = {
        $or: assignbranch.map(item => ({
            company: item.company,
            branch: item.branch,
            unit: item.unit
        })),
        enquirystatus: {
            $nin: ["Enquiry Purpose"],
        },
        resonablestatus: {
            $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
        },
    };
    let users;
    try {
        users = await User.find(
            query,
            {
                status: 1,
                resonablestatus: 1,
                reasonname: 1,
                lastworkday: 1,
                department: 1,
                dob: 1,
                location: 1,
                bloodgroup: 1,
                gender: 1,
                maritalstatus: 1,
                lastname: 1,
                contactpersonal: 1,
                processlog: 1,
                boardingLog: 1, attendancemode: 1,
                designationlog: 1,
                company: 1,
                reasondate: 1,
                empreason: 1,
                percentage: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                floor: 1,
                username: 1,
                usernameautogenerate: 1,
                workmode: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,

                unit: 1,
                branch: 1,
                designation: 1,
                team: 1,
                shift: 1,
                reportingto: 1,
                experience: 1,
                doj: 1,
                dot: 1,
                role: 1,
                bankname: 1,
                bankbranchname: 1,
                accountholdername: 1,
                accountnumber: 1,
                ifsccode: 1,
                shifttiming: 1,
                shiftgrouping: 1,
                legalname: 1,
                callingname: 1,
                pdoorno: 1,
                pstreet: 1,
                parea: 1,
                plandmark: 1,
                ptaluk: 1,
                ppost: 1,
                ppincode: 1,
                pcountry: 1,
                pstate: 1,
                pcity: 1,
                cdoorno: 1,
                cstreet: 1,
                carea: 1,
                clandmark: 1,
                ctaluk: 1,
                cpost: 1,
                cpincode: 1,
                ccountry: 1,
                cstate: 1,
                ccity: 1,
                reasondate: 1,
                process: 1,
                workstation: 1,
                weekoff: 1,
                originalpassword: 1,
                enquirystatus: 1,
                area: 1,
                enableworkstation: 1,
                wordcheck: 1,
                shiftallot: 1,
                twofaenabled: 1,
                fathername: 1,
                mothername: 1,
                firstname: 1,
                contactfamily: 1,
                emergencyno: 1,
                referencetodo: 1,
                contactno: 1,
                details: 1,
                assignExpLog: 1,
                pfesistatus: 1,
                status: 1,
                resonablestatus: 1,
                reasonname: 1,
                lastworkday: 1,
                department: 1,
                dob: 1,
                location: 1,
                bloodgroup: 1,
                gender: 1,
                maritalstatus: 1,
                lastname: 1,
                contactpersonal: 1,
                processlog: 1,
                boardingLog: 1, attendancemode: 1,
                designationlog: 1,
                company: 1,
                reasondate: 1,
                empreason: 1,
                percentage: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                floor: 1,
                username: 1,
                usernameautogenerate: 1,
                workmode: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,

                unit: 1,
                branch: 1,
                designation: 1,
                team: 1,
                shift: 1,
                reportingto: 1,
                experience: 1,
                doj: 1,
                role: 1,
                bankname: 1,
                bankbranchname: 1,
                accountholdername: 1,
                accountnumber: 1,
                ifsccode: 1,
                shifttiming: 1,
                shiftgrouping: 1,
                legalname: 1,
                callingname: 1,
                pdoorno: 1,
                pstreet: 1,
                parea: 1,
                plandmark: 1,
                ptaluk: 1,
                ppost: 1,
                ppincode: 1,
                pcountry: 1,
                pstate: 1,
                pcity: 1,
                cdoorno: 1,
                cstreet: 1,
                carea: 1,
                clandmark: 1,
                ctaluk: 1,
                cpost: 1,
                cpincode: 1,
                ccountry: 1,
                cstate: 1,
                ccity: 1,
                reasondate: 1,
                process: 1,
                workstation: 1,
                weekoff: 1,
                originalpassword: 1,
                enquirystatus: 1,
                area: 1,
                enableworkstation: 1,
                wordcheck: 1,
                shiftallot: 1,
                twofaenabled: 1,
                fathername: 1,
                mothername: 1,
                firstname: 1,
                contactfamily: 1,
                emergencyno: 1,
                referencetodo: 1,
                contactno: 1,
                details: 1,
                assignExpLog: 1,
                ipname: 1,
                pfmembername: 1,
                uan: 1,
                insurancenumber: 1,
                shiftallowancelog: 1,
                targetpointlog: 1,
                acheivedpointlog: 1,
                penaltylog: 1,
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }
    return res.status(200).json({ count: users.length, users });
});
exports.getAllUsersAssignbranch = catchAsyncErrors(async (req, res, next) => {
    const { assignbranch } = req.body;
    if (!Array.isArray(assignbranch) || assignbranch.length === 0) {
        // return next(new ErrorHandler("assignbranch must be a non-empty array", 400)); 
    }
    // Create a query array for company and branch
    const query = {
        $or: assignbranch.map(item => ({
            company: item.company,
            branch: item.branch,
            unit: item.unit
        })),
        enquirystatus: { $nin: ["Enquiry Purpose"] },
        resonablestatus: { $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"] }
    };


    let users;

    try {
        users = await User.find(query,

            {
                status: 1,
                resonablestatus: 1,
                reasonname: 1,
                lastworkday: 1,
                rejoin: 1,
                reasonablestatusremarks: 1,
                department: 1,
                dob: 1,
                gender: 1,
                maritalstatus: 1,
                bloodgroup: 1,
                location: 1,
                contactpersonal: 1,
                panno: 1,
                aadhar: 1,
                designationlog: 1,
                contactfamily: 1,
                approvedremotestatus: 1,
                ctaluk: 1,
                dom: 1,
                processlog: 1,
                boardingLog: 1,
                attendancemode: 1,
                company: 1,
                reasondate: 1,
                empreason: 1,
                percentage: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                username: 1,
                usernameautogenerate: 1,
                workmode: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,

                unit: 1,
                branch: 1,
                designation: 1,
                floor: 1,
                shift: 1,
                reportingto: 1,
                experience: 1,
                doj: 1,
                dot: 1,
                bankname: 1,
                bankbranchname: 1,
                accountholdername: 1,
                accountnumber: 1,
                ifsccode: 1,
                shifttiming: 1,
                shiftgrouping: 1,
                legalname: 1,
                callingname: 1,
                pdoorno: 1,
                pstreet: 1,
                candidateid: 1,
                parea: 1,
                plandmark: 1,
                ptaluk: 1,
                ppost: 1,
                ppincode: 1,
                pcountry: 1,
                pstate: 1,
                pcity: 1,
                cdoorno: 1,
                cstreet: 1,
                carea: 1,
                role: 1,
                clandmark: 1,
                ctaluk: 1,
                cpost: 1,
                cpincode: 1,
                ccountry: 1,
                cstate: 1,
                ccity: 1,
                reasondate: 1,
                process: 1,
                workstation: 1,
                weekoff: 1,
                originalpassword: 1,
                enquirystatus: 1,
                area: 1,
                enableworkstation: 1,
                wordcheck: 1,
                shiftallot: 1,
                firstname: 1,
                lastname: 1,
                employeecount: 1,
                emergencyno: 1,
                name: 1,
                salarysetup: 1,
                mode: 1,
                salarycode: 1,
                basic: 1,
                hra: 1,
                conveyance: 1,
                medicalallowance: 1,
                productionallowance: 1,
                otherallowance: 1,
                productionallowancetwo: 1,
                pffromdate: 1,
                pfenddate: 1,
                esifromdate: 1,
                esienddate: 1,
                pfesistatus: 1,
                resonablestatus: 1,
                reasonname: 1,
                lastworkday: 1,
                department: 1,
                dob: 1,
                location: 1,
                bloodgroup: 1,
                gender: 1,
                maritalstatus: 1,
                lastname: 1,
                contactpersonal: 1,
                processlog: 1,
                boardingLog: 1,
                attendancemode: 1,
                designationlog: 1,
                company: 1,
                reasondate: 1,
                empreason: 1,
                percentage: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                floor: 1,
                username: 1,
                usernameautogenerate: 1,
                workmode: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,

                unit: 1,
                branch: 1,
                designation: 1,
                team: 1,
                bankdetails: 1,
                shift: 1,
                reportingto: 1,
                experience: 1,
                doj: 1,
                role: 1,
                bankname: 1,
                bankbranchname: 1,
                accountholdername: 1,
                accountnumber: 1,
                ifsccode: 1,
                shifttiming: 1,
                shiftgrouping: 1,
                legalname: 1,
                callingname: 1,
                pdoorno: 1,
                pstreet: 1,
                parea: 1,
                plandmark: 1,
                ptaluk: 1,
                ppost: 1,
                ppincode: 1,
                pcountry: 1,
                pstate: 1,
                pcity: 1,
                cdoorno: 1,
                cstreet: 1,
                carea: 1,
                clandmark: 1,
                ctaluk: 1,
                cpost: 1,
                cpincode: 1,
                ccountry: 1,
                cstate: 1,
                ccity: 1,
                reasondate: 1,
                process: 1,
                workstation: 1,
                weekoff: 1,
                originalpassword: 1,
                enquirystatus: 1,
                area: 1,
                enableworkstation: 1,
                wordcheck: 1,
                shiftallot: 1,
                twofaenabled: 1,
                fathername: 1,
                mothername: 1,
                firstname: 1,
                workstationinput: 1,
                emergencyno: 1,
                referencetodo: 1,
                contactno: 1,
                details: 1,
                assignExpLog: 1,
                grosssalary: 1,
                timemins: 1,
                modeexperience: 1,
                targetexperience: 1,
                targetpts: 1,
                expval: 1,
                expmode: 1,
                process: 1,
                processtype: 1,
                processduration: 1,
                duration: 1,
                workstationofficestatus: 1,
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: users.length, users });
});


exports.getAllUsersCompanyname = catchAsyncErrors(async (req, res, next) => {
    let users;

    try {
        users = await User.find(
            {

                resonablestatus: {
                    $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
            },
            {
                companyname: 1,
                company: 1,
                branch: 1,
                unit: 1,
                team: 1,
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ users });
});

exports.getIndividualUserLoginStatus = catchAsyncErrors(async (req, res, next) => {
    let users;
    try {
        users = await User.findOne(
            {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
                resonablestatus: {
                    $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
                companyname: req.body.companyname

            },
            {
                empcode: 1,
                companyname: 1,
                username: 1,
                branch: 1,
                unit: 1,
                designation: 1,
                team: 1,
                department: 1,
                company: 1,
                extratime: 1,
                extrastatus: 1, wfhcount: 1, wfhstatus: 1,
                extradate: 1,
                loginUserStatus: 1
            }
        );

    } catch (err) {
        return next(new ErrorHandler("User not found!", 404));
    }
    return res.status(200).json({
        users,
    });
});


exports.getHierarchyBasedEmployeeStatus = catchAsyncErrors(async (req, res, next) => {
    let resultArray,
        user,
        result1,
        ans1D,
        i = 1,
        result2,
        result3,
        result4,
        result5,
        result6,
        dataCheck,
        userFilter,
        result,
        hierarchyFilter,
        answerDef,
        hierarchyFinal,
        hierarchy,
        hierarchyDefList,
        resultAccessFilter,
        branch,
        hierarchySecond,
        overallMyallList,
        hierarchyMap,
        resulted,
        resultedTeam,
        DataAccessMode = false,
        myallTotalNames;

    try {
        const { listpageaccessmode } = req.body;
        let levelFinal = req.body?.sector === 'All' ? ['Primary', 'Secondary', 'Tertiary'] : [req.body?.sector];
        let answer = await Hirerarchi.aggregate([
            {
                $match: {
                    supervisorchoose: req?.body?.username, // Match supervisorchoose with username
                    level: { $in: levelFinal }, // Corrected unmatched quotation mark
                },
            },
            {
                $lookup: {
                    from: 'reportingheaders', // The name of the collection to join with
                    let: {
                        teamControlsArray: {
                            $ifNull: ['$pagecontrols', []],
                        }, // Ensure 'teamcontrols' is an array or default to an empty array
                    },
                    pipeline: [
                        {
                            $match: {
                                $expr: {
                                    $and: [
                                        {
                                            $in: ['$name', '$$teamControlsArray'],
                                        }, // Check if 'name' is in 'teamcontrols' array
                                        {
                                            $in: [
                                                req?.body?.pagename,
                                                '$reportingnew', // Check if 'menuteamloginstatus' is in 'reportingnew' array
                                            ],
                                        }, // Additional condition for reportingnew array
                                    ],
                                },
                            },
                        },
                    ],
                    as: 'reportData', // The resulting matched documents will be in this field
                },
            },
            {
                $project: {
                    supervisorchoose: 1,
                    employeename: 1,
                    reportData: 1,
                },
            },
        ]);

        // Manager Condition Without Supervisor
        const HierarchySupervisorFind = await Hirerarchi.find({ supervisorchoose: req?.body?.username });
        DataAccessMode = req.body.role?.some(role => role.toLowerCase() === "manager") && HierarchySupervisorFind?.length === 0;
        const { uniqueNames, pageControlsData } = await Hierarchyfilter(levelFinal, req?.body?.pagename);


        let restrictList = answer?.filter((data) => data?.reportData?.length > 0)?.flatMap((Data) => Data?.employeename);

        result = await User.find(
            {
                enquirystatus: {
                    $nin: ['Enquiry Purpose'],
                },
                resonablestatus: {
                    $nin: ['Not Joined', 'Postponed', 'Rejected', 'Closed', 'Releave Employee', 'Absconded', 'Hold', 'Terminate'],
                },
                ...(listpageaccessmode === 'Reporting to Based' ? { reportingto: req.body.username } : {}),
            },
            {
                empcode: 1,
                companyname: 1,
                username: 1,
                branch: 1,
                unit: 1,
                designation: 1,
                team: 1,
                department: 1,
                company: 1,
                extratime: 1,
                extrastatus: 1,
                extradate: 1,
                wfhcount: 1,
                wfhstatus: 1,
                loginUserStatus: 1,
                workstation: 1,
                workstationshortname: 1,
                workstationinput: 1,
            }
        );

        // Accordig to sector and list filter process
        hierarchyFilter = await Hirerarchi.find({ level: req.body.sector });
        userFilter = hierarchyFilter.filter((data) => data.supervisorchoose.includes(req.body.username)).map((data) => data.employeename);

        hierarchyDefList = await Hirerarchi.find();
        user = await User.find({ companyname: req.body.username });
        const userFilt = user.length > 0 && user[0].designation;
        const desiGroup = await Designation.find();
        let HierarchyFilt = req.body.sector === 'all' ? hierarchyDefList.filter((data) => data.supervisorchoose.includes(req.body.username)).map((data) => data.designationgroup) : hierarchyFilter.filter((data) => data.supervisorchoose.includes(req.body.username)).map((data) => data.designationgroup);
        const DesifFilter = desiGroup.filter((data) => HierarchyFilt.includes(data.group));
        const desigName = DesifFilter.length > 0 && DesifFilter[0].name;
        const SameDesigUser = HierarchyFilt.includes('All') ? true : userFilt === desigName;
        //Default Loading of List
        answerDef = hierarchyDefList.filter((data) => data.supervisorchoose.includes(req.body.username)).map((data) => data.employeename);

        hierarchyFinal = req.body.sector === 'all' ? (answerDef.length > 0 ? [].concat(...answerDef) : []) : hierarchyFilter.length > 0 ? [].concat(...userFilter) : [];

        hierarchyMap = hierarchyFinal.length > 0 ? hierarchyFinal : [];

        //solo
        ans1D = req.body.sector === 'all' ? (answerDef.length > 0 ? hierarchyDefList.filter((data) => data.supervisorchoose.includes(req.body.username)) : []) : hierarchyFilter.length > 0 ? hierarchyFilter.filter((data) => data.supervisorchoose.includes(req.body.username)) : [];
        result1 =
            ans1D.length > 0
                ? result
                    .map((item1) => {
                        const matchingItem2 = ans1D.find((item2) => item2.employeename.includes(item1.companyname));

                        if (matchingItem2) {
                            const plainItem1 = item1.toObject ? item1.toObject() : item1;
                            return {
                                ...plainItem1,
                                level: req.body.sector + '-' + matchingItem2.control,
                            };
                            //   return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                        }
                    })
                    .filter((item) => item !== undefined)
                : [];

        resulted = result1;

        //team
        let branches = [];
        hierarchySecond = await Hirerarchi.find();

        const subBranch =
            hierarchySecond.length > 0
                ? hierarchySecond
                    .filter((item) => item.supervisorchoose.some((name) => hierarchyMap.includes(name)))
                    .map((item) => item.employeename)
                    .flat()
                : '';

        const answerFilterExcel = hierarchySecond.length > 0 ? hierarchySecond.filter((item) => item.supervisorchoose.some((name) => hierarchyMap.includes(name))) : [];

        result2 =
            answerFilterExcel.length > 0
                ? result
                    .map((item1) => {
                        const matchingItem2 = answerFilterExcel.find((item2) => item2.employeename.includes(item1.companyname));
                        if (matchingItem2) {
                            // If a match is found, inject the control property into the corresponding item in an1
                            const plainItem1 = item1.toObject ? item1.toObject() : item1;
                            return {
                                ...plainItem1,
                                level: req.body.sector + '-' + matchingItem2.control,
                            };
                            // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                        }
                    })
                    .filter((item) => item !== undefined)
                : [];
        branches.push(...subBranch);

        const ans =
            subBranch.length > 0
                ? hierarchySecond
                    .filter((item) => item.supervisorchoose.some((name) => subBranch.includes(name)))
                    .map((item) => item.employeename)
                    .flat()
                : '';
        const answerFilterExcel2 = subBranch.length > 0 ? hierarchySecond.filter((item) => item.supervisorchoose.some((name) => subBranch.includes(name))) : [];

        result3 =
            answerFilterExcel2.length > 0
                ? result
                    .map((item1) => {
                        const matchingItem2 = answerFilterExcel2.find((item2) => item2.employeename.includes(item1.companyname));
                        if (matchingItem2) {
                            const plainItem1 = item1.toObject ? item1.toObject() : item1;
                            return {
                                ...plainItem1,
                                level: req.body.sector + '-' + matchingItem2.control,
                            };
                            // If a match is found, inject the control property into the corresponding item in an1
                            // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                        }
                    })
                    .filter((item) => item !== undefined)
                : [];
        branches.push(...ans);

        const loop3 =
            ans.length > 0
                ? hierarchySecond
                    .filter((item) => item.supervisorchoose.some((name) => ans.includes(name)))
                    .map((item) => item.employeename)
                    .flat()
                : '';

        const answerFilterExcel3 = ans.length > 0 ? hierarchySecond.filter((item) => item.supervisorchoose.some((name) => ans.includes(name))) : [];

        result4 =
            answerFilterExcel3.length > 0
                ? result
                    .map((item1) => {
                        const matchingItem2 = answerFilterExcel3?.find((item2) => item2.employeename.includes(item1.companyname));
                        if (matchingItem2) {
                            const plainItem1 = item1.toObject ? item1.toObject() : item1;
                            return {
                                ...plainItem1,
                                level: req.body.sector + '-' + matchingItem2.control,
                            };
                            // If a match is found, inject the control property into the corresponding item in an1
                            // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                        }
                    })
                    .filter((item) => item !== undefined)
                : [];
        branches.push(...loop3);

        const loop4 =
            loop3.length > 0
                ? hierarchySecond
                    .filter((item) => item.supervisorchoose.some((name) => loop3.includes(name)))
                    .map((item) => item.employeename)
                    .flat()
                : [];
        const answerFilterExcel4 = loop3.length > 0 ? hierarchySecond.filter((item) => item.supervisorchoose.some((name) => loop3.includes(name))) : [];
        result5 =
            answerFilterExcel4.length > 0
                ? result
                    .map((item1) => {
                        const matchingItem2 = answerFilterExcel4?.find((item2) => item2.employeename.includes(item1.companyname));
                        if (matchingItem2) {
                            const plainItem1 = item1.toObject ? item1.toObject() : item1;
                            return {
                                ...plainItem1,
                                level: req.body.sector + '-' + matchingItem2.control,
                            };
                            // If a match is found, inject the control property into the corresponding item in an1
                            // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                        }
                    })
                    .filter((item) => item !== undefined)
                : [];
        branches.push(...loop4);

        const loop5 =
            loop4.length > 0
                ? hierarchySecond
                    .filter((item) => item.supervisorchoose.some((name) => loop4.includes(name)))
                    .map((item) => item.employeename)
                    .flat()
                : '';
        const answerFilterExcel5 = loop4.length > 0 ? hierarchySecond.filter((item) => item.supervisorchoose.some((name) => loop4.includes(name))) : [];
        result6 =
            answerFilterExcel5.length > 0
                ? result
                    .map((item1) => {
                        const matchingItem2 = answerFilterExcel5?.find((item2) => item2.employeename.includes(item1.companyname));
                        if (matchingItem2) {
                            const plainItem1 = item1.toObject ? item1.toObject() : item1;
                            return {
                                ...plainItem1,
                                level: req.body.sector + '-' + matchingItem2.control,
                            };
                            // If a match is found, inject the control property into the corresponding item in an1
                            // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                        }
                    })
                    .filter((item) => item !== undefined)
                : [];
        branches.push(...loop5);

        resultedTeam = [...result2, ...result3, ...result4, ...result5, ...result6];
        //overall Teams List
        myallTotalNames = DataAccessMode ? uniqueNames : [...hierarchyMap, ...branches];

        const finalResult = await User.find(
            {
                companyname: { $in: myallTotalNames },

                enquirystatus: {
                    $nin: ['Enquiry Purpose'],
                },
                resonablestatus: {
                    $nin: ['Not Joined', 'Postponed', 'Rejected', 'Closed', 'Releave Employee', 'Absconded', 'Hold', 'Terminate'],
                },
                ...(listpageaccessmode === 'Reporting to Based' ? { reportingto: req.body.username } : {}),
            },
            {
                empcode: 1,
                companyname: 1,
                username: 1,
                branch: 1,
                unit: 1,
                designation: 1,
                team: 1,
                department: 1,
                company: 1,
                extratime: 1,
                extrastatus: 1,
                extradate: 1,
                wfhcount: 1,
                wfhstatus: 1,
                loginUserStatus: 1,
                workstation: 1,
                workstationshortname: 1,
                workstationinput: 1,
            }
        );


        overallMyallList = [...resulted, ...resultedTeam];

        const restrictTeam = await Hirerarchi.aggregate([
            {
                $match: {
                    supervisorchoose:
                        { $in: myallTotalNames }, // Match supervisorchoose with username
                    level: { $in: levelFinal } // Corrected unmatched quotation mark
                }
            },
            {
                $lookup: {
                    from: "reportingheaders",
                    let: {
                        teamControlsArray: {
                            $ifNull: ["$pagecontrols", []]
                        }
                    },
                    pipeline: [
                        {
                            $match: {
                                $expr: {
                                    $and: [
                                        {
                                            $in: [
                                                "$name",
                                                "$$teamControlsArray"
                                            ]
                                        }, // Check if 'name' is in 'teamcontrols' array
                                        {
                                            $in: [
                                                req?.body?.pagename,
                                                "$reportingnew" // Check if 'menuteamloginstatus' is in 'reportingnew' array
                                            ]
                                        } // Additional condition for reportingnew array
                                    ]
                                }
                            }
                        }
                    ],
                    as: "reportData" // The resulting matched documents will be in this field
                }
            },
            {
                $project: {
                    supervisorchoose: 1,
                    employeename: 1,
                    reportData: 1
                }
            }
        ]);

        let restrictListTeam = DataAccessMode ? pageControlsData : restrictTeam?.filter(data => data?.reportData?.length > 0)?.flatMap(Data => Data?.employeename)
        let overallRestrictList = DataAccessMode ? restrictListTeam :
            (req.body.hierachy === "myhierarchy" ? restrictList :
                req.body.hierachy === "allhierarchy" ? restrictListTeam
                    : [...restrictList, ...restrictListTeam]);

        let resultAccessFiltered = DataAccessMode ? finalResult : (
            req.body.hierachy === 'myhierarchy' && (listpageaccessmode === 'Hierarchy Based' || listpageaccessmode === 'Overall')
                ? resulted
                : req.body.hierachy === 'allhierarchy' && (listpageaccessmode === 'Hierarchy Based' || listpageaccessmode === 'Overall')
                    ? resultedTeam
                    : req.body.hierachy === 'myallhierarchy' && (listpageaccessmode === 'Hierarchy Based' || listpageaccessmode === 'Overall')
                        ? overallMyallList
                        : result);

        resultAccessFilter = overallRestrictList?.length > 0 ? resultAccessFiltered?.filter((data) => overallRestrictList?.includes(data?.companyname)) : [];
    } catch (err) {
        return next(new ErrorHandler('Records not found!', 404));
    }
    return res.status(200).json({
        result,
        ans1D,
        result1,
        resulted,
        resultedTeam,
        branch,
        hierarchy,
        overallMyallList,
        resultAccessFilter,
        hierarchyFilter,
        user,
        dataCheck,
        userFilter,
        resultArray,
        DataAccessMode
    });
});

exports.getHierarchyBasedEmployeeStatusdefault = catchAsyncErrors(async (req, res, next) => {
    let resultArray,
        user,
        result1,
        ans1D,
        i = 1,
        result2,
        result3,
        result4,
        result5,
        result6,
        dataCheck,
        userFilter,
        result,
        hierarchyFilter,
        answerDef,
        hierarchyFinal,
        hierarchy,
        hierarchyDefList,
        resultAccessFilter,
        branch,
        hierarchySecond,
        overallMyallList,
        hierarchyMap,
        resulted,
        resultedTeam,
        DataAccessMode = false,
        myallTotalNames;

    try {
        const { listpageaccessmode } = req.body;
        let levelFinal = req.body?.sector === 'All' ? ['Primary', 'Secondary', 'Tertiary'] : [req.body?.sector];
        let answer = await Hirerarchi.aggregate([
            {
                $match: {
                    supervisorchoose: req?.body?.username, // Match supervisorchoose with username
                    level: { $in: levelFinal }, // Corrected unmatched quotation mark
                },
            },
            {
                $lookup: {
                    from: 'reportingheaders', // The name of the collection to join with
                    let: {
                        teamControlsArray: {
                            $ifNull: ['$pagecontrols', []],
                        }, // Ensure 'teamcontrols' is an array or default to an empty array
                    },
                    pipeline: [
                        {
                            $match: {
                                $expr: {
                                    $and: [
                                        {
                                            $in: ['$name', '$$teamControlsArray'],
                                        }, // Check if 'name' is in 'teamcontrols' array
                                        {
                                            $in: [
                                                req?.body?.pagename,
                                                '$reportingnew', // Check if 'menuteamloginstatus' is in 'reportingnew' array
                                            ],
                                        }, // Additional condition for reportingnew array
                                    ],
                                },
                            },
                        },
                    ],
                    as: 'reportData', // The resulting matched documents will be in this field
                },
            },
            {
                $project: {
                    supervisorchoose: 1,
                    employeename: 1,
                    reportData: 1,
                },
            },
        ]);
        let restrictList = answer?.filter((data) => data?.reportData?.length > 0)?.flatMap((Data) => Data?.employeename);

        // Manager Condition Without Supervisor
        const HierarchySupervisorFind = await Hirerarchi.find({ supervisorchoose: req?.body?.username });
        DataAccessMode = req.body.role?.some(role => role.toLowerCase() === "manager") && HierarchySupervisorFind?.length === 0;
        const { uniqueNames, pageControlsData } = await Hierarchyfilter(levelFinal, req?.body?.pagename);



        result = await User.find(
            {
                enquirystatus: {
                    $nin: ['Enquiry Purpose'],
                },
                resonablestatus: {
                    $nin: ['Not Joined', 'Postponed', 'Rejected', 'Closed', 'Releave Employee', 'Absconded', 'Hold', 'Terminate'],
                },
                ...(listpageaccessmode === 'Reporting to Based' ? { reportingto: req.body.username } : {}),
            },
            {
                empcode: 1,
                companyname: 1,
                username: 1,
                branch: 1,
                unit: 1,
                designation: 1,
                team: 1,
                department: 1,
                company: 1,
                extratime: 1,
                extrastatus: 1,
                extradate: 1,
                wfhcount: 1,
                wfhstatus: 1,
                loginUserStatus: 1,
                workstation: 1,
                workstationshortname: 1,
                workstationinput: 1,
            }
        );

        // Accordig to sector and list filter process
        hierarchyFilter = await Hirerarchi.find({ level: req.body.sector });
        userFilter = hierarchyFilter.filter((data) => data.supervisorchoose.includes(req.body.username)).map((data) => data.employeename);

        hierarchyDefList = await Hirerarchi.find();
        user = await User.find({ companyname: req.body.username });
        const userFilt = user.length > 0 && user[0].designation;
        const desiGroup = await Designation.find();
        let HierarchyFilt = req.body.sector === 'all' ? hierarchyDefList.filter((data) => data.supervisorchoose.includes(req.body.username)).map((data) => data.designationgroup) : hierarchyFilter.filter((data) => data.supervisorchoose.includes(req.body.username)).map((data) => data.designationgroup);
        const DesifFilter = desiGroup.filter((data) => HierarchyFilt.includes(data.group));
        const desigName = DesifFilter.length > 0 && DesifFilter[0].name;
        const SameDesigUser = HierarchyFilt.includes('All') ? true : userFilt === desigName;
        //Default Loading of List
        answerDef = hierarchyDefList.filter((data) => data.supervisorchoose.includes(req.body.username)).map((data) => data.employeename);

        hierarchyFinal = req.body.sector === 'all' ? (answerDef.length > 0 ? [].concat(...answerDef) : []) : hierarchyFilter.length > 0 ? [].concat(...userFilter) : [];

        hierarchyMap = hierarchyFinal.length > 0 ? hierarchyFinal : [];

        //solo
        ans1D = req.body.sector === 'all' ? (answerDef.length > 0 ? hierarchyDefList.filter((data) => data.supervisorchoose.includes(req.body.username)) : []) : hierarchyFilter.length > 0 ? hierarchyFilter.filter((data) => data.supervisorchoose.includes(req.body.username)) : [];
        result1 =
            ans1D.length > 0
                ? result
                    .map((item1) => {
                        const matchingItem2 = ans1D.find((item2) => item2.employeename.includes(item1.companyname));

                        if (matchingItem2) {
                            const plainItem1 = item1.toObject ? item1.toObject() : item1;
                            return {
                                ...plainItem1,
                                level: req.body.sector + '-' + matchingItem2.control,
                            };
                            //   return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                        }
                    })
                    .filter((item) => item !== undefined)
                : [];

        resulted = result1;

        //team
        let branches = [];
        hierarchySecond = await Hirerarchi.find();

        const subBranch =
            hierarchySecond.length > 0
                ? hierarchySecond
                    .filter((item) => item.supervisorchoose.some((name) => hierarchyMap.includes(name)))
                    .map((item) => item.employeename)
                    .flat()
                : '';

        const answerFilterExcel = hierarchySecond.length > 0 ? hierarchySecond.filter((item) => item.supervisorchoose.some((name) => hierarchyMap.includes(name))) : [];

        result2 =
            answerFilterExcel.length > 0
                ? result
                    .map((item1) => {
                        const matchingItem2 = answerFilterExcel.find((item2) => item2.employeename.includes(item1.companyname));
                        if (matchingItem2) {
                            // If a match is found, inject the control property into the corresponding item in an1
                            const plainItem1 = item1.toObject ? item1.toObject() : item1;
                            return {
                                ...plainItem1,
                                level: req.body.sector + '-' + matchingItem2.control,
                            };
                            // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                        }
                    })
                    .filter((item) => item !== undefined)
                : [];
        branches.push(...subBranch);

        const ans =
            subBranch.length > 0
                ? hierarchySecond
                    .filter((item) => item.supervisorchoose.some((name) => subBranch.includes(name)))
                    .map((item) => item.employeename)
                    .flat()
                : '';
        const answerFilterExcel2 = subBranch.length > 0 ? hierarchySecond.filter((item) => item.supervisorchoose.some((name) => subBranch.includes(name))) : [];

        result3 =
            answerFilterExcel2.length > 0
                ? result
                    .map((item1) => {
                        const matchingItem2 = answerFilterExcel2.find((item2) => item2.employeename.includes(item1.companyname));
                        if (matchingItem2) {
                            const plainItem1 = item1.toObject ? item1.toObject() : item1;
                            return {
                                ...plainItem1,
                                level: req.body.sector + '-' + matchingItem2.control,
                            };
                            // If a match is found, inject the control property into the corresponding item in an1
                            // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                        }
                    })
                    .filter((item) => item !== undefined)
                : [];
        branches.push(...ans);

        const loop3 =
            ans.length > 0
                ? hierarchySecond
                    .filter((item) => item.supervisorchoose.some((name) => ans.includes(name)))
                    .map((item) => item.employeename)
                    .flat()
                : '';

        const answerFilterExcel3 = ans.length > 0 ? hierarchySecond.filter((item) => item.supervisorchoose.some((name) => ans.includes(name))) : [];

        result4 =
            answerFilterExcel3.length > 0
                ? result
                    .map((item1) => {
                        const matchingItem2 = answerFilterExcel3?.find((item2) => item2.employeename.includes(item1.companyname));
                        if (matchingItem2) {
                            const plainItem1 = item1.toObject ? item1.toObject() : item1;
                            return {
                                ...plainItem1,
                                level: req.body.sector + '-' + matchingItem2.control,
                            };
                            // If a match is found, inject the control property into the corresponding item in an1
                            // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                        }
                    })
                    .filter((item) => item !== undefined)
                : [];
        branches.push(...loop3);

        const loop4 =
            loop3.length > 0
                ? hierarchySecond
                    .filter((item) => item.supervisorchoose.some((name) => loop3.includes(name)))
                    .map((item) => item.employeename)
                    .flat()
                : [];
        const answerFilterExcel4 = loop3.length > 0 ? hierarchySecond.filter((item) => item.supervisorchoose.some((name) => loop3.includes(name))) : [];
        result5 =
            answerFilterExcel4.length > 0
                ? result
                    .map((item1) => {
                        const matchingItem2 = answerFilterExcel4?.find((item2) => item2.employeename.includes(item1.companyname));
                        if (matchingItem2) {
                            const plainItem1 = item1.toObject ? item1.toObject() : item1;
                            return {
                                ...plainItem1,
                                level: req.body.sector + '-' + matchingItem2.control,
                            };
                            // If a match is found, inject the control property into the corresponding item in an1
                            // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                        }
                    })
                    .filter((item) => item !== undefined)
                : [];
        branches.push(...loop4);

        const loop5 =
            loop4.length > 0
                ? hierarchySecond
                    .filter((item) => item.supervisorchoose.some((name) => loop4.includes(name)))
                    .map((item) => item.employeename)
                    .flat()
                : '';
        const answerFilterExcel5 = loop4.length > 0 ? hierarchySecond.filter((item) => item.supervisorchoose.some((name) => loop4.includes(name))) : [];
        result6 =
            answerFilterExcel5.length > 0
                ? result
                    .map((item1) => {
                        const matchingItem2 = answerFilterExcel5?.find((item2) => item2.employeename.includes(item1.companyname));
                        if (matchingItem2) {
                            const plainItem1 = item1.toObject ? item1.toObject() : item1;
                            return {
                                ...plainItem1,
                                level: req.body.sector + '-' + matchingItem2.control,
                            };
                            // If a match is found, inject the control property into the corresponding item in an1
                            // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                        }
                    })
                    .filter((item) => item !== undefined)
                : [];
        branches.push(...loop5);

        resultedTeam = [...result2, ...result3, ...result4, ...result5, ...result6];
        //overall Teams List
        myallTotalNames = DataAccessMode ? uniqueNames : [...hierarchyMap, ...branches];


        const finalResult = await User.find(
            {
                companyname: { $in: myallTotalNames },
                enquirystatus: {
                    $nin: ['Enquiry Purpose'],
                },
                resonablestatus: {
                    $nin: ['Not Joined', 'Postponed', 'Rejected', 'Closed', 'Releave Employee', 'Absconded', 'Hold', 'Terminate'],
                },
                ...(listpageaccessmode === 'Reporting to Based' ? { reportingto: req.body.username } : {}),
            },
            {
                empcode: 1,
                companyname: 1,
                username: 1,
                branch: 1,
                unit: 1,
                designation: 1,
                team: 1,
                department: 1,
                company: 1,
                extratime: 1,
                extrastatus: 1,
                extradate: 1,
                wfhcount: 1,
                wfhstatus: 1,
                loginUserStatus: 1,
                workstation: 1,
                workstationshortname: 1,
                workstationinput: 1,
            }
        );
        overallMyallList = [...resulted, ...resultedTeam];

        const restrictTeam = await Hirerarchi.aggregate([
            {
                $match: {
                    supervisorchoose:
                        { $in: myallTotalNames }, // Match supervisorchoose with username
                    level: { $in: levelFinal } // Corrected unmatched quotation mark
                }
            },
            {
                $lookup: {
                    from: "reportingheaders",
                    let: {
                        teamControlsArray: {
                            $ifNull: ["$pagecontrols", []]
                        }
                    },
                    pipeline: [
                        {
                            $match: {
                                $expr: {
                                    $and: [
                                        {
                                            $in: [
                                                "$name",
                                                "$$teamControlsArray"
                                            ]
                                        }, // Check if 'name' is in 'teamcontrols' array
                                        {
                                            $in: [
                                                req?.body?.pagename,
                                                "$reportingnew" // Check if 'menuteamloginstatus' is in 'reportingnew' array
                                            ]
                                        } // Additional condition for reportingnew array
                                    ]
                                }
                            }
                        }
                    ],
                    as: "reportData" // The resulting matched documents will be in this field
                }
            },
            {
                $project: {
                    supervisorchoose: 1,
                    employeename: 1,
                    reportData: 1
                }
            }
        ]);

        let restrictListTeam = DataAccessMode ? pageControlsData : restrictTeam?.filter(data => data?.reportData?.length > 0)?.flatMap(Data => Data?.employeename)
        let overallRestrictList = DataAccessMode ? restrictListTeam :
            (req.body.hierachy === "myhierarchy" ? restrictList :
                req.body.hierachy === "allhierarchy" ? restrictListTeam
                    : [...restrictList, ...restrictListTeam]);



        let resultAccessFiltered = DataAccessMode ? finalResult : (
            req.body.hierachy === 'myhierarchy' && (listpageaccessmode === 'Hierarchy Based' || listpageaccessmode === 'Overall')
                ? resulted
                : req.body.hierachy === 'allhierarchy' && (listpageaccessmode === 'Hierarchy Based' || listpageaccessmode === 'Overall')
                    ? resultedTeam
                    : req.body.hierachy === 'myallhierarchy' && (listpageaccessmode === 'Hierarchy Based' || listpageaccessmode === 'Overall')
                        ? overallMyallList
                        : result);

        resultAccessFilter = overallRestrictList?.length > 0 ? resultAccessFiltered?.filter((data) => overallRestrictList?.includes(data?.companyname)) : [];
    } catch (err) {
        return next(new ErrorHandler('Records not found!', 404));
    }
    return res.status(200).json({
        result,
        ans1D,
        result1,
        resulted,
        resultedTeam,
        branch,
        hierarchy,
        overallMyallList,
        resultAccessFilter,
        hierarchyFilter,
        user,
        dataCheck,
        userFilter,
        resultArray,
        DataAccessMode
    });
});






exports.getAllUsersnewFilter = catchAsyncErrors(async (req, res, next) => {

    const { companyname, branchname, unitname, teamname, employeename } = req.body;

    let users;
    const filter = {

        enquirystatus: {
            $nin: ["Enquiry Purpose"],
        },
        resonablestatus: {
            $nin: [
                "Not Joined",
                "Postponed",
                "Rejected",
                "Closed",
                "Releave Employee",
                "Absconded",
                "Hold",
                "Terminate",
            ],
        },

        ...(companyname && Array.isArray(companyname) && companyname.length > 0 ? { company: { $in: companyname } } : companyname ? { company: companyname } : {}),
        ...(branchname && Array.isArray(branchname) && branchname.length > 0 ? { branch: { $in: branchname } } : {}),
        ...(unitname && Array.isArray(unitname) && unitname.length > 0 ? { unit: { $in: unitname } } : {}),
        ...(teamname && Array.isArray(teamname) && teamname.length > 0 ? { team: { $in: teamname } } : {}),
        ...(employeename && Array.isArray(employeename) && employeename.length > 0 ? { companyname: { $in: employeename } } : {}),

    }

    try {
        users = await User.find(filter);
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: users.length, users });
});


// get All user => /api/users
exports.getAllUsersWithXEmployee = catchAsyncErrors(async (req, res, next) => {
    let users;

    try {
        users = await User.find(
            {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
            },
            {
                status: 1,
                resonablestatus: 1,
                reasonname: 1,
                rejoin: 1,
                reasonablestatusremarks: 1,
                department: 1,
                departmentlog: 1,
                dob: 1,
                gender: 1,
                maritalstatus: 1,
                bloodgroup: 1,
                loginUserStatus: 1,
                location: 1,
                contactpersonal: 1,
                panno: 1,
                aadhar: 1,
                designationlog: 1,
                contactfamily: 1,
                ctaluk: 1,
                dom: 1,
                processlog: 1,
                boardingLog: 1, attendancemode: 1,
                company: 1,
                reasondate: 1,
                empreason: 1,
                percentage: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                username: 1,
                usernameautogenerate: 1,
                workmode: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,

                unit: 1,
                branch: 1,
                designation: 1,
                floor: 1,
                shift: 1,
                reportingto: 1,
                experience: 1,
                doj: 1,
                dot: 1,
                bankname: 1,
                bankbranchname: 1,
                accountholdername: 1,
                accountnumber: 1,
                ifsccode: 1,
                shifttiming: 1,
                shiftgrouping: 1,
                legalname: 1,
                callingname: 1,
                pdoorno: 1,
                pstreet: 1,
                candidateid: 1,
                parea: 1,
                plandmark: 1,
                ptaluk: 1,
                ppost: 1,
                ppincode: 1,
                pcountry: 1,
                pstate: 1,
                pcity: 1,
                cdoorno: 1,
                cstreet: 1,
                carea: 1,
                role: 1,
                clandmark: 1,
                ctaluk: 1,
                cpost: 1,
                cpincode: 1,
                ccountry: 1,
                cstate: 1,
                ccity: 1,
                reasondate: 1,
                process: 1,
                workstation: 1,
                weekoff: 1,
                originalpassword: 1,
                enquirystatus: 1,
                area: 1,
                enableworkstation: 1,
                wordcheck: 1,
                shiftallot: 1,
                firstname: 1,
                lastname: 1,
                employeecount: 1,
                emergencyno: 1,
                name: 1,
                salarysetup: 1,
                mode: 1,
                salarycode: 1,
                basic: 1,
                hra: 1,
                conveyance: 1,
                medicalallowance: 1,
                productionallowance: 1,
                otherallowance: 1,
                productionallowancetwo: 1,
                pffromdate: 1,
                pfenddate: 1,
                esifromdate: 1,
                esienddate: 1,
                pfesistatus: 1,
                resonablestatus: 1,
                reasonname: 1,
                department: 1,
                dob: 1,
                location: 1,
                bloodgroup: 1,
                gender: 1,
                maritalstatus: 1,
                lastname: 1,
                contactpersonal: 1,
                processlog: 1,
                boardingLog: 1, attendancemode: 1,
                designationlog: 1,
                company: 1,
                reasondate: 1,
                empreason: 1,
                percentage: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                floor: 1,
                username: 1,
                usernameautogenerate: 1,
                workmode: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,

                unit: 1,
                branch: 1,
                designation: 1,
                team: 1,
                bankdetails: 1,
                shift: 1,
                reportingto: 1,
                experience: 1,
                doj: 1,
                role: 1,
                bankname: 1,
                bankbranchname: 1,
                accountholdername: 1,
                accountnumber: 1,
                ifsccode: 1,
                shifttiming: 1,
                shiftgrouping: 1,
                legalname: 1,
                callingname: 1,
                pdoorno: 1,
                pstreet: 1,
                parea: 1,
                plandmark: 1,
                ptaluk: 1,
                ppost: 1,
                ppincode: 1,
                pcountry: 1,
                pstate: 1,
                pcity: 1,
                cdoorno: 1,
                cstreet: 1,
                carea: 1,
                clandmark: 1,
                ctaluk: 1,
                cpost: 1,
                cpincode: 1,
                ccountry: 1,
                cstate: 1,
                ccity: 1,
                reasondate: 1,
                process: 1,
                workstation: 1,
                weekoff: 1,
                originalpassword: 1,
                enquirystatus: 1,
                area: 1,
                enableworkstation: 1,
                wordcheck: 1,
                shiftallot: 1,
                twofaenabled: 1,
                fathername: 1,
                mothername: 1,
                firstname: 1,
                workstationinput: 1,
                emergencyno: 1,
                referencetodo: 1,
                contactno: 1,
                details: 1,
                assignExpLog: 1,
                grosssalary: 1,
                timemins: 1,
                modeexperience: 1,
                targetexperience: 1,
                targetpts: 1,
                expval: 1,
                expmode: 1,
                process: 1,
                processtype: 1,
                processduration: 1,
                duration: 1,
                workstationofficestatus: 1,
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: users.length, users });
});

exports.getAllNotInEmployees = catchAsyncErrors(async (req, res, next) => {
    let allinterns;

    try {
        allinterns = await User.find(
            {
                resonablestatus: {
                    $in: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                },
            },
            {
                status: 1,
                percentage: 1,
                empcode: 1,
                nexttime: 1,
                companyname: 1,
                username: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,

                branch: 1,
                unit: 1,
                team: 1,
                company: 1,
                shift: 1,
                experience: 1,
                doj: 1,
                dot: 1,
                workmode: 1,
                internstatus: 1,
                resonablestatus: 1,
                department: 1,
                reasondate: 1,
                reportingto: 1,
                reasonname: 1,
                rejoin: 1,
                reasonablestatusremarks: 1,
            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!allinterns) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: allinterns.length, allinterns });
});


exports.deleteUsersShiftAllot = catchAsyncErrors(async (req, res, next) => {
    const { outerId, innerId } = req.body;
    try {
        // Find the user and remove the shiftallot object with the matching innerId
        const user = await User.findOneAndUpdate(
            { _id: outerId },
            {
                $pull: { shiftallot: { _id: innerId } }
            },
            { new: true } // Return the updated document
        );
        if (!user) {
            return next(new ErrorHandler("Data not found!", 404));
        }
        return res.status(200).json({ message: "Deleted successfully" });
    } catch (error) {
        return next(new ErrorHandler(error.message, 500));
    }
});


exports.employeeCodeAutogenerate = async (req, res) => {
    try {
        const { company, branch, doj, branchcode } = req.body;

        // Extract date in YYMMDD format
        const formattedDate = new Date(doj);
        const year = String(formattedDate.getFullYear()).slice(-2); // last two digits of year
        const month = String(formattedDate.getMonth() + 1).padStart(2, "0"); // zero-padded month
        const day = String(formattedDate.getDate()).padStart(2, "0"); // zero-padded day
        const dateString = `${year}${month}${day}`;

        // Get SettingsCode for the specific branch and company
        let overallsettings = await AdminOverAllSettings.findOne().sort({
            createdAt: -1,
        });
        let SettingsCode = overallsettings?.todos?.find(
            (data) => data?.company === company && data?.branch?.includes(branch)
        )?.empcodedigits;

        // Fetch the last employee based on branch and company with certain status and empcode starting with branchcode


        const users = await User.aggregate([
            {
                $match: {
                    branch,
                    company,
                    wordcheck: { $eq: false },
                    workmode: { $ne: "Internship" },
                    empcode: {
                        $regex: `^${branchcode.toUpperCase()}`, // Match empcode starting with branchcode
                        $not: /INT/ // Exclude empcodes containing "INT"
                    },
                },
            },
            {
                $addFields: {
                    empcodeLength: { $strLenCP: "$empcode" }, // Calculate the length of empcode
                },
            },
            {
                $match: {
                    empcodeLength: { $lte: 13 }, // Skip users where empcode length is greater than 13
                },
            },
            {
                $addFields: {
                    numericPart: {
                        $toInt: { $substr: ["$empcode", 8, -1] }, // Extract the numeric part after the first 8 characters
                    },
                },
            },
            {
                $sort: { numericPart: -1 }, // Sort by numeric part in descending order to get the greatest one
            },
            {
                $limit: 1, // Take the employee with the highest numeric part
            },
            {
                $project: {
                    empcode: 1,
                    numericPart: 1, // Include numericPart in the projection
                },
            },
        ]);

        // New employee code logic
        let newEmployeeCode, prevEmployeeCode;
        const settingsNumericPart = parseInt(SettingsCode, 10); // Parse SettingsCode

        if (users.length > 0) {
            // If employees exist, extract the last numeric portion of the empcode
            const lastEmployeeNumericPart = users[0].numericPart;
            prevEmployeeCode = users[0].numericPart;

            // Determine if we should use SettingsCode or last employee's numeric part
            if (
                settingsNumericPart - 1 >= lastEmployeeNumericPart &&
                overallsettings?.empdigits
            ) {
                // If SettingsCode is greater, increment from SettingsCode - 1
                const nextCode = String(settingsNumericPart + 1).padStart(
                    users[0].empcode.slice(8).length,
                    "0"
                ); // Ensure same length
                newEmployeeCode = `${branchcode.toUpperCase()}${dateString}${nextCode}`;
            } else {
                // Otherwise, increment from the last employee's numeric part
                const nextCode = String(lastEmployeeNumericPart + 1).padStart(
                    users[0].empcode.slice(8).length,
                    "0"
                ); // Ensure same length
                newEmployeeCode = `${branchcode.toUpperCase()}${dateString}${nextCode}`;
            }
        } else {
            // If no employees exist, start with SettingsCode or default to 001
            const startCode = settingsNumericPart ? settingsNumericPart : "001";
            newEmployeeCode = `${branchcode.toUpperCase()}${dateString}${startCode}`;
        }

        return res.status(200).json({
            employeeCode: newEmployeeCode,
            prevEmployeeCode: prevEmployeeCode,
        });
    } catch (err) {
        return res.status(500).json({ error: "Internal server error" });
    }
};

exports.internCodeAutogenerate = async (req, res) => {
    try {
        const { company, branch, doj, branchcode } = req.body;
        // Extract date in YYMMDD format
        const formattedDate = new Date(doj);
        const year = String(formattedDate.getFullYear()).slice(-2); // last two digits of year
        const month = String(formattedDate.getMonth() + 1).padStart(2, "0"); // zero-padded month
        const day = String(formattedDate.getDate()).padStart(2, "0"); // zero-padded day
        const dateString = `${year}${month}${day}`;



        // Fetch the last employee based on branch and company with certain status and empcode starting with branchcode
        const users = await User.aggregate([
            {
                $match: {
                    branch,
                    company,
                    wordcheck: { $eq: false },
                    workmode: { $eq: "Internship" },
                    empcode: { $regex: `^${branchcode.toUpperCase()}` }, // Match empcode starting with branchcode + dateString
                },
            },
            {
                $addFields: {
                    numericPart: {
                        $toInt: { $substr: ["$empcode", 11, -1] }, // Extract the numeric part after first 11 characters
                    },
                },
            },
            {
                $sort: { numericPart: -1 }, // Sort by numeric part in descending order to get the greatest one
            },
            {
                $limit: 1, // Take the employee with the highest numeric part
            },
            {
                $project: {
                    empcode: 1,
                    numericPart: 1, // include numericPart in the projection
                },
            },
        ]);
        // New employee code logic
        let newEmployeeCode, prevEmployeeCode;

        if (users.length > 0) {
            // If employees exist, extract the last numeric portion of the empcode
            const lastEmployeeNumericPart = users[0].numericPart;
            prevEmployeeCode = users[0].numericPart;

            // Otherwise, increment from the last employee's numeric part
            const nextCode = String(lastEmployeeNumericPart + 1).padStart(
                users[0].empcode.slice(11).length,
                "0"
            ); // Ensure same length
            newEmployeeCode = `${branchcode.toUpperCase()}INT${dateString}${nextCode}`;

        } else {
            // If no employees exist, start with SettingsCode or default to 001
            const startCode = "001";
            newEmployeeCode = `${branchcode.toUpperCase()}INT${dateString}${startCode}`;
        }
        return res.status(200).json({
            employeeCode: newEmployeeCode,
            prevEmployeeCode: prevEmployeeCode,
        });
    } catch (err) {
        return res.status(500).json({ error: "Internal server error" });
    }
};
exports.getFilteredUserForShiftAdjusment = catchAsyncErrors(async (req, res, next) => {
    let users;

    try {

        users = await User.find(
            {
                companyname: { $in: req.body.employee },
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
            }, {
            company: 1,
            branch: 1,
            unit: 1,
            team: 1,
            department: 1,
            doj: 1,
            empcode: 1,
            companyname: 1,
            team: 1,
            floor: 1,
            username: 1,
            designation: 1,
            weekoff: 1,
            shiftallot: 1,
            shifttiming: 1,
            boardingLog: 1, attendancemode: 1,
            reasondate: 1,
            departmentlog: 1,
        }
        );

    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ users });
});

exports.getAllEmployeesForAttendanceFilter = catchAsyncErrors(async (req, res, next) => {
    let users;
    const { company, branch, unit, team, employee, department, assignbranch } = req.body;
    try {

        let query = {
            company: { $in: company },
            branch: { $in: branch },
            unit: { $in: unit },
            enquirystatus: {
                $nin: ["Enquiry Purpose"],
            },
        };

        const accessquery = {
            $or: assignbranch.map(item => ({
                company: item.company,
                branch: item.branch,
                unit: item.unit,
            }))
        };

        // If team is provided, include the team in the condition
        if (team && team.length > 0) {
            query.$and = [
                { team: { $in: team } },
                {
                    $or: [
                        {
                            departmentlog: {
                                $elemMatch: {
                                    department: { $in: department }
                                }
                            }
                        },
                        { companyname: { $in: employee } }
                    ]
                }
            ];
        } else {
            // If team is not provided, just use department or employee condition
            query.$or = [
                {
                    departmentlog: {
                        $elemMatch: {
                            department: { $in: department }
                        }
                    }
                },
                { companyname: { $in: employee } }
            ];
        }

        const combinedQuery = {
            $and: [query, accessquery],
        };

        // Fetch users based on combined query
        users = await User.find(combinedQuery, {
            company: 1,
            branch: 1,
            unit: 1,
            team: 1,
            department: 1,
            doj: 1,
            empcode: 1,
            companyname: 1,
            team: 1,
            floor: 1,
            username: 1,
            designation: 1,
            weekoff: 1,
            shiftallot: 1,
            shifttiming: 1,
            boardingLog: 1,
            attendancemode: 1,
            reasondate: 1,
            departmentlog: 1,
        }
        );

    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ users });
});


exports.getAllEmployeesForAttendanceFilterIndividualType = catchAsyncErrors(async (req, res, next) => {
    const { type, company, branch, unit, team, employee, department, assignbranch } = req.body;
    let query = {
        company: { $in: company },
        enquirystatus: {
            $nin: ["Enquiry Purpose"],
        },
    }; const accessquery = {
        $or: assignbranch.map(item => ({
            company: item.company,
            branch: item.branch,
            unit: item.unit,
        }))
    }; try {
        switch (type) {
            case "Individual":
                query = {
                    branch: { $in: branch },
                    unit: { $in: unit },
                    team: { $in: team },
                    companyname: { $in: employee },
                };
                break; case "Company":
                query;
                break; case "Branch":
                query = {
                    branch: { $in: branch },
                };
                break; case "Unit":
                query = {
                    branch: { $in: branch },
                    unit: { $in: unit },
                };
                break; case "Team":
                query = {
                    branch: { $in: branch },
                    unit: { $in: unit },
                    team: { $in: team },
                };
                break; case "Department":
                query.$or = [
                    {
                        departmentlog: {
                            $elemMatch: {
                                department: { $in: department }
                            }
                        }
                    },
                    { companyname: { $in: employee } }
                ];
                break; default:
                return next(new ErrorHandler("Invalid filter type provided", 400));
        }        const combinedQuery = {
            $and: [query, accessquery],
        };        // Fetch users based on combined query
        const users = await User.find(combinedQuery, {
            company: 1,
            branch: 1,
            unit: 1,
            team: 1,
            department: 1,
            doj: 1,
            empcode: 1,
            companyname: 1,
            floor: 1,
            username: 1,
            designation: 1,
            weekoff: 1,
            shiftallot: 1,
            shifttiming: 1,
            boardingLog: 1,
            attendancemode: 1, attendancemodelog: 1,
            reasondate: 1,
            departmentlog: 1,
            designationlog: 1,
        }); return res.status(200).json({ users });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
});



exports.getAllUserClockinAndClockoutStatusAttModeBasedFilter = catchAsyncErrors(async (req, res, next) => {
    let graceTime, clockOutHours, clockInHours, lateclockincount, earlyclockoutcount, onclockout, earlyclockin, earlyclockout, lateclockin, afterlateclockin, beforeearlyclockout, mergedData;
    let finaluser = [];
    let mergedDataall = [];

    const { employee, fromdate, todate, montharray } = req.body;

    let query = {
        companyname: { $in: employee },
        enquirystatus: {
            $nin: ["Enquiry Purpose"],
        },
    }

    // Transform `result` to match MongoDB fields
    const queryConditions = montharray.map(item => ({
        monthname: item.month,
        year: item.year
    }));

    let logidQuery = {
        loginallotlog: { $exists: true, $ne: [] },
        empname: { $in: employee },
    };

    try {
        const [users, controlcriteria, depMonthSets, holidays, leavetype, attendenceControlCriteria, depMaster] = await Promise.all([
            User.find(query,
                { company: 1, branch: 1, unit: 1, team: 1, department: 1, doj: 1, dot: 1, empcode: 1, companyname: 1, floor: 1, username: 1, designation: 1, weekoff: 1, shiftallot: 1, shifttiming: 1, boardingLog: 1, attendancemode: 1, attendancemodelog: 1, role: 1, reasondate: 1, departmentlog: 1, designationlog: 1, resonablestatus: 1, workmode: 1 }
            ),
            ControlCriteria.find(),
            DepartmentMonth.find({ $or: queryConditions }, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 }),
            Holiday.find({}, { date: 1, company: 1, applicablefor: 1, unit: 1, team: 1, employee: 1, noofdays: 1 }),
            Leavetype.find({}, { leavetype: 1, code: 1 }),
            AttendanceControlCriteria.findOne().sort({ createdAt: -1 }).exec(),
            Department.find(),
        ])
        const userIds = users.map(user => user._id);
        const userCds = users.map(user => user.companyname);
        const userNames = users.map(user => user.username);

        const [attendances, allLeaveStatus, permission, eventstorages, loginids] = await Promise.all([
            Attendance.find({ userid: { $in: userIds } }),
            ApplyLeave.find({ employeename: { $in: userCds } }),
            Permission.find({ employeename: { $in: userCds } }, { employeeid: 1, date: 1, status: 1, applytype: 1, compensationstatus: 1, compensationapplytype: 1, requesthours: 1, shiftmode: 1, }),
            EventLog.find({ username: { $in: userNames }, status: { $eq: 'Matched' }, category: { $in: ['Login', 'Logoff'] } }, { category: 1, timestamp: 1, date: 1, time: 1, employeename: 1, empcode: 1, username: 1, }).lean(),
            ClientUserid.find(logidQuery, { empname: 1, userid: 1, projectvendor: 1, loginallotlog: 1 }).lean(),
        ]);

        // Get Domain Data
        // Step 1: Group events by username and date
        const grouped = {};

        eventstorages.forEach(event => {
            const key = `${event.username}_${event.date}`;
            if (!grouped[key]) {
                grouped[key] = [];
            }
            grouped[key].push(event);
        });

        // Step 2: Build the final output
        const finalEventStorages = Object.entries(grouped).map(([key, events]) => {
            const [username, date] = key.split('_');
            const loginData = events.find(e => e.category === 'Login');

            const loginTimes = events
                .filter(e => e.category === 'Login')
                .map(e => e.time)
                .sort(); // Ascending

            const logoffTimes = events
                .filter(e => e.category === 'Logoff')
                .map(e => e.time)
                .sort(); // Ascending

            const combinedLogin = new Date(`${date}T${loginTimes[0] || null}`);
            const formattedLoginTime = combinedLogin.toLocaleTimeString('en-US', {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: true,
            });

            const combinedLogoff = new Date(`${date}T${logoffTimes[logoffTimes.length - 1] || null}`);
            const formattedLogoffTime = combinedLogoff.toLocaleTimeString('en-US', {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: true,
            });

            return {
                employeename: loginData && loginData.employeename || null,
                empcode: loginData && loginData.empcode || null,
                username,
                date,
                clockintime: formattedLoginTime,
                clockouttime: formattedLogoffTime,
            };
        });

        // console.log(finalEventStorages);

        const leavecriterias = await Leavecriteria.find({ leavetype: 'No Call/No Show' }, { mode: 1, company: 1, branch: 1, unit: 1, team: 1, employee: 1, designation: 1, department: 1, leavetype: 1, tookleave: 1 });

        finaluserbefore = users?.flatMap((item) => {

            let isEmployeeGrace = controlcriteria[0].todos && controlcriteria[0].todos.find(d => d.company === item.company &&
                d.branch === item.branch && d.unit === item.unit && d.team === item.team &&
                d.employeename === item.companyname
            )

            if (isEmployeeGrace) {
                graceTime = isEmployeeGrace.employeegracetime;
            }

            let userDates = [];

            // Remove duplicate entries with the most recent entry
            const uniqueEntriesDep = {};
            item.departmentlog?.forEach(entry => {
                const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                const key = entry.startdate;
                if (!(key in uniqueEntriesDep)) {
                    uniqueEntriesDep[key] = entry;
                }
            });

            const uniqueDepLog = Object.values(uniqueEntriesDep);
            let relevantDepLogEntry = uniqueDepLog
                .filter(log => new Date(log.startdate) <= new Date(fromdate))
                .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

            if (!relevantDepLogEntry) {
                relevantDepLogEntry = uniqueDepLog
                    .filter(log => new Date(log.startdate) <= new Date(todate))
                    .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];
            }

            // Remove duplicate entries with the most recent entry
            const uniqueEntriesDesig = {};
            item?._doc?.designationlog?.forEach(entry => {
                const entryDate = new Date(entry.startdate);
                const key = entry.startdate;
                if (!(key in uniqueEntriesDesig)) {
                    uniqueEntriesDesig[key] = entry;
                }
            });

            const uniqueDesigLog = Object.values(uniqueEntriesDesig);

            // Find the relevant log entry for the given date     
            let relevantDesigLogEntry = uniqueDesigLog
                .filter(log => new Date(log.startdate) <= new Date(fromdate))
                .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

            if (relevantDesigLogEntry) {
                relevantDesigLogEntry = uniqueDesigLog
                    .filter(log => new Date(log.startdate) <= new Date(todate))
                    .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];
            }

            const comparedDate = depMonthSets?.filter((d) => d.department === (relevantDepLogEntry && relevantDepLogEntry?.department));

            let departmentDateSet = [];
            comparedDate.map(data => {
                departmentDateSet.push({ department: data.department, fromdate: data.fromdate, todate: data.todate });
            })
            // console.log(departmentDateSet, 'departmentDateSet')
            const dojDate = item?._doc?.boardingLog.length > 0 ?
                item?._doc?.boardingLog[0].startdate
                : item?._doc?.doj;

            if (comparedDate && comparedDate.length > 0) {
                comparedDate?.forEach((dep) => {
                    if (!dep.fromdate && !dep.todate) {
                        return '';
                    }

                    if (!item?._doc?.doj) {
                        return "";
                    }

                    const [year2, month2, day2] = dojDate?.split('-').map(Number);
                    const joiningDate = new Date(year2, month2 - 1, day2);
                    const [year1, month1, day1] = dep.fromdate?.split('-').map(Number);
                    const [year, month, day] = dep.todate?.split('-').map(Number);
                    const lastDate = new Date(year, month - 1, day);
                    const firstDate = new Date(year1, month1 - 1, day1);

                    if (joiningDate < firstDate) {
                        // If matched, push the range from 'fromdate' to 'todate'
                        const startDate = new Date(firstDate);
                        // Loop through the dates in the range
                        while (startDate <= lastDate) {
                            userDates.push({
                                formattedDate: format(startDate, 'dd/MM/yyyy'),
                                dayName: format(startDate, 'EEEE'),
                                dayCount: startDate.getDate(),
                                weekNumberInMonth: (getWeekNumberInMonth(startDate) === 1 ? `${getWeekNumberInMonth(startDate)}st Week` :
                                    getWeekNumberInMonth(startDate) === 2 ? `${getWeekNumberInMonth(startDate)}nd Week` :
                                        getWeekNumberInMonth(startDate) === 3 ? `${getWeekNumberInMonth(startDate)}rd Week` :
                                            getWeekNumberInMonth(startDate) > 3 ? `${getWeekNumberInMonth(startDate)}th Week` : '')
                            });
                            startDate.setDate(startDate.getDate() + 1);
                        }
                    } else {
                        // If matched, push the range from 'fromdate' to 'todate'
                        const startDate = new Date(joiningDate);
                        // Loop through the dates in the range
                        while (startDate <= lastDate) {
                            userDates.push({
                                formattedDate: format(startDate, 'dd/MM/yyyy'),
                                dayName: format(startDate, 'EEEE'),
                                dayCount: startDate.getDate(),
                                weekNumberInMonth: (getWeekNumberInMonth(startDate) === 1 ? `${getWeekNumberInMonth(startDate)}st Week` :
                                    getWeekNumberInMonth(startDate) === 2 ? `${getWeekNumberInMonth(startDate)}nd Week` :
                                        getWeekNumberInMonth(startDate) === 3 ? `${getWeekNumberInMonth(startDate)}rd Week` :
                                            getWeekNumberInMonth(startDate) > 3 ? `${getWeekNumberInMonth(startDate)}th Week` : '')
                            });
                            startDate.setDate(startDate.getDate() + 1);
                        }
                    }
                });
            }
            else {
                const [year2, month2, day2] = dojDate?.split('-').map(Number);
                const joiningDate = new Date(year2, month2 - 1, day2);

                // Calculate the start date of the month based on the selected month
                const startDate = new Date(fromdate);

                const endDate = new Date(startDate);
                endDate.setMonth(endDate.getMonth() + 1);
                endDate.setDate(endDate.getDate() - 1);

                if (joiningDate < startDate) {
                    // Check if the shift date is before or equal to the current date
                    if (endDate >= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            userDates.push({
                                formattedDate: format(currentDate1, 'dd/MM/yyyy'),
                                dayName: format(currentDate1, 'EEEE'),
                                dayCount: currentDate1.getDate(),
                                weekNumberInMonth: (getWeekNumberInMonth(currentDate1) === 1 ? `${getWeekNumberInMonth(currentDate1)}st Week` :
                                    getWeekNumberInMonth(currentDate1) === 2 ? `${getWeekNumberInMonth(currentDate1)}nd Week` :
                                        getWeekNumberInMonth(currentDate1) === 3 ? `${getWeekNumberInMonth(currentDate1)}rd Week` :
                                            getWeekNumberInMonth(currentDate1) > 3 ? `${getWeekNumberInMonth(currentDate1)}th Week` : '')
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    } else if (endDate <= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            userDates.push({
                                formattedDate: format(currentDate1, 'dd/MM/yyyy'),
                                dayName: format(currentDate1, 'EEEE'),
                                dayCount: currentDate1.getDate(),
                                weekNumberInMonth: (getWeekNumberInMonth(currentDate1) === 1 ? `${getWeekNumberInMonth(currentDate1)}st Week` :
                                    getWeekNumberInMonth(currentDate1) === 2 ? `${getWeekNumberInMonth(currentDate1)}nd Week` :
                                        getWeekNumberInMonth(currentDate1) === 3 ? `${getWeekNumberInMonth(currentDate1)}rd Week` :
                                            getWeekNumberInMonth(currentDate1) > 3 ? `${getWeekNumberInMonth(currentDate1)}th Week` : '')
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    }
                } else {
                    // Check if the shift date is before or equal to the current date
                    if (endDate >= currentDateAttStatus) {
                        // If matched, push the range from 'fromdate' to 'todate'
                        const startDate = new Date(joiningDate);
                        // Loop through the dates in the range
                        while (startDate <= currentDateAttStatus) {
                            userDates.push({
                                formattedDate: format(startDate, 'dd/MM/yyyy'),
                                dayName: format(startDate, 'EEEE'),
                                dayCount: startDate.getDate(),
                                weekNumberInMonth: (getWeekNumberInMonth(startDate) === 1 ? `${getWeekNumberInMonth(startDate)}st Week` :
                                    getWeekNumberInMonth(startDate) === 2 ? `${getWeekNumberInMonth(startDate)}nd Week` :
                                        getWeekNumberInMonth(startDate) === 3 ? `${getWeekNumberInMonth(startDate)}rd Week` :
                                            getWeekNumberInMonth(startDate) > 3 ? `${getWeekNumberInMonth(startDate)}th Week` : '')
                            });
                            startDate.setDate(startDate.getDate() + 1);
                        }
                    } else if (endDate <= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            userDates.push({
                                formattedDate: format(currentDate1, 'dd/MM/yyyy'),
                                dayName: format(currentDate1, 'EEEE'),
                                dayCount: currentDate1.getDate(),
                                weekNumberInMonth: (getWeekNumberInMonth(currentDate1) === 1 ? `${getWeekNumberInMonth(currentDate1)}st Week` :
                                    getWeekNumberInMonth(currentDate1) === 2 ? `${getWeekNumberInMonth(currentDate1)}nd Week` :
                                        getWeekNumberInMonth(currentDate1) === 3 ? `${getWeekNumberInMonth(currentDate1)}rd Week` :
                                            getWeekNumberInMonth(currentDate1) > 3 ? `${getWeekNumberInMonth(currentDate1)}th Week` : '')
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    }
                }
            }

            // console.log(userDates, 'userDates')
            const filteredMatchingDoubleShiftItem = item.shiftallot?.filter(val => val && val?._doc?.empcode === item?._doc?.empcode && val?._doc?.adjstatus === 'Approved');

            // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
            let uniqueEntries = new Set();

            // Iterate over removedUserDates and add unique entries to the Set
            userDates?.forEach(date => {
                uniqueEntries.add(JSON.stringify({
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    shiftMode: 'Main Shift',
                    weekNumberInMonth: date.weekNumberInMonth
                }));
            });

            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach(item => {
                const [day, month, year] = item._doc.adjdate?.split('/')
                let newFormattedDate = new Date(`${year}-${month}-${day}`);

                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(JSON.stringify({
                        formattedDate: item._doc.adjdate,
                        dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
                        dayCount: parseInt(moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")),
                        shiftMode: 'Second Shift',
                        weekNumberInMonth: (getWeekNumberInMonth(newFormattedDate) === 1 ? `${getWeekNumberInMonth(newFormattedDate)}st Week` :
                            getWeekNumberInMonth(newFormattedDate) === 2 ? `${getWeekNumberInMonth(newFormattedDate)}nd Week` :
                                getWeekNumberInMonth(newFormattedDate) === 3 ? `${getWeekNumberInMonth(newFormattedDate)}rd Week` :
                                    getWeekNumberInMonth(newFormattedDate) > 3 ? `${getWeekNumberInMonth(newFormattedDate)}th Week` : '')
                    }));
                }
            });

            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries)?.map(entry => JSON.parse(entry));

            function sortUserDates(dates) {
                return dates.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);
            const createdUserDates = sortedCreatedUserDates?.filter(d => {
                const filterData = userDates.some(val => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date) => {
                let filteredRowData = item.shiftallot?.filter((val) => val?._doc?.empcode == item?._doc?.empcode);
                const matchingItem = filteredRowData?.find(item => item && item?._doc?.adjdate == date.formattedDate);
                const matchingItemAllot = filteredRowData?.find(item => item && formatDate(item?._doc?.date) == date.formattedDate);
                const matchingDoubleShiftItem = filteredRowData?.find(item => item && item?._doc?.todate === date.formattedDate);
                const matchingRemovedItem = filteredRowData?.find(item => item?._doc?.removedshiftdate === date.formattedDate);
                const matchingAssignShiftItem = filteredRowData?.find(item => item?._doc?.adjdate === date.formattedDate && item?._doc?.adjstatus === 'Approved' && item?._doc?.adjustmenttype === 'Assign Shift');

                const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                });

                // const uniqueDepLog = Object.values(uniqueEntriesDep);
                const [columnDay, columnMonth, columnYear] = date.formattedDate?.split('/');
                const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

                const depMonthSet = depMonthSets.filter(d => d.department === (relevantDepLogEntry && relevantDepLogEntry?.department));

                //production Data
                const userids = loginids.filter((login) => login.loginallotlog.some((d) => d.empname === item.companyname)).map((data) => data.userid);

                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item?._doc?.weekoff?.includes(date.dayName);
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                // Remove duplicate entries with the most recent entry
                const uniqueEntriesAtt = {};
                controlcriteria[0].attendancetimelog?.forEach(entry => {
                    const key = entry.startdate;
                    if (!(key in uniqueEntriesAtt)) {
                        uniqueEntriesAtt[key] = entry;
                    }
                });

                const uniqueAttLog = Object.values(uniqueEntriesAtt);
                let relevantAttLogEntry = uniqueAttLog
                    .filter(log => new Date(log.startdate) <= new Date(finalDate))
                    .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

                clockOutHours = relevantAttLogEntry ? relevantAttLogEntry.clockout : controlcriteria[0].clockout;
                clockInHours = relevantAttLogEntry ? relevantAttLogEntry.clockin : controlcriteria[0].clockin;

                // Convert 12-hour format with AM/PM to 24-hour format
                function convertTo24Hour(timeStr) {
                    let match = timeStr && timeStr.match(/^(\d{1,2}):?(\d{2})?\s*([APap][Mm])$/);

                    if (!match) return null;

                    let [_, hours, minutes, modifier] = match;
                    hours = parseInt(hours, 10);
                    minutes = minutes ? parseInt(minutes, 10) : 0;

                    if (modifier.toLowerCase() === "pm" && hours !== 12) {
                        hours += 12;
                    }
                    if (modifier.toLowerCase() === "am" && hours === 12) {
                        hours = 0;
                    }

                    return `${String(hours).padStart(2, "0")}:${String(minutes).padStart(2, "0")}:00`;
                }

                function convertToDateTime(timeRange, dateStr) {
                    let [startTimeStr, endTimeStr] = timeRange.split("to").map(t => t.trim());
                    let [day, month, year] = dateStr.split("/").map(n => n.trim());

                    // Convert to a proper date format
                    let formattedDate = `${year}-${month}-${day}`;
                    let startTime = new Date(`${formattedDate}T${convertTo24Hour(startTimeStr)}`);
                    let endTime = new Date(`${formattedDate}T${convertTo24Hour(endTimeStr)}`);

                    let orgStartTime = new Date(`${formattedDate}T${convertTo24Hour(startTimeStr)}`);
                    let orgEndTime = new Date(`${formattedDate}T${convertTo24Hour(endTimeStr)}`);
                    // console.log(moment(startTime).format("DD-MM-YYYY hh:mm a"), endTime, 'Parsed startTime and endTime');

                    if (isNaN(startTime) || isNaN(endTime)) {
                        // console.error("Invalid date format");
                        return null;
                    }


                    // Handle cases where endTime is on the next day
                    if (endTime <= startTime) {
                        endTime.setDate(endTime.getDate() + 1);
                    }
                    if (orgEndTime <= orgStartTime) {
                        orgEndTime.setDate(orgEndTime.getDate() + 1);
                    }

                    startTime.setHours(startTime.getHours() - Number(clockInHours));
                    endTime.setHours(endTime.getHours() + Number(clockOutHours));
                    return { startTime, endTime, orgStartTime, orgEndTime, date: moment(startTime).format("DD-MM-YYYY"), formattedStartTime: moment(startTime).format("DD-MM-YYYY hh:mm a"), formattedEndTime: moment(endTime).format("DD-MM-YYYY hh:mm a") };
                }

                const userShiftTime = getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem);
                const combinedStart = moment(`${finalDate} ${userShiftTime?.split('to')[0]}`, 'YYYY-MM-DD hh:mm:ss A').format('YYYY-MM-DDTHH:mm:ss');
                const combinedEnd = moment(`${finalDate} ${userShiftTime?.split('to')[1]}`, 'YYYY-MM-DD hh:mm:ss A').format('YYYY-MM-DDTHH:mm:ss');

                const row = {
                    id: `${item?._doc?._id.toString()}_${date.formattedDate}_${date.shiftMode}`,
                    userid: item?._doc?._id.toString(),
                    company: item?._doc?.company,
                    branch: item?._doc?.branch,
                    unit: item?._doc?.unit,
                    team: item?._doc?.team,
                    department: (relevantDepLogEntry && relevantDepLogEntry?.department),
                    designation: (relevantDesigLogEntry && relevantDesigLogEntry?.designation),
                    companyname: item?._doc?.companyname,
                    username: item?._doc?.companyname,
                    rowusername: item?._doc?.username,
                    role: item?._doc?.role,
                    empcode: item?._doc?.empcode,
                    weekoff: item?._doc?.weekoff,
                    boardingLog: item?._doc?.boardingLog,
                    shiftallot: item?._doc?.shiftallot,
                    doj: dojDate,
                    shift: userShiftTime,
                    shiftdate: userShiftTime ? convertToDateTime(userShiftTime, date.formattedDate) : "",
                    date: `${date.formattedDate} ${date.dayName} ${date.dayCount}`,
                    rowformattedDate: date.formattedDate,
                    finalDate: finalDate,
                    dayName: date.dayName,
                    shiftMode: date.shiftMode,
                    reasondate: item?._doc?.reasondate,
                    resonablestatus: item?._doc?.resonablestatus,
                    attendancemode: item?._doc?.attendancemode,
                    attendancemodelog: item?._doc?.attendancemodelog,
                    departmentDateSet: departmentDateSet,
                    userids: userids,
                    shiftFromTime: combinedStart,
                    shiftEndTime: combinedEnd,
                    // createdUserDates: createdUserDates,
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    weekNumberInMonth: date.weekNumberInMonth,
                    workmode: item?._doc?.workmode,
                };

                return row;
            });

            return userRows;

        });

        // console.log(finaluserbefore.filter(data => data.formattedDate === '24/05/2025'))

        // To get production for single date
        let startMonthDateMinus = new Date(req.body.fromdate);
        let startdate = startMonthDateMinus.setDate(startMonthDateMinus.getDate() - 1);
        let startMonthDate = new Date(startdate);

        let firstDate = new Date(req.body.todate);
        let enddate = firstDate.setDate(firstDate.getDate() + 2);
        let endMonthDate = new Date(enddate);

        const daysArray = [];
        while (startMonthDate <= endMonthDate) {
            const formattedDate = `${String(startMonthDate.getDate()).padStart(2, "0")}/${String(startMonthDate.getMonth() + 1).padStart(2, "0")}/${startMonthDate.getFullYear()}`;
            const dayName = startMonthDate.toLocaleDateString("en-US", {
                weekday: "long",
            });
            const dayCount = startMonthDate.getDate();
            const shiftMode = "Main Shift";
            const weekNumberInMonth =
                getWeekNumberInMonth(startMonthDate) === 1
                    ? `${getWeekNumberInMonth(startMonthDate)}st Week`
                    : getWeekNumberInMonth(startMonthDate) === 2
                        ? `${getWeekNumberInMonth(startMonthDate)}nd Week`
                        : getWeekNumberInMonth(startMonthDate) === 3
                            ? `${getWeekNumberInMonth(startMonthDate)}rd Week`
                            : getWeekNumberInMonth(startMonthDate) > 3
                                ? `${getWeekNumberInMonth(startMonthDate)}th Week`
                                : "";

            daysArray.push({
                formattedDate,
                dayName,
                dayCount,
                shiftMode,
                weekNumberInMonth,
            });

            // Move to the next day
            startMonthDate.setDate(startMonthDate.getDate() + 1);
        }
        // console.log(daysArray)
        let dateoneafter = new Date(req.body.todate);
        dateoneafter.setDate(dateoneafter.getDate() + 1);
        let newDateOnePlus = dateoneafter.toISOString().split('T')[0];

        let datebefore = new Date(req.body.fromdate);
        datebefore.setDate(datebefore.getDate() - 1);
        let newDateOneMinus = datebefore.toISOString().split("T")[0];

        let datebeforeoneBefore = new Date(req.body.fromdate);
        datebeforeoneBefore.setDate(datebeforeoneBefore.getDate() - 1);
        let newDateOneMinusOneBefore = datebeforeoneBefore.toISOString().split("T")[0];

        let dateoneaftertwoplus = new Date(req.body.todate);
        dateoneaftertwoplus.setDate(dateoneaftertwoplus.getDate() + 2);
        let newDateTwoPlus = dateoneaftertwoplus.toISOString().split("T")[0];

        let dayShiftBeforeHrs = attendenceControlCriteria && attendenceControlCriteria.dayactive && attendenceControlCriteria.dayactive == true ? Number(attendenceControlCriteria.calcshifthourday) : 4;
        let dayShiftBeforeMin = attendenceControlCriteria && attendenceControlCriteria.dayactive && attendenceControlCriteria.dayactive == true ? Number(attendenceControlCriteria.calcshiftminday) : 0;
        let nightShiftBeforeHrs = attendenceControlCriteria && attendenceControlCriteria.nightactive && attendenceControlCriteria.nightactive == true ? Number(attendenceControlCriteria.calcshifthournight) : 4;
        let nightShiftBeforeMin = attendenceControlCriteria && attendenceControlCriteria.nightactive && attendenceControlCriteria.nightactive == true ? Number(attendenceControlCriteria.calcshiftminnight) : 0;

        let dateSelectedFormat = moment(req.body.fromdate).format("DD/MM/YYYY");
        let dateSelectedFormatOnePlus = moment(newDateOnePlus).format("DD/MM/YYYY");
        let dateSelectedFormatOneMinus = moment(newDateOneMinus).format("DD/MM/YYYY");
        let dateSelectedFormatTwoPlus = moment(newDateTwoPlus).format("DD/MM/YYYY");

        let shiftEndTime = `${req.body.fromdate}T00:00:00.000Z`;
        let shiftFromTime = `${req.body.fromdate}T00:00:00.000Z`;

        const dateFilteredUsers = finaluserbefore?.filter(data => daysArray?.some(val => val.formattedDate === data.formattedDate));

        const filterMatchedUser = dateFilteredUsers
            ?.flatMap((item) => {
                let finaluserFiltered = dateFilteredUsers.filter((d) => d.shift != undefined && d.companyname === item.companyname);
                // console.log(finaluserFiltered, 'finaluserFiltered')
                function filterData(data) {
                    // console.log(data, dateSelectedFormatOneMinus, dateSelectedFormat, dateSelectedFormatOnePlus, 'data')
                    const previousEntry = data.find((d) => d.formattedDate === dateSelectedFormatOneMinus);
                    const firstEntry = data.find((d) => d.formattedDate === dateSelectedFormat);
                    const secondEntry = data.find((d) => d.formattedDate === dateSelectedFormatOnePlus);
                    const firstEntryDoubleShift = data.find((d) => d.formattedDate === dateSelectedFormat && d.shiftMode === "Second Shift" && d.shift != undefined);
                    const firstEntryDoubleShiftPM = data.find((d) => d.formattedDate === dateSelectedFormat && d.shiftMode === "Second Shift" && d.shift != undefined && d.shift.split("to")[0].includes("PM"));
                    const thirdEntry = data.find((d) => d.formattedDate === dateSelectedFormatTwoPlus);
                    // console.log(firstEntry, firstEntryDoubleShift, 'firstEntryDoubleShift');
                    const isBeforeDayDoubleShift = data.find((d) => d.formattedDate === dateSelectedFormatOneMinus && d.shiftMode === "Second Shift" && d.shift != undefined);
                    const isBeforeDayDoubleShiftPM = isBeforeDayDoubleShift && isBeforeDayDoubleShift.shift.split("to")[0].includes("PM");

                    // if (!firstEntry) return [];
                    const ispreviousShiftWeekoff = previousEntry && previousEntry.shift !== "" && previousEntry.shift == "Week Off";
                    const isFirstShiftWeekoff = firstEntry && firstEntry.shift !== "" && firstEntry.shift == "Week Off";
                    const isSecondShiftWeekoff = secondEntry && secondEntry.shift !== "" && secondEntry.shift == "Week Off";
                    const isFirstShiftPM = firstEntry && firstEntry.shift !== "" && firstEntry.shift != "Week Off" ? firstEntry.shift.split("to")[0].includes("PM") : "";
                    const isPreviousShiftPM = previousEntry && previousEntry.shift !== "" && previousEntry.shift != "Week Off" ? previousEntry.shift.split("to")[0].includes("PM") : "";
                    const isSecondShiftPM = secondEntry && secondEntry.shift !== "" && secondEntry.shift != "Week Off" ? secondEntry.shift.split("to")[0].includes("PM") : "";
                    // console.log(firstEntry,secondEntry, 'firstEntry');
                    const isMainShift = firstEntry && firstEntry.shiftMode === "Main Shift";
                    const isPlusShift = firstEntry && firstEntry.plusshift && firstEntry.plusshift != "";

                    function convertTo24Hour(time) {
                        // Remove any extra spaces or unexpected characters
                        time = time.trim();

                        // Use regular expression to capture time and AM/PM
                        const match = time.match(/^(\d{1,2}):(\d{2})(AM|PM)$/);
                        if (!match) return null; // Return null if the format is incorrect

                        let hours = parseInt(match[1], 10);
                        const minutes = match[2];
                        const period = match[3];

                        // Convert to 24-hour format
                        if (period === "PM" && hours < 12) {
                            hours += 12;
                        }
                        if (period === "AM" && hours === 12) {
                            hours = 0;
                        }

                        // Format the time as 'HH:MM'
                        return `${hours.toString().padStart(2, "0")}:${minutes}`;
                    }
                    if (isFirstShiftWeekoff && isSecondShiftWeekoff) {
                        let newFromTime = isPreviousShiftPM ? new Date(`${req.body.fromdate}T10:00:00Z`) : new Date(`${req.body.fromdate}T01:00:00Z`);
                        let newEndTime = isPreviousShiftPM ? new Date(`${newDateOnePlus}T${convertTo24Hour(previousEntry.shift.split("to")[0])}Z`) : new Date(`${newDateOnePlus}T${convertTo24Hour(previousEntry.shift.split("to")[0])}Z`);

                        let finalHrs = isPreviousShiftPM === "PM" ? nightShiftBeforeHrs : dayShiftBeforeHrs;
                        let finalMin = isPreviousShiftPM === "PM" ? nightShiftBeforeMin : dayShiftBeforeMin;
                        shiftEndTime = new Date(newEndTime.getTime() - (finalHrs * 60 * 60 * 1000 + (finalMin + 1) * 60 * 1000));
                        shiftFromTime = new Date(newFromTime.getTime() + 60 * 1000);

                        shiftEndTime = new Date(shiftEndTime.setSeconds(shiftEndTime.getSeconds() + 59));

                        data = { shiftFromTime, shiftEndTime, shift: firstEntry.shift };
                        // console.log(shiftFromTime, shiftEndTime, newFromTime, newEndTime, 'shiftFromTime111')
                    } else if (isFirstShiftWeekoff && ispreviousShiftWeekoff) {
                        let newFromTime = isPreviousShiftPM ? new Date(`${req.body.fromdate}T${convertTo24Hour(secondEntry.shift.split("to")[0])}Z`) : new Date(`${req.body.fromdate}T${convertTo24Hour(secondEntry.shift.split("to")[0])}Z`);
                        let newEndTime = isPreviousShiftPM ? new Date(`${newDateOnePlus}T${convertTo24Hour(secondEntry.shift.split("to")[0])}Z`) : new Date(`${newDateOnePlus}T${convertTo24Hour(secondEntry.shift.split("to")[0])}Z`);

                        let finalHrs = isPreviousShiftPM === "PM" ? nightShiftBeforeHrs : dayShiftBeforeHrs;
                        let finalMin = isPreviousShiftPM === "PM" ? nightShiftBeforeMin : dayShiftBeforeMin;
                        shiftEndTime = new Date(newEndTime.getTime() - (finalHrs * 60 * 60 * 1000 + finalMin * 60 * 1000));
                        shiftFromTime = new Date(newFromTime.getTime() - (finalHrs * 60 * 60 * 1000 + finalMin * 60 * 1000));

                        shiftEndTime = new Date(shiftEndTime.setSeconds(shiftEndTime.getSeconds() - 1));

                        data = { shiftFromTime, shiftEndTime, shift: firstEntry.shift, };
                        // console.log(shiftFromTime, shiftEndTime, newFromTime, newEndTime, 'shiftFromTime111')
                    } else if (isFirstShiftWeekoff) {
                        let newFromTime = isPreviousShiftPM ? new Date(`${req.body.fromdate}T10:00:00Z`) : new Date(`${req.body.fromdate}T01:00:00Z`);
                        let newEndTime = isPreviousShiftPM ? new Date(`${newDateOnePlus}T${convertTo24Hour(secondEntry.shift.split("to")[0])}Z`) : new Date(`${newDateOnePlus}T${convertTo24Hour(secondEntry.shift.split("to")[0])}Z`);

                        let finalHrs = isPreviousShiftPM === "PM" ? nightShiftBeforeHrs : dayShiftBeforeHrs;
                        let finalMin = isPreviousShiftPM === "PM" ? nightShiftBeforeMin : dayShiftBeforeMin;
                        shiftEndTime = new Date(newEndTime.getTime() - (finalHrs * 60 * 60 * 1000 + (finalMin + 1) * 60 * 1000));
                        shiftFromTime = new Date(newFromTime.getTime() + 60 * 1000);

                        shiftEndTime = new Date(shiftEndTime.setSeconds(shiftEndTime.getSeconds() + 59));

                        data = { shiftFromTime, shiftEndTime, shift: firstEntry.shift, };
                        // console.log(shiftFromTime, shiftEndTime, newFromTime, newEndTime, 'shiftFromTime')
                    } else if (isSecondShiftWeekoff) {
                        let newFromTime = isFirstShiftPM ? new Date(`${req.body.fromdate}T${convertTo24Hour(firstEntry.shift.split("to")[0])}Z`) : new Date(`${req.body.fromdate}T${convertTo24Hour(firstEntry.shift.split("to")[0])}Z`);
                        let newEndTime = isFirstShiftPM ? new Date(`${newDateOnePlus}T10:00:00Z`) : new Date(`${newDateOnePlus}T01:00:00Z`);

                        let finalHrs = isPreviousShiftPM === "PM" ? nightShiftBeforeHrs : dayShiftBeforeHrs;
                        let finalMin = isPreviousShiftPM === "PM" ? nightShiftBeforeMin : dayShiftBeforeMin;
                        shiftEndTime = new Date(newEndTime);
                        shiftFromTime = new Date(newFromTime.getTime() - (finalHrs * 60 * 60 * 1000 + finalMin * 60 * 1000));
                        shiftEndTime = new Date(shiftEndTime.setSeconds(shiftEndTime.getSeconds() + 59));

                        data = { shiftFromTime, shiftEndTime, shift: firstEntry.shift, };
                        // console.log(shiftFromTime, shiftEndTime, newFromTime, newEndTime, 'shiftFromTimesec')
                    } else if (firstEntryDoubleShift && secondEntry.shift === "Not Allotted") {
                        // return data.filter(entry => [dateSelectedFormat, dateSelectedFormatOnePlus].includes(entry.date) && entry.shiftMode === "Main Shift");
                        let newFromTime = isFirstShiftPM ? new Date(`${req.body.fromdate}T${convertTo24Hour(firstEntry.shift.split("to")[0])}Z`) : new Date(`${req.body.fromdate}T${convertTo24Hour(firstEntry.shift.split("to")[0])}Z`);
                        let newEndTime = isFirstShiftPM ? new Date(`${newDateOnePlus}T${convertTo24Hour(firstEntryDoubleShift.shift.split("to")[0])}Z`) : new Date(`${req.body.fromdate}T${convertTo24Hour(firstEntryDoubleShift.shift.split("to")[0])}Z`);

                        let newFromTimeSecondShift = isFirstShiftPM ? new Date(`${newDateOnePlus}T${convertTo24Hour(firstEntryDoubleShift.shift.split("to")[0])}Z`) : new Date(`${req.body.fromdate}T${convertTo24Hour(firstEntryDoubleShift.shift.split("to")[0])}Z`);
                        let newEndTimeSecondShift = isFirstShiftPM ? new Date(`${newDateOnePlus}T${convertTo24Hour(firstEntryDoubleShift.shift.split("to")[1])}Z`) : new Date(`${newDateOnePlus}T${convertTo24Hour(firstEntryDoubleShift.shift.split("to")[1])}Z`);

                        const finalHrs = isPreviousShiftPM === "PM" ? nightShiftBeforeHrs : dayShiftBeforeHrs;
                        const finalMin = isPreviousShiftPM === "PM" ? nightShiftBeforeMin : dayShiftBeforeMin;
                        shiftFromTime = new Date(newFromTime.getTime() - (finalHrs * 60 * 60 * 1000 + finalMin * 60 * 1000));

                        shiftEndTime = new Date(newEndTime.getTime() - (finalHrs * 60 * 60 * 1000 + (finalMin + 1) * 60 * 1000));
                        shiftEndTime = new Date(shiftEndTime.setSeconds(shiftEndTime.getSeconds() + 59));

                        let shiftEndTimeFirstShift = newEndTime;

                        const shiftFromTimeSecondShift = new Date(newFromTimeSecondShift.setSeconds(newFromTimeSecondShift.getSeconds() + 1));
                        let shiftEndTimeSecondShift = new Date(newEndTimeSecondShift);
                        // shiftEndTimeSecondShift = new Date(shiftEndTimeSecondShift.setSeconds(shiftEndTimeSecondShift.getSeconds() + 59));

                        // console.log(shiftFromTime, shiftEndTime, firstEntry.shift.split("to")[1], 'shiftFromTimesec')
                        data = [
                            { shiftFromTime, shiftEndTime: shiftEndTimeFirstShift, shift: firstEntry.shift, },
                            { shiftFromTime: shiftFromTimeSecondShift, shiftEndTime: shiftEndTimeSecondShift, shift: firstEntryDoubleShift.shift, },
                        ];
                    } else if (firstEntryDoubleShift && secondEntry.shift != "Not Allotted") {
                        // return data.filter(entry => [dateSelectedFormat, dateSelectedFormatOnePlus].includes(entry.date) && entry.shiftMode === "Main Shift");
                        let newFromTime = isFirstShiftPM ? new Date(`${req.body.fromdate}T${convertTo24Hour(firstEntry.shift.split("to")[0])}Z`) : new Date(`${req.body.fromdate}T${convertTo24Hour(firstEntry.shift.split("to")[0])}Z`);
                        let newEndTime = firstEntryDoubleShiftPM ? new Date(`${newDateOnePlus}T${convertTo24Hour(firstEntryDoubleShift.shift.split("to")[0])}Z`) : new Date(`${newDateOnePlus}T${convertTo24Hour(firstEntryDoubleShift.shift.split("to")[0])}Z`);

                        let newFromTimeSecondShift = isFirstShiftPM ? new Date(`${newDateOnePlus}T${convertTo24Hour(firstEntryDoubleShift.shift.split("to")[0])}Z`) : new Date(`${req.body.fromdate}T${convertTo24Hour(firstEntryDoubleShift.shift.split("to")[0])}Z`);
                        let newEndTimeSecondShift = isSecondShiftPM ? new Date(`${newDateOnePlus}T${convertTo24Hour(secondEntry.shift.split("to")[0])}Z`) : new Date(`${newDateOnePlus}T${convertTo24Hour(secondEntry.shift.split("to")[0])}Z`);

                        const finalHrs = isPreviousShiftPM === "PM" ? nightShiftBeforeHrs : dayShiftBeforeHrs;
                        const finalMin = isPreviousShiftPM === "PM" ? nightShiftBeforeMin : dayShiftBeforeMin;
                        shiftFromTime = new Date(newFromTime.getTime() - (finalHrs * 60 * 60 * 1000 + finalMin * 60 * 1000));

                        shiftEndTime = new Date(newEndTime.getTime() - (finalHrs * 60 * 60 * 1000 + (finalMin + 1) * 60 * 1000));
                        shiftEndTime = new Date(shiftEndTime.setSeconds(shiftEndTime.getSeconds() + 59));

                        let shiftEndTimeSecondShift = new Date(newEndTimeSecondShift.getTime() - (finalHrs * 60 * 60 * 1000 + (finalMin + 1) * 60 * 1000));
                        shiftEndTimeSecondShift = new Date(shiftEndTimeSecondShift.setSeconds(shiftEndTimeSecondShift.getSeconds() + 59));

                        let shiftEndTimeFirstShift = newEndTime;

                        const shiftFromTimeSecondShift = new Date(newFromTimeSecondShift.setSeconds(newFromTimeSecondShift.getSeconds() + 1));
                        //  let shiftEndTimeFirstShift = newEndTime;

                        //   const shiftFromTimeSecondShift = new Date(newFromTimeSecondShift.setSeconds(newFromTimeSecondShift.getSeconds() + 1));
                        //   let shiftEndTimeSecondShift = new Date(newEndTimeSecondShift);
                        // shiftEndTimeSecondShift = new Date(shiftEndTimeSecondShift.setSeconds(shiftEndTimeSecondShift.getSeconds() + 59));

                        // console.log(shiftFromTime, shiftEndTime, firstEntry.shift.split("to")[1], 'shiftFromTimesec')
                        data = [
                            { shiftFromTime, shiftEndTime: shiftEndTimeFirstShift, shift: firstEntry.shift, },
                            { shiftFromTime: shiftFromTimeSecondShift, shiftEndTime: shiftEndTimeSecondShift, shift: firstEntryDoubleShift.shift, },
                        ];
                    } else if (isBeforeDayDoubleShift && firstEntry.shift === "Not Allotted" && secondEntry) {
                        // return data.filter(entry => [dateSelectedFormat, dateSelectedFormatOnePlus].includes(entry.date) && entry.shiftMode === "Main Shift");
                        let newFromTime = isBeforeDayDoubleShiftPM ? new Date(`${req.body.fromdate}T${convertTo24Hour(isBeforeDayDoubleShift.shift.split("to")[1])}Z`) : new Date(`${req.body.fromdate}T${convertTo24Hour(isBeforeDayDoubleShift.shift.split("to")[1])}Z`);
                        let newEndTime = isBeforeDayDoubleShiftPM ? new Date(`${newDateOnePlus}T${convertTo24Hour(secondEntry.shift.split("to")[0])}Z`) : new Date(`${newDateOnePlus}T${convertTo24Hour(secondEntry.shift.split("to")[0])}Z`);

                        let finalHrs = isPreviousShiftPM === "PM" ? nightShiftBeforeHrs : dayShiftBeforeHrs;
                        let finalMin = isPreviousShiftPM === "PM" ? nightShiftBeforeMin : dayShiftBeforeMin;
                        shiftEndTime = new Date(newEndTime.getTime() - (finalHrs * 60 * 60 * 1000 + (finalMin + 1) * 60 * 1000));
                        // shiftFromTime = new Date(newFromTime.getTime() - (finalHrs * 60 * 60 * 1000 + finalMin * 60 * 1000));
                        shiftFromTime = new Date(newFromTime.getTime() + 60 * 1000);
                        shiftFromTime = new Date(shiftFromTime.setSeconds(shiftFromTime.getSeconds() - 59));

                        shiftEndTime = new Date(shiftEndTime.setSeconds(shiftEndTime.getSeconds() + 59));

                        // console.log(shiftFromTime, shiftEndTime,  firstEntry.shift.split("to")[1], 'shiftFromTimesec')
                        data = { shiftFromTime, shiftEndTime, shift: "Not Allot", };
                    } else if (firstEntry.shift === "Not Allotted" && secondEntry && previousEntry) {
                        // return data.filter(entry => [dateSelectedFormat, dateSelectedFormatOnePlus].includes(entry.date) && entry.shiftMode === "Main Shift");
                        let newFromTime = isPreviousShiftPM ? new Date(`${req.body.fromdate}T${convertTo24Hour(previousEntry.shift.split("to")[1])}Z`) : new Date(`${newDateOneMinus}T${convertTo24Hour(previousEntry.shift.split("to")[1])}Z`);
                        let newEndTime = isSecondShiftPM ? new Date(`${newDateOnePlus}T${convertTo24Hour(secondEntry.shift.split("to")[0])}Z`) : new Date(`${newDateOnePlus}T${convertTo24Hour(secondEntry.shift.split("to")[0])}Z`);

                        let finalHrs = isPreviousShiftPM === "PM" ? nightShiftBeforeHrs : dayShiftBeforeHrs;
                        let finalMin = isPreviousShiftPM === "PM" ? nightShiftBeforeMin : dayShiftBeforeMin;
                        shiftEndTime = new Date(newEndTime.getTime() - (finalHrs * 60 * 60 * 1000 + (finalMin + 1) * 60 * 1000));
                        // shiftFromTime = new Date(newFromTime.getTime() - (finalHrs * 60 * 60 * 1000 + finalMin * 60 * 1000));
                        shiftFromTime = new Date(newFromTime.getTime() + 60 * 1000);
                        shiftFromTime = new Date(shiftFromTime.setSeconds(shiftFromTime.getSeconds() - 59));

                        shiftEndTime = new Date(shiftEndTime.setSeconds(shiftEndTime.getSeconds() + 59));

                        // console.log(shiftFromTime, shiftEndTime, firstEntry.shift.split("to")[1], 'shiftFromTimesec')
                        data = { shiftFromTime, shiftEndTime, shift: "Not Allot", };
                    } else if (firstEntry && secondEntry.shift === "Not Allotted") {
                        // console.log("secondshiftnotallot")
                        // return data.filter(entry => [dateSelectedFormat, dateSelectedFormatOnePlus].includes(entry.date) && entry.shiftMode === "Main Shift");
                        let newFromTime = isFirstShiftPM ? new Date(`${req.body.fromdate}T${convertTo24Hour(firstEntry.shift.split("to")[0])}Z`) : new Date(`${req.body.fromdate}T${convertTo24Hour(firstEntry.shift.split("to")[0])}Z`);
                        let newEndTime = isFirstShiftPM ? new Date(`${newDateOnePlus}T${convertTo24Hour(firstEntry.shift.split("to")[1])}Z`) : new Date(`${req.body.fromdate}T${convertTo24Hour(firstEntry.shift.split("to")[1])}Z`);

                        let finalHrs = isPreviousShiftPM === "PM" ? nightShiftBeforeHrs : dayShiftBeforeHrs;
                        let finalMin = isPreviousShiftPM === "PM" ? nightShiftBeforeMin : dayShiftBeforeMin;
                        // shiftEndTime = new Date(newEndTime.getTime() - (finalHrs * 60 * 60 * 1000 + (finalMin + 1) * 60 * 1000));
                        shiftFromTime = new Date(newFromTime.getTime() - (finalHrs * 60 * 60 * 1000 + finalMin * 60 * 1000));

                        // shiftEndTime = new Date(shiftEndTime.setSeconds(shiftEndTime.getSeconds() + 59));
                        shiftEndTime = newEndTime;

                        // console.log(shiftFromTime, shiftEndTime,  firstEntry.shift.split("to")[1], 'shiftFromTimesec')
                        data = { shiftFromTime, shiftEndTime, shift: firstEntry.shift, };
                    } else if (firstEntry && secondEntry) {
                        // console.log("thislastelseif")
                        // return data.filter(entry => [dateSelectedFormat, dateSelectedFormatOnePlus].includes(entry.date) && entry.shiftMode === "Main Shift");
                        let newFromTime = isFirstShiftPM ? new Date(`${req.body.fromdate}T${convertTo24Hour(firstEntry.shift.split("to")[0])}Z`) : new Date(`${req.body.fromdate}T${convertTo24Hour(firstEntry.shift.split("to")[0])}Z`);
                        let newEndTime = isFirstShiftPM ? new Date(`${newDateOnePlus}T${convertTo24Hour(secondEntry.shift.split("to")[0])}Z`) : new Date(`${newDateOnePlus}T${convertTo24Hour(secondEntry.shift.split("to")[0])}Z`);

                        let finalHrs = isPreviousShiftPM === "PM" ? nightShiftBeforeHrs : dayShiftBeforeHrs;
                        let finalMin = isPreviousShiftPM === "PM" ? nightShiftBeforeMin : dayShiftBeforeMin;
                        shiftEndTime = new Date(newEndTime.getTime() - (finalHrs * 60 * 60 * 1000 + (finalMin + 1) * 60 * 1000));
                        shiftFromTime = new Date(newFromTime.getTime() - (finalHrs * 60 * 60 * 1000 + finalMin * 60 * 1000));

                        shiftEndTime = new Date(shiftEndTime.setSeconds(shiftEndTime.getSeconds() + 59));

                        // console.log(shiftFromTime, shiftEndTime, firstEntry.shift.split("to")[1], 'shiftFromTimesec')
                        data = { shiftFromTime, shiftEndTime, shift: firstEntry.shift, };
                    } else {
                        data = { shiftFromTime: new Date(shiftFromTime), shiftEndTime: new Date(shiftEndTime), };
                    }

                    return data; // Return the original data if conditions are not met
                }

                userShiftTimings = finaluserFiltered.length >= 3 ? filterData(finaluserFiltered) : { shiftFromTime: new Date(shiftFromTime), shiftEndTime: new Date(shiftEndTime) };

                if (finaluserFiltered.find((d) => d.formattedDate === dateSelectedFormat && d.shiftMode === "Second Shift" && d.shift != undefined)) {
                    return [
                        {
                            ...item,
                            shift: userShiftTimings[0]?.shift,
                            shiftFromTime: userShiftTimings[0]?.shiftFromTime,
                            shiftEndTime: userShiftTimings[0]?.shiftEndTime,
                        },
                        {
                            ...item,
                            shift: userShiftTimings[1]?.shift,
                            shiftFromTime: userShiftTimings[1]?.shiftFromTime,
                            shiftEndTime: userShiftTimings[1]?.shiftEndTime,
                        },
                    ];
                } else {
                    return {
                        ...item,
                        shift: userShiftTimings.shift,
                        shiftFromTime: userShiftTimings.shiftFromTime,
                        shiftEndTime: userShiftTimings.shiftEndTime,
                    };
                }
            })
            .sort((a, b) => new Date(a.shiftFromTime) - new Date(b.shiftFromTime));

        // console.log(filterMatchedUser.length, 'filterMatchedUser')

        const { minStart, maxEnd } = filterMatchedUser
            .filter((d) => d.shiftFromTime && d.shiftFromTime !== '')
            .reduce(
                (acc, obj) => {
                    // console.log(obj.shiftFromTime, obj.shiftEndTime)
                    const startTime = new Date(obj.shiftFromTime);
                    const endTime = new Date(obj.shiftEndTime);

                    // console.log('Comparing:', startTime, endTime);

                    // Update minimum start time
                    if (!acc.minStart || startTime < acc.minStart) {
                        acc.minStart = startTime;
                    }

                    // Update maximum end time
                    if (!acc.maxEnd || endTime > acc.maxEnd) {
                        acc.maxEnd = endTime;
                    }

                    return acc;
                },
                { minStart: null, maxEnd: null } // Proper initialization
            );

        let queryManual = {};
        let queryprod = {};

        queryManual.$or = [{ fromdate: { $eq: req.body.fromdate } }, { fromdate: { $eq: newDateOnePlus } }];

        queryprod.dateobjformatdate = { $gte: minStart, $lte: maxEnd };
        // console.log(queryprod.dateobjformatdate, 'query');

        const [producionIndividual, productionupload] = await Promise.all([
            ProducionIndividual.find(queryManual, {
                user: 1, fromdate: 1, time: 1, filename: 1, vendor: 1, mode: 1, category: 1, section: 1, unitid: 1, lateentrystatus: 1, updatedunitrate: 1, updatedflag: 1, updatedsection: 1, unallotcategory: 1, unallotsubcategory: 1,
            }).lean(),
            ProductionUpload.find(queryprod, {
                unitid: 1, user: 1, formatteddate: 1, formattedtime: 1, filenameupdated: 1, category: 1, flagcount: 1, vendor: 1, unitrate: 1, updatedunitrate: 1, updatedflag: 1, unallotcategory: 1, unallotsubcategory: 1,
            }).lean(),
        ]);

        let allData = [...producionIndividual, ...productionupload];
        // console.log(allData.length, 'allData 14053')

        function compareDateTimes(dateT, shiftFrom, shiftEnd) {
            // Parse the datetime strings into Date objects
            const dateTimeObj = new Date(dateT);
            const shiftFromTimeObj = new Date(shiftFrom);
            const shiftEndTimeObj = new Date(shiftEnd);
            // Perform the comparisons
            const isWithinShift = dateTimeObj >= shiftFromTimeObj && dateTimeObj <= shiftEndTimeObj;

            return isWithinShift;
        }

        let logs = loginids.flatMap((user) =>
            user.loginallotlog.map((log) => ({
                userid: user.userid,
                projectvendor: user.projectvendor,
                date: log.date,
                time: log.time,
                empname: log.empname,
                empcode: log.empcode,
                enddate: log.enddate ? log.enddate : null,
            }))
        );

        // Step 2: Sort logs by date and time (ascending order)
        logs.sort((a, b) => {
            if (a.date === b.date) {
                return a.time.localeCompare(b.time);
            }
            return new Date(a.date) - new Date(b.date);
        });

        // Step 3: Calculate the enddate for each log (except the last log for each userid)
        const userLogsMap = {};
        logs.forEach((log) => {
            if (!userLogsMap[log.userid]) {
                userLogsMap[log.userid] = {};
            }

            if (!userLogsMap[log.userid][log.projectvendor]) {
                userLogsMap[log.userid][log.projectvendor] = [];
            }

            userLogsMap[log.userid][log.projectvendor].push(log);
        });

        Object.values(userLogsMap).forEach((userLogs) => {
            Object.values(userLogs).forEach((logsArray) => {
                logsArray.forEach((log, idx) => {
                    if (idx < logsArray.length - 1) {
                        log.enddate = logsArray[idx + 1].date;
                    }
                });
            });
        });
        // Step 4: Filter logs based on input date
        const filteredLogs = logs.filter((log) => {
            return new Date(log.date) <= new Date(req.body.fromdate) && (!log.enddate || new Date(log.enddate) >= new Date(req.body.fromdate));
        });

        // Step 5: Sort the filtered logs by date and time (descending order)
        filteredLogs.sort((a, b) => {
            if (a.date === b.date) {
                return b.time.localeCompare(a.time);
            }
            return new Date(b.date) - new Date(a.date);
        });
        // console.log(filteredLogs, 'filteredLogs')

        let mergedDataallfirst = allData.map((upload, index) => {
            const loginInfo = filteredLogs.filter((login) => login.userid === upload.user && login.projectvendor === upload.vendor);

            let loginallot = loginInfo ? loginInfo : [];

            let filteredDataDateTime = null;

            if (loginallot.length > 0) {
                const groupedByDateTime = {};

                loginallot.forEach((item) => {
                    const dateTime = item.date + ' ' + item.time;
                    if (!groupedByDateTime[dateTime]) {
                        groupedByDateTime[dateTime] = [];
                    }
                    groupedByDateTime[dateTime].push(item);
                });

                // Extract the last item of each group
                const lastItemsForEachDateTime = Object.values(groupedByDateTime).map((group) => group[group.length - 1]);

                // Sort the last items by date and time
                lastItemsForEachDateTime.sort((a, b) => {
                    return new Date(b.date + ' ' + b.time) - new Date(a.date + ' ' + a.time);
                });

                // Find the first item in the sorted array that meets the criteria
                for (let i = 0; i < lastItemsForEachDateTime.length; i++) {
                    const dateTime = `${lastItemsForEachDateTime[i].date}T${lastItemsForEachDateTime[i].time}Z`;
                    // let datevalsplit = upload.mode == "Manual" ? "" : upload.formatteddatetime.split(" ");
                    let datevalsplitfinal = upload.mode == 'Manual' ? `${upload.fromdate}T${uploadtime}Z` : `${upload.formatteddate}T${upload.formattedtime}Z`;
                    if (new Date(dateTime) <= new Date(datevalsplitfinal)) {
                        filteredDataDateTime = lastItemsForEachDateTime[i];
                    } else {
                        break;
                    }
                }
            }

            let logininfoname = loginallot.length > 0 && filteredDataDateTime && filteredDataDateTime.empname ? filteredDataDateTime.empname : loginInfo ? loginInfo.empname : '';

            // const filenamelistviewAll = upload.filename && upload.filename?.split(".x");
            const comparedate = upload.mode == "Manual" ? upload.fromdate : upload.formatteddate;
            const comparetime = upload.mode == "Manual" ? convertTo24HourFormat(upload.time) : upload.formattedtime;

            const dateTime = `${comparedate}T${comparetime}Z`;

            const userInfo = filterMatchedUser.find((user) => logininfoname === user.companyname && new Date(dateTime) >= new Date(user.shiftFromTime) && new Date(dateTime) <= new Date(user.shiftEndTime));

            const finalcategory = upload.unallotcategory ? upload.unallotcategory : upload.mode == 'Manual' ? upload.filename : upload.filenameupdated;

            const finalsubcategory = upload.unallotsubcategory ? upload.unallotsubcategory : upload.category;

            let finalunitrate = upload.updatedunitrate ? Number(upload.updatedunitrate) : Number(upload.unitrate);
            let finalflag = upload.updatedflag ? Number(upload.updatedflag) : Number(upload.flagcount);

            let LateEntryPointsDeduct = upload.mode == 'Manual' && upload.lateentrystatus === 'Late Entry';

            let unitrateold = Number(upload.unitrate);

            const resultDate = addTimeBasedOnDST(`${comparedate} ${comparetime}`);

            if (
                compareDateTimes(dateTime, userInfo && userInfo.shiftFromTime, userInfo && userInfo.shiftEndTime) &&
                (employee.includes(userInfo && userInfo?.companyname))
            ) {
                return {
                    user: upload.user,
                    fromdate: upload.fromdate,
                    todate: upload.todate,
                    vendor: upload.vendor,
                    category: finalsubcategory,
                    dateval: upload.mode === 'Manual' ? `${upload.fromdate} ${convertTo24HourFormat(upload.time)}` : `${upload.formatteddate} ${upload.formattedtime}`,
                    olddateval: upload.mode === 'Manual' ? `${upload.fromdate}T${convertTo24HourFormat(upload.time)}Z` : `${upload.formatteddate}T${upload.formattedtime}Z`,
                    filename: finalcategory,
                    mode: upload.mode === 'Manual' ? 'Manual' : 'Production',
                    section: upload.section,
                    flagcount: upload.flagcount,
                    unitrate: upload.unitrate,
                    csection: upload.updatedsection ? upload.updatedsection : '',
                    cflagcount: upload.updatedflag ? upload.updatedflag : '',
                    cunitrate: upload.updatedflag ? upload.updatedflag : '',
                    unitid: upload.unitid,
                    worktook: upload.worktook,
                    lateentry: LateEntryPointsDeduct,
                    points: LateEntryPointsDeduct ? 0 : (unitrateold * 8.333333333333333).toFixed(3),
                    cpoints: LateEntryPointsDeduct ? 0 : (finalunitrate * 8.333333333333333).toFixed(3),
                    totalpoints: LateEntryPointsDeduct ? 0 : (finalunitrate * finalflag * 8.333333333333333).toFixed(3),
                    cstist: String(resultDate),
                    date: upload.mode === 'Manual' ? upload.fromdate : upload.formatteddate,
                    time: upload.mode === 'Manual' ? convertTo24HourFormat(upload.time) : upload.formattedtime,
                    olddateval: upload.mode === 'Manual' ? `${upload.fromdate}T${convertTo24HourFormat(upload.time)}Z` : `${upload.formatteddate}T${upload.formattedtime}Z`,
                    empname: userInfo && userInfo.companyname,
                    empcode: userInfo && userInfo.empcode,
                    shifttiming: userInfo && userInfo.shift,
                    shiftmode: userInfo && userInfo.shiftMode,
                    username: userInfo && userInfo.rowusername,
                    userid: userInfo && userInfo.userid,
                    _id: upload._id,
                };
            }
        });

        mergedDataallfirst = mergedDataallfirst.filter((d) => d !== null && d !== undefined);

        mergedDataall = mergedDataallfirst.sort((a, b) => {
            // First sort by empname
            if (a.empname < b.empname) return -1;
            if (a.empname > b.empname) return 1;
            // If empnames are equal, sort by dateval
            //  return a.dateval.localeCompare(b.dateval);
            return new Date(a.olddateval) - new Date(b.olddateval);
        });
        // console.log(mergedDataall.length, 'data')

        const mergedDataallFinal = [];
        const lastTimes = {};
        const empFirstLastIndex = {};

        mergedDataall.forEach((item, idx) => {
            const key = `${item.empname}_${item.date}`;
            if (!empFirstLastIndex[key]) {
                empFirstLastIndex[key] = { first: idx, last: idx };
            } else {
                empFirstLastIndex[key].last = idx;
            }
        });

        function getTimeDifference(start, end, id) {
            if (start && end) {
                const startDate = new Date(start);
                const endDate = new Date(end);

                if (startDate > endDate) {
                    return '00:00:00';
                } else {
                    const diff = new Date(endDate - startDate);
                    return diff.toISOString().substr(11, 8);
                }
            }
        }

        // working 
        // Step 2: Loop through mergedDataall
        mergedDataall.forEach((item, idx) => {
            const key = `${item.empname}_${item.date}`;
            const indexInfo = empFirstLastIndex[key];

            const originalDatetime = item.dateval;
            const [finddate, findtime] = originalDatetime.split(' ');
            const formattedTimeshift = findtime;
            const clockindate = attendances.find((d) => {
                const [day, month, year] = d.date.split('-');
                const dateObject = new Date(year, month - 1, day);
                const formattedDateString = `${dateObject.getFullYear()}-${(dateObject.getMonth() + 1)
                    .toString()
                    .padStart(2, '0')}-${dateObject.getDate().toString().padStart(2, '0')}`;
                return formattedDateString === finddate && item.username === d.username;
            });

            const formattedTime = clockindate ? convertTo24HourFormat(clockindate.clockintime) : findtime;

            // let worktook = '';
            // let claimstatus = '';

            // // First record for the user-date
            // if (idx === indexInfo.first) {
            //     // claimstatus = 'first';
            //     if (!lastTimes[item.empname]) {
            //         lastTimes[item.empname] = formattedTime < findtime ? formattedTime : findtime;
            //     }
            //     worktook = getTimeDifference(`${finddate}T${lastTimes[item.empname]}Z`, `${finddate}T${findtime}Z`);
            // }
            // // Last record
            // else if (idx === indexInfo.last) {
            //     // claimstatus = 'last';
            //     const prevItem = mergedDataall[idx - 1];
            //     worktook = getTimeDifference(prevItem.dateval, item.dateval);
            // }
            // // Middle record (for completeness)
            // else {
            //     const prevItem = mergedDataall[idx - 1];
            //     worktook = getTimeDifference(prevItem.dateval, item.dateval);
            // }

            // // Only store first and last
            // if (idx === indexInfo.first || idx === indexInfo.last) {
            //     mergedDataallFinal.push({
            //         empname: item.empname,
            //         shiftmode: item.shiftmode,
            //         userid: item.userid,
            //         shifttiming: item.shifttiming,
            //         username: item.username,
            //         date: item.date,
            //         // time: findtime,
            //         time: item.time,
            //         claimstatus,
            //         worktook,
            //     });
            // }

            if (idx == 0 || item.empname !== mergedDataall[idx - 1].empname) {
                if (item) {
                    if (!lastTimes.hasOwnProperty(item.empname)) {
                        lastTimes[item.empname] = clockindate && formattedTime < formattedTimeshift ? formattedTime : formattedTimeshift;
                    }
                    item.claimstatus = "first";
                    item.worktook = getTimeDifference(`${finddate}T${lastTimes[item.empname]}Z`, `${finddate}T${findtime}Z`, '1');
                }
            } else if (item.empname == mergedDataall[idx - 1].empname) {
                item.worktook = getTimeDifference(mergedDataall[idx - 1].olddateval, item.olddateval, '2');
                if (idx === indexInfo.last) {
                    item.claimstatus = "last";
                }
            }
        });

        const clockinDiffMin = parseInt(attendenceControlCriteria.clockindifferencetime);
        const clockoutDiffMin = parseInt(attendenceControlCriteria.clockoutdifferencetime);

        const groupByEmpDate = {};

        function timeToSeconds(timeStr) {
            const [h, m, s] = timeStr.split(':').map(Number);
            return h * 3600 + m * 60 + s;
        }

        // Group data by empname + date
        mergedDataall.forEach((item) => {
            const key = `${item.empname}_${item.date}`;
            if (!groupByEmpDate[key]) groupByEmpDate[key] = [];
            groupByEmpDate[key].push(item);
        });

        // Iterate each emp-date group
        for (const key in groupByEmpDate) {
            const records = groupByEmpDate[key];
            const [empname, date] = key.split('_');
            const firstRecord = records.find(item => {
                const seconds = timeToSeconds(item.worktook);
                return seconds <= clockinDiffMin * 60;
            });

            const lastRecord = [...records].reverse().find(item => {
                const seconds = timeToSeconds(item.worktook);
                return seconds <= clockoutDiffMin * 60;
            });

            if (firstRecord) {
                mergedDataallFinal.push({
                    ...firstRecord,
                    claimstatus: 'first'
                });
            }

            if (lastRecord && (!firstRecord || lastRecord.dateval !== firstRecord.dateval)) {
                mergedDataallFinal.push({
                    ...lastRecord,
                    claimstatus: 'last'
                });
            }
        }

        // Get Production Data
        // Step 1: Group events by username and date
        const groupedProd = {};

        mergedDataallFinal.forEach(prod => {
            const key = `${prod.username}_${prod.date}`;
            if (!groupedProd[key]) {
                groupedProd[key] = [];
            }
            groupedProd[key].push(prod);
        });
        // console.log(mergedDataallFinal, 'mergedDataallFinal')
        // Step 2: Build the final output
        const finalProductions = Object.entries(groupedProd).map(([key, prod]) => {
            const [username, date] = key.split('_');
            const loginData = prod.find(e => e.claimstatus === 'first');
            const loginDataLast = prod.find(e => e.claimstatus === 'last');

            const loginTimes = prod
                .filter(e => e.claimstatus === 'first')
                .map(e => e.time)
                .sort(); // Ascending

            const logoffTimes = prod
                .filter(e => e.claimstatus === 'last')
                .map(e => e.time)
                .sort(); // Ascending

            const combinedLogin = new Date(`${date}T${loginTimes[0] || null}`);
            const formattedLoginTime = combinedLogin.toLocaleTimeString('en-US', {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: true,
            });

            const combinedLogoff = new Date(`${date}T${logoffTimes[logoffTimes.length - 1] || null}`);
            const formattedLogoffTime = combinedLogoff.toLocaleTimeString('en-US', {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: true,
            });

            return {
                shiftmode: loginData && loginData.shiftmode || null,
                userid: loginData && loginData.userid || null,
                shiftname: loginData && loginData.shifttiming || null,
                username,
                date,
                clockintime: formattedLoginTime,
                clockouttime: formattedLogoffTime,
                firstworktook: loginData && loginData.worktook,
                lastworktook: loginDataLast && loginDataLast.worktook,
            };
        });
        // console.log(finalProductions, 'finalProductions')

        //Get Biometric Data       
        const usernamesFilter = finaluserbefore?.length > 0 ? finaluserbefore?.map(data => data?.rowusername) : [];
        const uniqueUsers = [...new Set(usernamesFilter)];

        const devicenames = await BiometricDeviceManagement.find({
            $or: [
                { biometricinattendance: true },
                { biometricoutattendance: true },
                { biometricinoutattendance: true }
            ]
        }, { biometricserialno: 1 });

        // answer = finaluserbefore?.filter(data => req.body.fromdate <= data.finalDate && req.body.todate >= data.finalDate);
        answer = finaluserbefore?.filter(data => daysArray?.some(val => val.formattedDate === data.formattedDate));

        usersCollection = await Biometricattlog.aggregate([
            {
                $match: {
                    staffNameC: { $in: uniqueUsers },
                    cloudIDC: { $in: devicenames?.map(data => data?.biometricserialno) }
                }
            },
            {
                $lookup: {
                    from: "users",
                    localField: "staffNameC",
                    foreignField: "username",
                    as: "uniqueUsers"
                }
            },
            {
                $lookup: {
                    from: "biometricdevicemanagements",
                    localField: "cloudIDC",
                    foreignField: "biometricserialno",
                    as: "biometricDevice"
                }
            },
            {
                $addFields: {
                    _id: { $arrayElemAt: ["$uniqueUsers._id", 0] },
                    username: { $arrayElemAt: ["$uniqueUsers.username", 0] },
                    empcode: { $arrayElemAt: ["$uniqueUsers.empcode", 0] },
                    company: { $arrayElemAt: ["$uniqueUsers.company", 0] },
                    branch: { $arrayElemAt: ["$uniqueUsers.branch", 0] },
                    unit: { $arrayElemAt: ["$uniqueUsers.unit", 0] },
                    team: { $arrayElemAt: ["$uniqueUsers.team", 0] },
                    department: { $arrayElemAt: ["$uniqueUsers.department", 0] },
                    companyname: { $arrayElemAt: ["$uniqueUsers.companyname", 0] },
                    biometriccommonname: { $arrayElemAt: ["$biometricDevice.biometriccommonname", 0] },
                    indevice: { $arrayElemAt: ["$biometricDevice.biometricinattendance", 0] },
                    outdevice: { $arrayElemAt: ["$biometricDevice.biometricoutattendance", 0] },
                    inoutdevice: { $arrayElemAt: ["$biometricDevice.biometricinoutattendance", 0] },
                }
            },
            {
                $project: {
                    uniqueUsers: 0
                }
            }
        ]);

        // console.log(usersCollection.filter(val => val.clockDateTimeD.split(" ")[0] === '22-05-2025'))

        // let BioFilteredData = answer?.flatMap((userdata) => {

        //     const matchedUsers = usersCollection
        //         .filter(user => user.staffNameC === userdata.rowusername)
        //         .map(user => {
        //             const startTime = userdata.shiftdate?.startTime ? new Date(userdata.shiftdate.startTime) : null;
        //             const endTime = userdata.shiftdate?.endTime ? new Date(userdata.shiftdate.endTime) : null;
        //             const [datePart, timePart] = user?.clockDateTimeD.split(" ");
        //             const [day, month, year] = datePart.split("-");
        //             const clockTime = new Date(`${year}-${month}-${day}T${timePart}`);

        //             if (startTime && endTime && !isNaN(clockTime)) {
        //                 if (clockTime >= startTime && clockTime <= endTime) {
        //                     return { ...user, clockTime, };
        //                 }
        //             }
        //             return null;
        //         })
        //         .filter(Boolean);


        //     // console.log(matchedUsers.filter(data => data.indevice === true), 'indevice')
        //     // console.log(matchedUsers.filter(data => data.indevice === true), 'indevice')
        //     // const testdata = matchedUsers.filter(data => data.outdevice === true)
        //     // console.log(testdata[testdata.length - 1].clockDateTimeD, 'outdevice')

        //     // Categorize by device types
        //     const inDevices = matchedUsers.filter(d => d.indevice);
        //     const outDevices = matchedUsers.filter(d => d.outdevice);
        //     const inOutDevices = matchedUsers.filter(d => d.inoutdevice);

        //     // Sort all by datetime
        //     const sortedInDevices = [...inDevices].sort((a, b) => new Date(a.clockTime) - new Date(b.clockTime));
        //     const sortedOutDevices = [...outDevices].sort((a, b) => new Date(a.clockTime) - new Date(b.clockTime));
        //     const sortedInOutDevices = [...inOutDevices].sort((a, b) => new Date(a.clockTime) - new Date(b.clockTime));

        //     let inTime = null;
        //     let outTime = null;
        //     let inTimeVerified = null;
        //     let inTimeVerifiedDevice = null;
        //     let outTimeVerified = null;
        //     let outTimeVerifiedDevice = null;

        //     // Determine inTime
        //     if (sortedInDevices.length > 0) {
        //         console.log(sortedInDevices[0].clockDateTimeD, 'sortedInDevices[0].clockDateTimeD')
        //         inTime = sortedInDevices[0].clockDateTimeD;
        //         inTimeVerified = sortedInDevices[0].verifyC;
        //         inTimeVerifiedDevice = sortedInDevices[0].biometriccommonname;
        //     } else if (sortedInOutDevices.length > 0) {
        //         console.log(sortedInOutDevices[0].clockDateTimeD, 'sortedInOutDevices[0].clockDateTimeD')
        //         inTime = sortedInOutDevices[0].clockDateTimeD;
        //         inTimeVerified = sortedInOutDevices[0].verifyC;
        //         inTimeVerifiedDevice = sortedInOutDevices[0].biometriccommonname;
        //     }

        //     // console.log(sortedInOutDevices.length > 0 && sortedInOutDevices.length % 2 === 0)
        //     // console.log(sortedInOutDevices, 'sortedInOutDevices')
        //     // console.log(sortedOutDevices.length)
        //     // Determine outTime
        //     if (sortedOutDevices.length > 0) {
        //         const last = matchedUsers[matchedUsers.length - 1];
        //         // console.log(matchedUsers[matchedUsers.length - 1])
        //         // console.log(last, 'last')
        //         if (last?.outdevice) {
        //             outTime = last.clockDateTimeD;
        //             outTimeVerified = last.verifyC;
        //             outTimeVerifiedDevice = last.biometriccommonname;
        //         }


        //     } else if (sortedInOutDevices.length > 0 && sortedInOutDevices.length % 2 === 0) {
        //         const last = matchedUsers[matchedUsers.length - 1];
        //         if (last?.inoutdevice) {
        //             outTime = last.clockDateTimeD;
        //             outTimeVerified = last.verifyC;
        //             outTimeVerifiedDevice = last.biometriccommonname;
        //         }
        //     }

        //     const fallbackUser = usersCollection.find(user => user.staffNameC === userdata.rowusername);

        //     // console.log(inTime ? formatToAmPm(inTime) : null, 'inTime ? formatToAmPm(inTime) : null')
        //     // console.log(outTime ? formatToAmPm(outTime) : null, 'outTime ? formatToAmPm(outTime) : null')

        //     return {
        //         shiftdate: userdata.shiftdate?.date || userdata.shift,
        //         ...(matchedUsers?.length > 0 ? matchedUsers[0] : fallbackUser),

        //         inTime: inTime ? formatToAmPm(inTime) : null,
        //         outTime: outTime ? formatToAmPm(outTime) : null,
        //         inTimeVerified,
        //         inTimeVerifiedDevice,
        //         outTimeVerified,
        //         outTimeVerifiedDevice,
        //         date: formatToDate(inTime),
        //         clockintime: formatToTimeAmPm(inTime),
        //         clockouttime: formatToTimeAmPm(outTime),
        //     };
        // });


        // // today
        // let BioFilteredData = answer?.flatMap(({ rowusername, shiftdate, shift }) => {
        //     const matchedUsers = usersCollection
        //         .filter(user => user.staffNameC === rowusername)
        //         .map(user => {
        //             const startTime = shiftdate?.startTime ? new Date(shiftdate.startTime) : null;
        //             const endTime = shiftdate?.endTime ? new Date(shiftdate.endTime) : null;
        //             const [datePart, timePart] = user?.clockDateTimeD.split(" ");
        //             const [day, month, year] = datePart.split("-");
        //             const clockTime = new Date(`${year}-${month}-${day}T${timePart}`);

        //             if (startTime && endTime && !isNaN(clockTime)) {
        //                 if (clockTime >= startTime && clockTime <= endTime) {
        //                     return { ...user, clockTime };
        //                 }
        //             }
        //             return null;
        //         })
        //         .filter(Boolean);

        //     // Categorize by device types
        //     const inDevices = matchedUsers.filter(d => d.indevice);
        //     const outDevices = matchedUsers.filter(d => d.outdevice);
        //     const inOutDevices = matchedUsers.filter(d => d.inoutdevice);

        //     // Sort all by datetime
        //     const sortedInDevices = [...inDevices].sort((a, b) => new Date(a.clockTime) - new Date(b.clockTime));
        //     const sortedOutDevices = [...outDevices].sort((a, b) => new Date(a.clockTime) - new Date(b.clockTime));
        //     const sortedInOutDevices = [...inOutDevices].sort((a, b) => new Date(a.clockTime) - new Date(b.clockTime));

        //     let inTime = null;
        //     let outTime = null;
        //     let inTimeVerified = null;
        //     let inTimeVerifiedDevice = null;
        //     let outTimeVerified = null;
        //     let outTimeVerifiedDevice = null;

        //     // Determine inTime
        //     if (sortedInDevices.length > 0) {
        //         inTime = sortedInDevices[0].clockDateTimeD;
        //         inTimeVerified = sortedInDevices[0].verifyC;
        //         inTimeVerifiedDevice = sortedInDevices[0].biometriccommonname;
        //     } else if (sortedInOutDevices.length > 0) {
        //         inTime = sortedInOutDevices[0].clockDateTimeD;
        //         inTimeVerified = sortedInOutDevices[0].verifyC;
        //         inTimeVerifiedDevice = sortedInOutDevices[0].biometriccommonname;
        //     }

        //     // Determine outTime
        //     if (sortedOutDevices.length > 0) {
        //         const last = matchedUsers[matchedUsers.length - 1];

        //         if (last?.outdevice) {
        //             outTime = last.clockDateTimeD;
        //             outTimeVerified = last.verifyC;
        //             outTimeVerifiedDevice = last.biometriccommonname;
        //         }


        //     } else if (sortedInOutDevices.length > 0 && sortedInOutDevices.length % 2 === 0) {
        //         const last = matchedUsers[matchedUsers.length - 1];
        //         if (last?.inoutdevice) {
        //             outTime = last.clockDateTimeD;
        //             outTimeVerified = last.verifyC;
        //             outTimeVerifiedDevice = last.biometriccommonname;
        //         }
        //     }

        //     const fallbackUser = usersCollection.find(user => user.staffNameC === rowusername);

        //     return {
        //         shiftdate: shiftdate?.date || shift,
        //         ...(matchedUsers?.length > 0 ? matchedUsers[0] : fallbackUser),
        //         inTime: inTime ? formatToAmPm(inTime) : null,
        //         outTime: outTime ? formatToAmPm(outTime) : null,
        //         inTimeVerified,
        //         inTimeVerifiedDevice,
        //         outTimeVerified,
        //         outTimeVerifiedDevice,
        //         date: formatToDate(inTime),
        //         clockintime: formatToTimeAmPm(inTime),
        //         clockouttime: formatToTimeAmPm(outTime),
        //     };
        // });

        // Group answer1 by username and date
        const groupedByUserAndDate = answer.reduce((acc, curr) => {
            const key = `${curr.rowusername}_${curr.formattedDate}`;
            if (!acc[key]) acc[key] = [];
            acc[key].push(curr);
            return acc;
        }, {});

        let BioFilteredData = Object.entries(groupedByUserAndDate).flatMap(([key, shiftsForDay]) => {
            return shiftsForDay.map((shiftEntry, index, arr) => {

                const { rowusername, formattedDate, shiftdate, shiftMode, shift, userid } = shiftEntry;

                // Extract shift start and end time
                const shiftStartTime = shiftdate?.startTime ? new Date(shiftdate.startTime) : null;
                const shiftEndTime = shiftdate?.endTime ? new Date(shiftdate.endTime) : null;

                let overrideInTime = null;
                let overrideOutTime = null;

                // Check for double shift on same day
                if (arr.length === 2) {
                    const mainShift = arr.find(s => s.shiftMode === 'Main Shift');
                    const secondShift = arr.find(s => s.shiftMode === 'Second Shift');

                    if (mainShift && secondShift) {
                        const mainEnd = convertTo24HourBio1(mainShift.shift.split("to")[1]);
                        const secondStart = convertTo24HourBio1(secondShift.shift.split("to")[0]);

                        const [day, month, year] = formattedDate?.split('/');
                        const formattedFinalDate = `${day}-${month}-${year}`;

                        if (mainEnd === secondStart) {
                            if (shiftMode === 'Main Shift') {
                                overrideOutTime = `${formattedFinalDate} ${mainEnd}`;
                            } else if (shiftMode === 'Second Shift') {
                                overrideInTime = `${formattedFinalDate} ${secondStart}`;
                            }
                        }
                    }
                }

                const matchedUsers = usersCollection
                    .filter(user => user.staffNameC === rowusername)
                    .map(user => {
                        const [datePart, timePart] = user.clockDateTimeD.split(" ");
                        const [day, month, year] = datePart.split("-");
                        const clockTime = new Date(`${year}-${month}-${day}T${timePart}`);

                        if (!isNaN(clockTime) && clockTime >= shiftStartTime && clockTime <= shiftEndTime) {
                            return { ...user, clockTime };
                        }
                        return null;
                    })
                    .filter(Boolean);

                const inDevices = matchedUsers.filter(d => d.indevice);
                const outDevices = matchedUsers.filter(d => d.outdevice);
                const inOutDevices = matchedUsers.filter(d => d.inoutdevice);

                const sortedInDevices = [...inDevices].sort((a, b) => new Date(a.clockTime) - new Date(b.clockTime));
                const sortedOutDevices = [...outDevices].sort((a, b) => new Date(a.clockTime) - new Date(b.clockTime));
                const sortedInOutDevices = [...inOutDevices].sort((a, b) => new Date(a.clockTime) - new Date(b.clockTime));

                let inTime = overrideInTime;
                let outTime = overrideOutTime;
                let inTimeVerified = null;
                let inTimeVerifiedDevice = null;
                let outTimeVerified = null;
                let outTimeVerifiedDevice = null;

                if (!inTime) {
                    if (sortedInDevices.length > 0) {
                        inTime = sortedInDevices[0].clockDateTimeD;
                        inTimeVerified = sortedInDevices[0].verifyC;
                        inTimeVerifiedDevice = sortedInDevices[0].biometriccommonname;
                    } else if (sortedInOutDevices.length > 0) {
                        inTime = sortedInOutDevices[0].clockDateTimeD;
                        inTimeVerified = sortedInOutDevices[0].verifyC;
                        inTimeVerifiedDevice = sortedInOutDevices[0].biometriccommonname;
                    }
                }

                if (!outTime) {
                    if (sortedOutDevices.length > 0) {
                        const last = matchedUsers[matchedUsers.length - 1];
                        if (last?.outdevice) {
                            outTime = last.clockDateTimeD;
                            outTimeVerified = last.verifyC;
                            outTimeVerifiedDevice = last.biometriccommonname;
                        }
                    } else if (sortedInOutDevices.length > 0 && sortedInOutDevices.length % 2 === 0) {
                        const last = matchedUsers[matchedUsers.length - 1];
                        if (last?.inoutdevice) {
                            outTime = last.clockDateTimeD;
                            outTimeVerified = last.verifyC;
                            outTimeVerifiedDevice = last.biometriccommonname;
                        }
                    }
                }

                const fallbackUser = usersCollection.find(user => user.staffNameC === rowusername);

                return {
                    shiftdate: shiftdate?.date || shift,
                    ...(matchedUsers.length > 0 ? matchedUsers[0] : fallbackUser),
                    inTime: inTime ? formatToAmPm(inTime) : null,
                    outTime: outTime ? formatToAmPm(outTime) : null,
                    inTimeVerified,
                    inTimeVerifiedDevice,
                    outTimeVerified,
                    outTimeVerifiedDevice,
                    shiftmode: shiftMode,
                    userid: userid,
                    date: formatToDate(inTime),
                    clockintime: formatToTimeAmPm(inTime),
                    clockouttime: formatToTimeAmPm(outTime),
                };
            });
        });


        function convertTo24HourBio1(time) {
            if (!time) {
                return '';
            }
            const [t, modifier] = time.match(/(\d{1,2}:\d{2})(AM|PM)/).slice(1);
            let [hours, minutes] = t.split(":").map(Number);

            if (modifier === "PM" && hours !== 12) hours += 12;
            if (modifier === "AM" && hours === 12) hours = 0;

            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:00`;
        }


        //console.log(BioFilteredData.filter(data => data.shiftdate === '22-05-2025'), 'BioFilteredData')

        function formatToAmPm(datetimeStr) {
            const date = new Date(datetimeStr.replace(' ', 'T'));
            return date.toLocaleTimeString('en-US', { hour12: true });
        }

        function convertTo24HourBio(timeStr) {
            const [time, modifier] = [timeStr.slice(0, -2), timeStr.slice(-2)];
            let [hours, minutes] = time.split(":").map(Number);
            if (modifier === "PM" && hours !== 12) hours += 12;
            if (modifier === "AM" && hours === 12) hours = 0;
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:00`;
        }

        function formatToAmPm(dateStr) {
            if (!dateStr) {
                return '';
            }
            let [day, month, year, time] = dateStr.split(/[-\s]/);
            let formattedDate = new Date(`${year}-${month}-${day}T${time}`);
            let formattedTime = formattedDate.toLocaleString("en-US", {
                hour: "2-digit",
                minute: "2-digit",
                second: "2-digit",
                hour12: true
            });
            return `${day}-${month}-${year} ${formattedTime}`; // Remove space between time and AM/PM
        }

        function formatToDate(dateStr) {
            if (!dateStr) {
                return '';
            }
            let [day, month, year, time] = dateStr?.split(/[-\s]/);
            return `${day}-${month}-${year}`; // Remove space between time and AM/PM
        }

        function formatToTimeAmPm(dateStr) {
            if (!dateStr) {
                return '';
            }
            let [day, month, year, time] = dateStr.split(/[-\s]/);
            let formattedDate = new Date(`${year}-${month}-${day}T${time}`);
            let formattedTime = formattedDate.toLocaleString("en-US", {
                hour: "2-digit",
                minute: "2-digit",
                second: "2-digit",
                hour12: true
            });
            return `${formattedTime}`; // Remove space between time and AM/PM
        }

        finaluser = finaluserbefore?.flatMap((item) => {

            let isEmployeeGrace = controlcriteria[0].todos && controlcriteria[0].todos.find(d => d.company === item.company &&
                d.branch === item.branch && d.unit === item.unit && d.team === item.team &&
                d.employeename === item.companyname
            )

            if (isEmployeeGrace) {
                graceTime = isEmployeeGrace.employeegracetime;
            }

            let attendance = [];
            const filteredEventData = [];
            const biometricData = [];

            finalEventStorages.forEach(eventitem => {
                if (eventitem.username === item?.rowusername && eventitem.date === item.finalDate) {
                    filteredEventData.push({
                        ...eventitem,
                        date: moment(eventitem.date, 'YYYY-MM-DD').format('DD-MM-YYYY'),
                        shiftmode: item.shiftMode,
                        userid: item.userid,
                    });
                }
            });
            const attendanceData = attendances.filter(d => d.username === item?.rowusername && moment(item.formattedDate, "DD/MM/YYYY").format("DD-MM-YYYY") === d.date);
            const productionData = finalProductions.filter(proditem => proditem.username === item?.rowusername && proditem.date === item.finalDate);

            BioFilteredData.forEach(bioitem => {
                if (bioitem.username === item?.rowusername && moment(item.formattedDate, "DD/MM/YYYY").format("DD-MM-YYYY") === bioitem.date && bioitem.shiftmode === item.shiftMode) {
                    biometricData.push({
                        username: bioitem.username,
                        inTime: bioitem.inTime,
                        outTime: bioitem.outTime,
                        inTimeVerified: bioitem.inTimeVerified,
                        inTimeVerifiedDevice: bioitem.inTimeVerifiedDevice,
                        outTimeVerified: bioitem.outTimeVerified,
                        outTimeVerifiedDevice: bioitem.outTimeVerifiedDevice,
                        date: bioitem.date,
                        clockintime: bioitem.clockintime,
                        clockouttime: bioitem.clockouttime,
                        shiftmode: bioitem.shiftmode,
                        userid: bioitem.userid,
                    });
                }
            });

            // console.log(filteredEventData, 'events')
            // console.log(attendanceData, 'att')
            // console.log(biometricData, 'biometricData')

            const matchedAttModeLog = item.attendancemodelog?.find(d => d.fromdate <= item.finalDate && d.todate >= item.finalDate);
            // console.log(matchedAttModeLog, 'matchedAttModeLog')

            // corresponding user's attendancemodelog priority wise
            if (matchedAttModeLog) {
                for (const mode of matchedAttModeLog.mode) {
                    const result = getAttendanceByMode(mode, filteredEventData, attendanceData, biometricData, productionData);
                    if (result && result.length > 0) {
                        attendance = result;
                        break; // stop once valid data is found
                    }
                }
            }

            // default corresponding user's attendancemode priority wise
            if (!matchedAttModeLog) {
                for (const mode of item.attendancemode) {
                    const result = getAttendanceByMode(mode, filteredEventData, attendanceData, biometricData, productionData);
                    if (result) {
                        attendance = result;
                        break; // stop once valid data is found
                    }
                }
            }

            // console.log(attendance, 'attendance')
            // Remove duplicate entries with the most recent entry
            const uniqueEntriesAtt = {};
            controlcriteria[0].attendancetimelog?.forEach(entry => {
                const key = entry.startdate;
                if (!(key in uniqueEntriesAtt)) {
                    uniqueEntriesAtt[key] = entry;
                }
            });

            const uniqueAttLog = Object.values(uniqueEntriesAtt);
            let relevantAttLogEntry = uniqueAttLog
                .filter(log => new Date(log.startdate) <= new Date(item.finalDate))
                .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

            clockOutHours = relevantAttLogEntry ? relevantAttLogEntry.clockout : controlcriteria[0].clockout;
            clockInHours = relevantAttLogEntry ? relevantAttLogEntry.clockin : controlcriteria[0].clockin;
            lateclockincount = relevantAttLogEntry ? relevantAttLogEntry.lateclockincount : controlcriteria[0].lateclockincount;
            earlyclockoutcount = relevantAttLogEntry ? relevantAttLogEntry.earlyclockoutcount : controlcriteria[0].earlyclockoutcount;
            onclockout = relevantAttLogEntry ? relevantAttLogEntry.onclockout : controlcriteria[0].onclockout;
            earlyclockin = relevantAttLogEntry ? relevantAttLogEntry.earlyclockin : controlcriteria[0].onclockout;
            lateclockin = relevantAttLogEntry ? relevantAttLogEntry.lateclockin : controlcriteria[0].lateclockin;
            earlyclockout = relevantAttLogEntry ? relevantAttLogEntry.earlyclockout : controlcriteria[0].earlyclockout;
            afterlateclockin = relevantAttLogEntry ? relevantAttLogEntry.afterlateclockin : controlcriteria[0].afterlateclockin;
            beforeearlyclockout = relevantAttLogEntry ? relevantAttLogEntry.beforeearlyclockout : controlcriteria[0].afterlateclockin;

            if (!isEmployeeGrace) {
                // graceTime = controlcriteria[0].gracetime;
                graceTime = relevantAttLogEntry ? relevantAttLogEntry.gracetime : controlcriteria[0].gracetime;
            }

            let resdep = depMaster.filter(val => val.deptname === item?.department);

            const row = {
                ...item,
                clockin: checkGetClockInTime(attendance, item.userid, item.formattedDate,
                    item.shift,
                    item.shiftMode,
                ),
                clockout: checkGetClockOutTime(attendance, item.userid, item.formattedDate,
                    item.shift,
                    item.shiftMode,
                ),
                clockinstatus: checkClockInStatus(
                    checkGetClockInTime(attendance, item.userid, item.formattedDate, item.shift, item.shiftMode,),
                    item.shift,
                    graceTime, allLeaveStatus, holidays,
                    checkGetClockInDate(attendance, item.userid, item.formattedDate, item.shiftMode,), item?.branch, item?.empcode, item?.company, item.formattedDate, item?.unit, item?.team, item?.companyname,
                    earlyclockin, lateclockin, afterlateclockin, leavetype, permission,
                    checkGetClockOutTime(attendance, item.userid, item.formattedDate, item.shift, item.shiftMode,),
                    item.shiftMode, checkWeekOffPresentStatus(attendance, item.userid, item.formattedDate, item.shiftMode,), leavecriterias, item.weekNumberInMonth, item.dayName, item?.department, item?.designation,
                ),
                clockoutstatus: checkClockOutStatus(
                    checkGetClockOutTime(attendance, item.userid, item.formattedDate, item.shift, item.shiftMode,),
                    checkGetClockInTime(attendance, item.userid, item.formattedDate, item.shift, item.shiftMode,),
                    item.shift,
                    clockOutHours, checkGetClockInDate(attendance, item.userid, item.formattedDate, item.shiftMode,),
                    allLeaveStatus, holidays, item?.branch, item?.empcode, item?.company, item.formattedDate, item?.unit, item?.team, item?.companyname, onclockout,
                    earlyclockout, beforeearlyclockout,
                    checkGetClockInAutoStatus(attendance, item.userid, item.formattedDate, item.shiftMode,),
                    leavetype, permission, item.shiftMode, checkWeekOffPresentStatus(attendance, item.userid, item.formattedDate, item.shiftMode,), leavecriterias, item.weekNumberInMonth, item.dayName, item?.department, item?.designation,
                ),
                attendanceautostatus: checkAttendanceStatus(attendance, item.userid, item.formattedDate, item.shiftMode,),
                lateclockincount: lateclockincount,
                earlyclockoutcount: earlyclockoutcount,
                ipaddress: getUserIp(attendance, item.userid, item.formattedDate, item.shiftMode),
                weekoffpresentstatus: checkWeekOffPresentStatus(attendance, item.userid, item.formattedDate, item.shiftMode,),
                leavestatus: checkLeaveStatus(allLeaveStatus, item?.empcode, item.formattedDate, leavetype, item.shiftMode),
                permissionstatus: checkPermissionStatus(item?.empcode, item.formattedDate, permission, item.shiftMode),
                changeshift: getActualShiftTimeBasedOnPermission(
                    checkGetClockInTime(attendance, item.userid, item.formattedDate, item.shift, item.shiftMode,),
                    item.shift,
                    item?.empcode, item.formattedDate, permission, item.shiftMode,
                ),
                workmode: item?.workmode,
                attendancemodeprioritystatus: checkGetAttModePriority(attendance, item.userid, item.formattedDate,
                    item.shift,
                    item.shiftMode, item.attendancemode
                ),
                depattmode: checkGetDepAttMode(resdep, item?.department),
            };

            return row;

        });

        // finaluser = department.length > 0 ? finaluserbefore.filter(data => department.includes(data.department)) : finaluserbefore;
        // console.log(finaluser, 'finaluser')
    } catch (err) {
        console.log(err)
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finaluser) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ finaluser });
});

// For Holiday/Weekoff Login page
exports.getAllEmployeesForHolidayWeekoffFilter = catchAsyncErrors(async (req, res, next) => {
    const { type, company, branch, unit, team, employee, department, designation } = req.body;
    let query = {
        company: { $in: company },
        branch: { $in: branch },
        enquirystatus: {
            $nin: ["Enquiry Purpose"],
        },
    };

    try {
        switch (type) {
            case "Individual":
                query = {
                    unit: { $in: unit },
                    team: { $in: team },
                    companyname: { $in: employee },
                };
                break;

            case "Branch":
                query;
                break;

            case "Unit":
                query = {
                    unit: { $in: unit },
                };
                break;

            case "Team":
                query = {
                    unit: { $in: unit },
                    team: { $in: team },
                };
                break;

            case "Department":
                query.$or = [
                    {
                        departmentlog: {
                            $elemMatch: {
                                department: { $in: department }
                            }
                        }
                    },
                    {
                        company: { $in: company },
                        branch: { $in: branch },
                    }
                ];
                break;

            case "Designation":
                query.$or = [
                    {
                        designationlog: {
                            $elemMatch: {
                                designation: { $in: designation }
                            }
                        }
                    },
                    {
                        company: { $in: company },
                        branch: { $in: branch },
                    }
                ];
                break;

            default:
                return next(new ErrorHandler("Invalid filter type provided", 400));
        }

        // Fetch users based on query
        const users = await User.find(query, {
            company: 1,
            branch: 1,
            unit: 1,
            team: 1,
            department: 1,
            doj: 1,
            empcode: 1,
            companyname: 1,
            floor: 1,
            username: 1,
            designation: 1,
            weekoff: 1,
            shiftallot: 1,
            shifttiming: 1,
            boardingLog: 1,
            attendancemode: 1,
            reasondate: 1,
            departmentlog: 1,
            designationlog: 1,
        });

        return res.status(200).json({ users });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
});
function createFilterCondition(column, condition, value) {
    switch (condition) {
        case "Contains":
            return { [column]: new RegExp(value, 'i') };
        case "Does Not Contain":
            return { [column]: { $not: new RegExp(value, 'i') } };
        case "Equals":
            return { [column]: value };
        case "Does Not Equal":
            return { [column]: { $ne: value } };
        case "Begins With":
            return { [column]: new RegExp(`^${value}`, 'i') };
        case "Ends With":
            return { [column]: new RegExp(`${value}$`, 'i') };
        case "Blank":
            return { [column]: { $exists: false } };
        case "Not Blank":
            return { [column]: { $exists: true } };
        default:
            return {};
    }
}
exports.getAllUsersnewFilterMissingfield = catchAsyncErrors(
    async (req, res, next) => {
        try {
            const {
                companyname,
                branchname,
                unitname,
                teamname,
                employeename,
                departmentname,
                allFilters, logicOperator, searchQuery,
            } = req.body;


            let query = {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
                resonablestatus: {
                    $nin: [
                        "Not Joined",
                        "Postponed",
                        "Rejected",
                        "Closed",
                        "Releave Employee",
                        "Absconded",
                        "Hold",
                        "Terminate",
                    ],
                },
                ...(companyname && Array.isArray(companyname) && companyname.length > 0
                    ? { company: { $in: companyname } }
                    : {}),
                ...(branchname && Array.isArray(branchname) && branchname.length > 0
                    ? { branch: { $in: branchname } }
                    : {}),
                ...(unitname && Array.isArray(unitname) && unitname.length > 0
                    ? { unit: { $in: unitname } }
                    : {}),
                ...(teamname && Array.isArray(teamname) && teamname.length > 0
                    ? { team: { $in: teamname } }
                    : {}),
                ...(employeename &&
                    Array.isArray(employeename) &&
                    employeename.length > 0
                    ? { companyname: { $in: employeename } }
                    : {}),
                ...(departmentname &&
                    Array.isArray(departmentname) &&
                    departmentname.length > 0
                    ? { department: { $in: departmentname } }
                    : {}),
            };
            let conditions = [];


            // Advanced search filter
            if (allFilters && allFilters.length > 0) {
                allFilters.forEach(filter => {
                    if (filter.column && filter.condition && (filter.value || ["Blank", "Not Blank"].includes(filter.condition))) {
                        conditions.push(createFilterCondition(filter.column, filter.condition, filter.value));
                    }
                });
            }

            if (searchQuery) {
                const searchTermsArray = searchQuery.split(" ");
                const regexTerms = searchTermsArray.map((term) => new RegExp(term, "i"));

                const orConditions = regexTerms.map((regex) => ({
                    $or: [
                        { company: regex },
                        { branch: regex },
                        { unit: regex },
                        { team: regex },
                        { empcode: regex },
                        { companyname: regex },
                    ],
                }));

                query = {
                    $and: [
                        ...orConditions,
                    ],
                };
            }

            // Apply logicOperator to combine conditions
            if (conditions.length > 0) {
                if (logicOperator === "AND") {
                    query.$and = conditions;
                } else if (logicOperator === "OR") {
                    query.$or = conditions;
                }
            }

            const page = parseInt(req.body.page) || 1; // Default to page 1
            const limit = parseInt(req.body.pageSize) || 10; // Default to 10 users per page
            const skip = (page - 1) * limit;

            ;

            const totalProjects = await User.countDocuments(query);
            const users = await User.find(query).skip(skip).limit(limit).lean();

            if (!users || users.length === 0) {
                return res.status(400).json({ message: "No users found" });
            }

            const results = await Promise.all(
                users.map(async (user) => {
                    const document = await User.findById(user._id).lean();
                    if (!document) {
                        return {
                            _id: user._id,
                            message: "Document not found",
                            emptyFields: [],
                        };
                    }

                    const [employeedocument, assignbranch] = await Promise.all([
                        EmployeeDocuments.findOne({
                            commonid: document._id.toString(),
                        }).lean(),
                        AssignBranch.findOne({
                            employee: document.companyname,
                            employeecode: document.empcode,
                        }).lean(),
                    ]);

                    const emptyFields = new Set();

                    const checkEmpty = (obj, prefix = "") => {
                        for (const key in obj) {
                            const value = obj[key];
                            if (Array.isArray(value) && key === "workstation") {
                                if (value.length === 0) {
                                    emptyFields.add("workstationprimary");
                                    emptyFields.add("workstationsecondary");
                                } else {
                                    if (value.includes("Please Select Primary Work Station")) {
                                        emptyFields.add("workstationprimary");
                                    }
                                    if (value.length === 1) {
                                        emptyFields.add("workstationsecondary");
                                    }
                                }
                            } else if (Array.isArray(value) && key === "boardingLog") {
                                if (value.length === 0) {
                                    emptyFields.add("weekoff");
                                } else if (value.length > 0) {
                                    if (value[value?.length - 1]?.weekoff?.length === 0) {
                                        emptyFields.add("weekoff");
                                    }
                                }
                            } else if (
                                value === "" ||
                                value === "undefined" ||
                                value === undefined ||
                                (Array.isArray(value) && value.length === 0) ||
                                (typeof value === "number" && value === 0)
                            ) {
                                emptyFields.add(prefix + key);
                            } else if (
                                typeof value === "object" &&
                                value !== null &&
                                !Array.isArray(value)
                            ) {
                                checkEmpty(value, `${prefix}${key}.`);
                            }
                        }

                        if (obj.workmode !== "Internship") {
                            emptyFields.delete(`${prefix}intStartDate`);
                            emptyFields.delete(`${prefix}intEndDate`);
                            emptyFields.delete(`${prefix}modeOfInt`);
                            emptyFields.delete(`${prefix}intDuration`);
                        }
                        if (obj.maritalstatus !== "Married") {
                            emptyFields.delete(`${prefix}dom`);
                        }
                    };

                    checkEmpty(document);

                    if (document.panstatus === "Have PAN") {
                        emptyFields.delete("panrefno");
                    }
                    if (document.panstatus === "Applied") {
                        emptyFields.delete("panno");
                    }
                    if (document.panstatus === "Yet to Apply") {
                        emptyFields.delete("panno");
                        emptyFields.delete("panrefno");
                    }

                    if (!employeedocument) {
                        emptyFields.add("profileimage");
                        emptyFields.add("employeedocuments");
                    } else {
                        if (!employeedocument.profileimage) emptyFields.add("profileimage");
                        if (employeedocument.files.length === 0) {
                            emptyFields.add("employeedocuments");
                        }
                    }

                    if (!assignbranch) {
                        emptyFields.add("assignbranch");
                    }

                    return {
                        ...document,
                        employeedocument,
                        assignbranch,
                        emptyfields: [...emptyFields],
                    };
                })
            );

            res.status(200).json({
                count: results.length,
                totalProjects,
                currentPage: page,
                totalPages: Math.ceil(totalProjects / limit),
                results,
            });
        } catch (err) {
            return next(new ErrorHandler("Error Filtering Missing Fields!", 404));
        }
    }
);

exports.getAllUsersPostergenerate = catchAsyncErrors(async (req, res, next) => {
    let users;
    const { team } = req.body.params
    try {

        users = await User.aggregate([
            {
                $match: {
                    enquirystatus: { $nin: ["Enquiry Purpose"] },
                    resonablestatus: {
                        $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"]
                    },
                    team: {
                        $in: team.map(obj => obj.value)
                    }
                }
            },
            {
                $lookup: {
                    from: "employeedocuments",
                    let: { company_name: "$companyname" },
                    pipeline: [
                        {
                            $match: {
                                $expr: { $eq: ["$companyname", "$$company_name"] }
                            }
                        },
                        {
                            $project: {
                                _id: 0,
                                profileimage: 1, // Profile image from employeedocuments
                                companyname: 1
                            }
                        },
                        { $limit: 5 }
                    ],
                    as: "documents"
                }
            },
            {
                $project: {
                    _id: 1,
                    companyname: 1,
                    team: 1,
                    legalname: 1,
                    profileimage: { $arrayElemAt: ["$documents.profileimage", 0] }, // Get first profileimage
                    documents: 1,
                    dom: 1,
                    dob: 1,
                }
            }
        ]);

    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ count: users.length, users });
});


exports.duplicateFaceDetector = catchAsyncErrors(async (req, res, next) => {
    try {
        const { faceDescriptor, id } = req.body;

        // Ensure faceDescriptor is an array of numbers
        if (
            !Array.isArray(faceDescriptor) ||
            !faceDescriptor.every((num) => typeof num === "number")
        ) {
            throw new Error("Invalid face descriptor format.");
        }

        // Fetch all user face descriptors from MongoDB
        const allUsers = await User.find(
            { _id: { $ne: id }, faceDescriptor: { $exists: true, $not: { $size: 0 } } },
            { faceDescriptor: 1 }
        ).lean();
        let authenticated = false;

        // Compare face descriptors
        for (const user of allUsers) {
            const storedDescriptor = user?.faceDescriptor;

            if (
                !Array.isArray(storedDescriptor) ||
                storedDescriptor.length !== faceDescriptor.length
            ) {
                continue; // Skip mismatched descriptors
            }

            const distance = faceapi.euclideanDistance(
                faceDescriptor,
                storedDescriptor
            );

            if (distance < 0.4) {
                authenticated = true;
                break; // Exit loop once fond
            }
        }

        return res.status(200).json({ matchfound: authenticated });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
});


//Hierarchy- Hierarchy Based Employee Status
exports.getHierarchyBasedEmployeeWorkstationhira = catchAsyncErrors(async (req, res, next) => {
    let resultArray,
        user,
        result1,
        ans1D,
        i = 1,
        result2,
        result3,
        result4,
        result5,
        result6,
        dataCheck,
        userFilter,
        result,
        hierarchyFilter,
        answerDef,
        hierarchyFinal,
        hierarchy,
        hierarchyDefList,
        resultAccessFilter,
        branch,
        hierarchySecond,
        overallMyallList,
        hierarchyMap,
        resulted,
        resultedTeam,
        DataAccessMode = false,
        myallTotalNames;

    try {
        const { listpageaccessmode } = req.body;
        let levelFinal = req.body?.sector === "all" ? ["Primary", "Secondary", "Tertiary"] : [req.body?.sector]
        let answer = await Hirerarchi.aggregate([
            {
                $match: {
                    supervisorchoose:
                        req?.body?.username, // Match supervisorchoose with username
                    level: { $in: levelFinal } // Corrected unmatched quotation mark
                }
            },
            {
                $lookup: {
                    from: "reportingheaders",
                    let: {
                        teamControlsArray: {
                            $ifNull: ["$pagecontrols", []]
                        }
                    },
                    pipeline: [
                        {
                            $match: {
                                $expr: {
                                    $and: [
                                        {
                                            $in: [
                                                "$name",
                                                "$$teamControlsArray"
                                            ]
                                        }, // Check if 'name' is in 'teamcontrols' array
                                        {
                                            $in: [
                                                req?.body?.pagename,
                                                "$reportingnew" // Check if 'menuteamloginstatus' is in 'reportingnew' array
                                            ]
                                        } // Additional condition for reportingnew array
                                    ]
                                }
                            }
                        }
                    ],
                    as: "reportData" // The resulting matched documents will be in this field
                }
            },
            {
                $project: {
                    supervisorchoose: 1,
                    employeename: 1,
                    reportData: 1
                }

            }
        ]);

        // Manager Condition Without Supervisor
        const HierarchySupervisorFind = await Hirerarchi.find({ supervisorchoose: req?.body?.username });
        DataAccessMode = req.body.role?.some(role => role.toLowerCase() === "manager") && HierarchySupervisorFind?.length === 0;
        const { uniqueNames, pageControlsData } = await Hierarchyfilter(levelFinal, req?.body?.pagename);


        let restrictList = answer?.filter(data => data?.reportData?.length > 0)?.flatMap(Data => Data?.employeename)

        result = await User.find(
            {
                enquirystatus: {
                    $nin: ['Enquiry Purpose'],
                },
                resonablestatus: {
                    $nin: ['Not Joined', 'Postponed', 'Rejected', 'Closed', 'Releave Employee', 'Absconded', 'Hold', 'Terminate'],
                },
            },
            {
                unit: 1,
                branch: 1,
                designation: 1,
                department: 1,
                dob: 1,
                company: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                username: 1,
                workmode: 1,
                employeecount: 1,
                workstation: 1,
                enableworkstation: 1,
                wordcheck: 1,
                workstationinput: 1,
                workstationofficestatus: 1,
                wfhstatus: 1,
                wfhcount: 1,
                loginUserStatus: 1,
            }
        );


        // Accordig to sector and list filter process
        hierarchyFilter = await Hirerarchi.find({ level: req.body.sector });
        userFilter = hierarchyFilter.filter((data) => data.supervisorchoose.includes(req.body.username)).map((data) => data.employeename);

        hierarchyDefList = await Hirerarchi.find();
        user = await User.find({ companyname: req.body.username });
        const userFilt = user.length > 0 && user[0].designation;
        const desiGroup = await Designation.find();
        let HierarchyFilt = req.body.sector === 'all' ? hierarchyDefList.filter((data) => data.supervisorchoose.includes(req.body.username)).map((data) => data.designationgroup) : hierarchyFilter.filter((data) => data.supervisorchoose.includes(req.body.username)).map((data) => data.designationgroup);
        const DesifFilter = desiGroup.filter((data) => HierarchyFilt.includes(data.group));
        const desigName = DesifFilter.length > 0 && DesifFilter[0].name;
        const SameDesigUser = HierarchyFilt.includes('All') ? true : userFilt === desigName;
        //Default Loading of List
        answerDef = hierarchyDefList.filter((data) => data.supervisorchoose.includes(req.body.username)).map((data) => data.employeename);

        hierarchyFinal = req.body.sector === 'all' ? (answerDef.length > 0 ? [].concat(...answerDef) : []) : hierarchyFilter.length > 0 ? [].concat(...userFilter) : [];

        hierarchyMap = hierarchyFinal.length > 0 ? hierarchyFinal : [];

        //solo
        ans1D = req.body.sector === 'all' ? (answerDef.length > 0 ? hierarchyDefList.filter((data) => data.supervisorchoose.includes(req.body.username)) : []) : hierarchyFilter.length > 0 ? hierarchyFilter.filter((data) => data.supervisorchoose.includes(req.body.username)) : [];
        result1 =
            ans1D.length > 0
                ? result
                    .map((item1) => {
                        const matchingItem2 = ans1D.find((item2) => item2.employeename.includes(item1.companyname));

                        if (matchingItem2) {
                            const plainItem1 = item1.toObject ? item1.toObject() : item1;
                            return { ...plainItem1, level: req.body.sector + '-' + matchingItem2.control };
                            //   return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                        }
                    })
                    .filter((item) => item !== undefined)
                : [];

        resulted = result1;

        //team
        let branches = [];
        hierarchySecond = await Hirerarchi.find();

        const subBranch =
            hierarchySecond.length > 0
                ? hierarchySecond
                    .filter((item) => item.supervisorchoose.some((name) => hierarchyMap.includes(name)))
                    .map((item) => item.employeename)
                    .flat()
                : '';

        const answerFilterExcel = hierarchySecond.length > 0 ? hierarchySecond.filter((item) => item.supervisorchoose.some((name) => hierarchyMap.includes(name))) : [];

        result2 =
            answerFilterExcel.length > 0
                ? result
                    .map((item1) => {
                        const matchingItem2 = answerFilterExcel.find((item2) => item2.employeename.includes(item1.companyname));
                        if (matchingItem2) {
                            // If a match is found, inject the control property into the corresponding item in an1
                            const plainItem1 = item1.toObject ? item1.toObject() : item1;
                            return { ...plainItem1, level: req.body.sector + '-' + matchingItem2.control };
                            // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                        }
                    })
                    .filter((item) => item !== undefined)
                : [];
        branches.push(...subBranch);

        const ans =
            subBranch.length > 0
                ? hierarchySecond
                    .filter((item) => item.supervisorchoose.some((name) => subBranch.includes(name)))
                    .map((item) => item.employeename)
                    .flat()
                : '';
        const answerFilterExcel2 = subBranch.length > 0 ? hierarchySecond.filter((item) => item.supervisorchoose.some((name) => subBranch.includes(name))) : [];

        result3 =
            answerFilterExcel2.length > 0
                ? result
                    .map((item1) => {
                        const matchingItem2 = answerFilterExcel2.find((item2) => item2.employeename.includes(item1.companyname));
                        if (matchingItem2) {
                            const plainItem1 = item1.toObject ? item1.toObject() : item1;
                            return { ...plainItem1, level: req.body.sector + '-' + matchingItem2.control };
                            // If a match is found, inject the control property into the corresponding item in an1
                            // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                        }
                    })
                    .filter((item) => item !== undefined)
                : [];
        branches.push(...ans);

        const loop3 =
            ans.length > 0
                ? hierarchySecond
                    .filter((item) => item.supervisorchoose.some((name) => ans.includes(name)))
                    .map((item) => item.employeename)
                    .flat()
                : '';

        const answerFilterExcel3 = ans.length > 0 ? hierarchySecond.filter((item) => item.supervisorchoose.some((name) => ans.includes(name))) : [];

        result4 =
            answerFilterExcel3.length > 0
                ? result
                    .map((item1) => {
                        const matchingItem2 = answerFilterExcel3?.find((item2) => item2.employeename.includes(item1.companyname));
                        if (matchingItem2) {
                            const plainItem1 = item1.toObject ? item1.toObject() : item1;
                            return { ...plainItem1, level: req.body.sector + '-' + matchingItem2.control };
                            // If a match is found, inject the control property into the corresponding item in an1
                            // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                        }
                    })
                    .filter((item) => item !== undefined)
                : [];
        branches.push(...loop3);

        const loop4 =
            loop3.length > 0
                ? hierarchySecond
                    .filter((item) => item.supervisorchoose.some((name) => loop3.includes(name)))
                    .map((item) => item.employeename)
                    .flat()
                : [];
        const answerFilterExcel4 = loop3.length > 0 ? hierarchySecond.filter((item) => item.supervisorchoose.some((name) => loop3.includes(name))) : [];
        result5 =
            answerFilterExcel4.length > 0
                ? result
                    .map((item1) => {
                        const matchingItem2 = answerFilterExcel4?.find((item2) => item2.employeename.includes(item1.companyname));
                        if (matchingItem2) {
                            const plainItem1 = item1.toObject ? item1.toObject() : item1;
                            return { ...plainItem1, level: req.body.sector + '-' + matchingItem2.control };
                            // If a match is found, inject the control property into the corresponding item in an1
                            // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                        }
                    })
                    .filter((item) => item !== undefined)
                : [];
        branches.push(...loop4);

        const loop5 =
            loop4.length > 0
                ? hierarchySecond
                    .filter((item) => item.supervisorchoose.some((name) => loop4.includes(name)))
                    .map((item) => item.employeename)
                    .flat()
                : '';
        const answerFilterExcel5 = loop4.length > 0 ? hierarchySecond.filter((item) => item.supervisorchoose.some((name) => loop4.includes(name))) : [];
        result6 =
            answerFilterExcel5.length > 0
                ? result
                    .map((item1) => {
                        const matchingItem2 = answerFilterExcel5?.find((item2) => item2.employeename.includes(item1.companyname));
                        if (matchingItem2) {
                            const plainItem1 = item1.toObject ? item1.toObject() : item1;
                            return { ...plainItem1, level: req.body.sector + '-' + matchingItem2.control };
                            // If a match is found, inject the control property into the corresponding item in an1
                            // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                        }
                    })
                    .filter((item) => item !== undefined)
                : [];
        branches.push(...loop5);

        resultedTeam = [...result2, ...result3, ...result4, ...result5, ...result6];
        //overall Teams List
        myallTotalNames = DataAccessMode ? uniqueNames : [...hierarchyMap, ...branches];
        const finalResult = await User.find(
            {
                enquirystatus: {
                    $nin: ['Enquiry Purpose'],
                },
                resonablestatus: {
                    $nin: ['Not Joined', 'Postponed', 'Rejected', 'Closed', 'Releave Employee', 'Absconded', 'Hold', 'Terminate'],
                },
            },
            {
                unit: 1,
                branch: 1,
                designation: 1,
                department: 1,
                dob: 1,
                company: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                username: 1,
                workmode: 1,
                employeecount: 1,
                workstation: 1,
                enableworkstation: 1,
                wordcheck: 1,
                workstationinput: 1,
                workstationofficestatus: 1,
                wfhstatus: 1,
                wfhcount: 1,
                loginUserStatus: 1,
            }
        );
        overallMyallList = [...resulted, ...resultedTeam];
        const restrictTeam = await Hirerarchi.aggregate([
            {
                $match: {
                    supervisorchoose:
                        { $in: myallTotalNames }, // Match supervisorchoose with username
                    level: { $in: levelFinal } // Corrected unmatched quotation mark
                }
            },
            {
                $lookup: {
                    from: "reportingheaders",
                    let: {
                        teamControlsArray: {
                            $ifNull: ["$pagecontrols", []]
                        }
                    },
                    pipeline: [
                        {
                            $match: {
                                $expr: {
                                    $and: [
                                        {
                                            $in: [
                                                "$name",
                                                "$$teamControlsArray"
                                            ]
                                        }, // Check if 'name' is in 'teamcontrols' array
                                        {
                                            $in: [
                                                req?.body?.pagename,
                                                "$reportingnew" // Check if 'menuteamloginstatus' is in 'reportingnew' array
                                            ]
                                        } // Additional condition for reportingnew array
                                    ]
                                }
                            }
                        }
                    ],
                    as: "reportData" // The resulting matched documents will be in this field
                }
            },
            {
                $project: {
                    supervisorchoose: 1,
                    employeename: 1,
                    reportData: 1
                }
            }
        ]);
        let restrictListTeam = DataAccessMode ? pageControlsData : restrictTeam?.filter(data => data?.reportData?.length > 0)?.flatMap(Data => Data?.employeename)
        let overallRestrictList = DataAccessMode ? restrictListTeam : (req.body.hierachy === "myhierarchy" ?
            restrictList : req.body.hierachy === "allhierarchy" ?
                restrictListTeam :
                [...restrictList, ...restrictListTeam]);

        let resultAccessFiltered = DataAccessMode ? finalResult : (
            req.body.hierachy === "myhierarchy" &&
                (listpageaccessmode === "Hierarchy Based" ||

                    listpageaccessmode === "Overall")
                ? resulted
                : req.body.hierachy === "allhierarchy" &&
                    (listpageaccessmode === "Hierarchy Based" ||
                        listpageaccessmode === "Overall")
                    ? resultedTeam
                    : req.body.hierachy === "myallhierarchy" &&
                        (listpageaccessmode === "Hierarchy Based" ||
                            listpageaccessmode === "Overall")
                        ? overallMyallList
                        : result);

        resultAccessFilter = overallRestrictList?.length > 0 ? resultAccessFiltered?.filter(data => overallRestrictList?.includes(data?.companyname)) : [];

        // resultAccessFilter = req.body.hierachy === 'myhierarchy' ? resulted : req.body.hierachy === 'allhierarchy' ? resultedTeam : overallMyallList;
    } catch (err) {
        return next(new ErrorHandler('Records not found!', 404));
    }
    if (!result) {
        return next(new ErrorHandler('No data found!', 404));
    }
    return res.status(200).json({
        result,
        ans1D,
        result1,
        resulted,
        resultedTeam,
        branch,
        hierarchy,
        overallMyallList,
        resultAccessFilter,
        hierarchyFilter,
        user,
        dataCheck,
        userFilter,
        resultArray,
        DataAccessMode

    });
});

exports.getHierarchyBasedEmployeeWorkstation = catchAsyncErrors(async (req, res, next) => {
    let resultArray,
        user,
        result1,
        ans1D,
        i = 1,
        result2,
        result3,
        result4,
        result5,
        result6,
        dataCheck,
        userFilter,
        result,
        hierarchyFilter,
        answerDef,
        hierarchyFinal,
        hierarchy,
        hierarchyDefList,
        resultAccessFilter,
        branch,
        hierarchySecond,
        overallMyallList,
        hierarchyMap,
        resulted,
        resultedTeam,
        DataAccessMode = false,
        myallTotalNames;

    try {
        const { listpageaccessmode } = req.body;
        let levelFinal = req.body?.sector === "all" ? ["Primary", "Secondary", "Tertiary"] : [req.body?.sector]
        let answer = await Hirerarchi.aggregate([
            {
                $match: {
                    supervisorchoose:
                        req?.body?.username, // Match supervisorchoose with username
                    level: { $in: levelFinal } // Corrected unmatched quotation mark
                }
            },
            {
                $lookup: {
                    from: "reportingheaders",
                    let: {
                        teamControlsArray: {
                            $ifNull: ["$pagecontrols", []]
                        }
                    },
                    pipeline: [
                        {
                            $match: {
                                $expr: {
                                    $and: [
                                        {
                                            $in: [
                                                "$name",
                                                "$$teamControlsArray"
                                            ]
                                        }, // Check if 'name' is in 'teamcontrols' array
                                        {
                                            $in: [
                                                req?.body?.pagename,
                                                "$reportingnew" // Check if 'menuteamloginstatus' is in 'reportingnew' array
                                            ]
                                        } // Additional condition for reportingnew array
                                    ]
                                }
                            }
                        }
                    ],
                    as: "reportData" // The resulting matched documents will be in this field
                }
            },
            {
                $project: {
                    supervisorchoose: 1,
                    employeename: 1,
                    reportData: 1
                }

            }
        ]);

        // Manager Condition Without Supervisor
        const HierarchySupervisorFind = await Hirerarchi.find({ supervisorchoose: req?.body?.username });
        DataAccessMode = req.body.role?.some(role => role.toLowerCase() === "manager") && HierarchySupervisorFind?.length === 0;
        const { uniqueNames, pageControlsData } = await Hierarchyfilter(levelFinal, req?.body?.pagename);


        let restrictList = answer?.filter(data => data?.reportData?.length > 0)?.flatMap(Data => Data?.employeename)
        result = await User.find(
            {
                enquirystatus: {
                    $nin: ['Enquiry Purpose'],
                },
                resonablestatus: {
                    $nin: ['Not Joined', 'Postponed', 'Rejected', 'Closed', 'Releave Employee', 'Absconded', 'Hold', 'Terminate'],
                },
            },
            {
                unit: 1,
                branch: 1,
                designation: 1,
                department: 1,
                dob: 1,
                company: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                username: 1,
                workmode: 1,
                employeecount: 1,
                workstation: 1,
                enableworkstation: 1,
                wordcheck: 1,
                workstationinput: 1,
                workstationofficestatus: 1,
                wfhstatus: 1,
                wfhcount: 1,
                loginUserStatus: 1,
            }
        );

        // Accordig to sector and list filter process
        hierarchyFilter = await Hirerarchi.find({ level: req.body.sector });
        userFilter = hierarchyFilter.filter((data) => data.supervisorchoose.includes(req.body.username)).map((data) => data.employeename);

        hierarchyDefList = await Hirerarchi.find();
        user = await User.find({ companyname: req.body.username });
        const userFilt = user.length > 0 && user[0].designation;
        const desiGroup = await Designation.find();
        let HierarchyFilt = req.body.sector === 'all' ? hierarchyDefList.filter((data) => data.supervisorchoose.includes(req.body.username)).map((data) => data.designationgroup) : hierarchyFilter.filter((data) => data.supervisorchoose.includes(req.body.username)).map((data) => data.designationgroup);
        const DesifFilter = desiGroup.filter((data) => HierarchyFilt.includes(data.group));
        const desigName = DesifFilter.length > 0 && DesifFilter[0].name;
        const SameDesigUser = HierarchyFilt.includes('All') ? true : userFilt === desigName;
        //Default Loading of List
        answerDef = hierarchyDefList.filter((data) => data.supervisorchoose.includes(req.body.username)).map((data) => data.employeename);

        hierarchyFinal = req.body.sector === 'all' ? (answerDef.length > 0 ? [].concat(...answerDef) : []) : hierarchyFilter.length > 0 ? [].concat(...userFilter) : [];

        hierarchyMap = hierarchyFinal.length > 0 ? hierarchyFinal : [];

        //solo
        ans1D = req.body.sector === 'all' ? (answerDef.length > 0 ? hierarchyDefList.filter((data) => data.supervisorchoose.includes(req.body.username)) : []) : hierarchyFilter.length > 0 ? hierarchyFilter.filter((data) => data.supervisorchoose.includes(req.body.username)) : [];
        result1 =
            ans1D.length > 0
                ? result
                    .map((item1) => {
                        const matchingItem2 = ans1D.find((item2) => item2.employeename.includes(item1.companyname));

                        if (matchingItem2) {
                            const plainItem1 = item1.toObject ? item1.toObject() : item1;
                            return { ...plainItem1, level: req.body.sector + '-' + matchingItem2.control };
                            //   return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                        }
                    })
                    .filter((item) => item !== undefined)
                : [];

        resulted = result1;

        //team
        let branches = [];
        hierarchySecond = await Hirerarchi.find();

        const subBranch =
            hierarchySecond.length > 0
                ? hierarchySecond
                    .filter((item) => item.supervisorchoose.some((name) => hierarchyMap.includes(name)))
                    .map((item) => item.employeename)
                    .flat()
                : '';

        const answerFilterExcel = hierarchySecond.length > 0 ? hierarchySecond.filter((item) => item.supervisorchoose.some((name) => hierarchyMap.includes(name))) : [];

        result2 =
            answerFilterExcel.length > 0
                ? result
                    .map((item1) => {
                        const matchingItem2 = answerFilterExcel.find((item2) => item2.employeename.includes(item1.companyname));
                        if (matchingItem2) {
                            // If a match is found, inject the control property into the corresponding item in an1
                            const plainItem1 = item1.toObject ? item1.toObject() : item1;
                            return { ...plainItem1, level: req.body.sector + '-' + matchingItem2.control };
                            // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                        }
                    })
                    .filter((item) => item !== undefined)
                : [];
        branches.push(...subBranch);

        const ans =
            subBranch.length > 0
                ? hierarchySecond
                    .filter((item) => item.supervisorchoose.some((name) => subBranch.includes(name)))
                    .map((item) => item.employeename)
                    .flat()
                : '';
        const answerFilterExcel2 = subBranch.length > 0 ? hierarchySecond.filter((item) => item.supervisorchoose.some((name) => subBranch.includes(name))) : [];

        result3 =
            answerFilterExcel2.length > 0
                ? result
                    .map((item1) => {
                        const matchingItem2 = answerFilterExcel2.find((item2) => item2.employeename.includes(item1.companyname));
                        if (matchingItem2) {
                            const plainItem1 = item1.toObject ? item1.toObject() : item1;
                            return { ...plainItem1, level: req.body.sector + '-' + matchingItem2.control };
                            // If a match is found, inject the control property into the corresponding item in an1
                            // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                        }
                    })
                    .filter((item) => item !== undefined)
                : [];
        branches.push(...ans);

        const loop3 =
            ans.length > 0
                ? hierarchySecond
                    .filter((item) => item.supervisorchoose.some((name) => ans.includes(name)))
                    .map((item) => item.employeename)
                    .flat()
                : '';

        const answerFilterExcel3 = ans.length > 0 ? hierarchySecond.filter((item) => item.supervisorchoose.some((name) => ans.includes(name))) : [];

        result4 =
            answerFilterExcel3.length > 0
                ? result
                    .map((item1) => {
                        const matchingItem2 = answerFilterExcel3?.find((item2) => item2.employeename.includes(item1.companyname));
                        if (matchingItem2) {
                            const plainItem1 = item1.toObject ? item1.toObject() : item1;
                            return { ...plainItem1, level: req.body.sector + '-' + matchingItem2.control };
                            // If a match is found, inject the control property into the corresponding item in an1
                            // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                        }
                    })
                    .filter((item) => item !== undefined)
                : [];
        branches.push(...loop3);

        const loop4 =
            loop3.length > 0
                ? hierarchySecond
                    .filter((item) => item.supervisorchoose.some((name) => loop3.includes(name)))
                    .map((item) => item.employeename)
                    .flat()
                : [];
        const answerFilterExcel4 = loop3.length > 0 ? hierarchySecond.filter((item) => item.supervisorchoose.some((name) => loop3.includes(name))) : [];
        result5 =
            answerFilterExcel4.length > 0
                ? result
                    .map((item1) => {
                        const matchingItem2 = answerFilterExcel4?.find((item2) => item2.employeename.includes(item1.companyname));
                        if (matchingItem2) {
                            const plainItem1 = item1.toObject ? item1.toObject() : item1;
                            return { ...plainItem1, level: req.body.sector + '-' + matchingItem2.control };
                            // If a match is found, inject the control property into the corresponding item in an1
                            // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                        }
                    })
                    .filter((item) => item !== undefined)
                : [];
        branches.push(...loop4);

        const loop5 =
            loop4.length > 0
                ? hierarchySecond
                    .filter((item) => item.supervisorchoose.some((name) => loop4.includes(name)))
                    .map((item) => item.employeename)
                    .flat()
                : '';
        const answerFilterExcel5 = loop4.length > 0 ? hierarchySecond.filter((item) => item.supervisorchoose.some((name) => loop4.includes(name))) : [];
        result6 =
            answerFilterExcel5.length > 0
                ? result
                    .map((item1) => {
                        const matchingItem2 = answerFilterExcel5?.find((item2) => item2.employeename.includes(item1.companyname));
                        if (matchingItem2) {
                            const plainItem1 = item1.toObject ? item1.toObject() : item1;
                            return { ...plainItem1, level: req.body.sector + '-' + matchingItem2.control };
                            // If a match is found, inject the control property into the corresponding item in an1
                            // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                        }
                    })
                    .filter((item) => item !== undefined)
                : [];
        branches.push(...loop5);

        resultedTeam = [...result2, ...result3, ...result4, ...result5, ...result6];
        //overall Teams List
        myallTotalNames = DataAccessMode ? uniqueNames : [...hierarchyMap, ...branches];
        const finalResult = await User.find(
            {
                enquirystatus: {
                    $nin: ['Enquiry Purpose'],
                },
                resonablestatus: {
                    $nin: ['Not Joined', 'Postponed', 'Rejected', 'Closed', 'Releave Employee', 'Absconded', 'Hold', 'Terminate'],
                },
            },
            {
                unit: 1,
                branch: 1,
                designation: 1,
                department: 1,
                dob: 1,
                company: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                username: 1,
                workmode: 1,
                employeecount: 1,
                workstation: 1,
                enableworkstation: 1,
                wordcheck: 1,
                workstationinput: 1,
                workstationofficestatus: 1,
                wfhstatus: 1,
                wfhcount: 1,
                loginUserStatus: 1,
            }
        );



        overallMyallList = [...resulted, ...resultedTeam];


        const restrictTeam = await Hirerarchi.aggregate([
            {
                $match: {
                    supervisorchoose:
                        { $in: myallTotalNames }, // Match supervisorchoose with username
                    level: { $in: levelFinal } // Corrected unmatched quotation mark
                }
            },
            {
                $lookup: {
                    from: "reportingheaders",
                    let: {
                        teamControlsArray: {
                            $ifNull: ["$pagecontrols", []]
                        }
                    },
                    pipeline: [
                        {
                            $match: {
                                $expr: {
                                    $and: [
                                        {
                                            $in: [
                                                "$name",
                                                "$$teamControlsArray"
                                            ]
                                        }, // Check if 'name' is in 'teamcontrols' array
                                        {
                                            $in: [
                                                req?.body?.pagename,
                                                "$reportingnew" // Check if 'menuteamloginstatus' is in 'reportingnew' array
                                            ]
                                        } // Additional condition for reportingnew array
                                    ]
                                }
                            }
                        }
                    ],
                    as: "reportData" // The resulting matched documents will be in this field
                }
            },
            {
                $project: {
                    supervisorchoose: 1,
                    employeename: 1,
                    reportData: 1
                }
            }
        ]);
        let restrictListTeam = DataAccessMode ? pageControlsData : restrictTeam?.filter(data => data?.reportData?.length > 0)?.flatMap(Data => Data?.employeename)
        let overallRestrictList = DataAccessMode ? restrictListTeam : (req.body.hierachy === "myhierarchy" ?
            restrictList : req.body.hierachy === "allhierarchy" ?
                restrictListTeam :
                [...restrictList, ...restrictListTeam]);

        let resultAccessFiltered = DataAccessMode ? finalResult : (
            req.body.hierachy === "myhierarchy" &&
                (listpageaccessmode === "Hierarchy Based" ||

                    listpageaccessmode === "Overall")
                ? resulted
                : req.body.hierachy === "allhierarchy" &&
                    (listpageaccessmode === "Hierarchy Based" ||
                        listpageaccessmode === "Overall")
                    ? resultedTeam
                    : req.body.hierachy === "myallhierarchy" &&
                        (listpageaccessmode === "Hierarchy Based" ||
                            listpageaccessmode === "Overall")
                        ? overallMyallList
                        : result);

        resultAccessFilter = overallRestrictList?.length > 0 ? resultAccessFiltered?.filter(data => overallRestrictList?.includes(data?.companyname)) : [];



        // resultAccessFilter = req.body.hierachy === 'myhierarchy' ? resulted : req.body.hierachy === 'allhierarchy' ? resultedTeam : overallMyallList;
    } catch (err) {
        return next(new ErrorHandler('Records not found!', 404));
    }

    return res.status(200).json({
        result,
        ans1D,
        result1,
        resulted,
        resultedTeam,
        branch,
        hierarchy,
        overallMyallList,
        resultAccessFilter,
        hierarchyFilter,
        user,
        dataCheck,
        userFilter,
        resultArray,
        DataAccessMode
    });
});


exports.getUserWithStatusHomeCount = catchAsyncErrors(async (req, res, next) => {
    let allusers;
    try {
        const { pageName } = req.body;

        // Define the past 3 days range
        const today = moment();
        const pastThreeAttendaysDays = [
            today.clone().subtract(1, "days").format("DD-MM-YYYY"),
            today.clone().subtract(2, "days").format("DD-MM-YYYY"),

            today.clone().subtract(3, "days").format("DD-MM-YYYY"),
        ];
        const pastThreeLeaveDays = [
            today.clone().subtract(1, "days").format("DD/MM/YYYY"),
            today.clone().subtract(2, "days").format("DD/MM/YYYY"),
            today.clone().subtract(3, "days").format("DD/MM/YYYY"),
        ];
        const pastThreeDaysISO = [
            today.clone().subtract(1, "days").format("YYYY-MM-DD"),
            today.clone().subtract(2, "days").format("YYYY-MM-DD"),
            today.clone().subtract(3, "days").format("YYYY-MM-DD"),
        ];
        // Fetch relevant attendance records for the past 3 days
        let attendance = await Attendance.find(
            {
                date: {
                    $in: pastThreeAttendaysDays,
                },
            },
            { date: 1, userid: 1 }
        ).lean();
        // Fetch relevant leave records
        let allLeaveStatus = await ApplyLeave.find(
            {
                date: { $in: pastThreeLeaveDays },
                status: { $nin: ["Rejected"] },
            },
            { employeename: 1, employeeid: 1, date: 1 }
        ).lean();

        let holidays = await Holiday.find(
            {
                date: { $in: pastThreeDaysISO },
            },
            { date: 1, employee: 1 }
        ).lean();

        let noticeperiodstatus = await Noticeperiod.find(
            {},
            {
                empname: 1,
                empcode: 1,
                status: 1,
                rejectStatus: 1,
                cancelstatus: 1,
                approvedStatus: 1,
                continuestatus: 1,
                recheckStatus: 1,
            }
        ).lean();

        // Create a map for fast lookup of attendance records
        const attendanceMap = attendance.reduce((acc, item) => {
            const userId = item.userid.toString();
            const date = moment(item.date, "DD-MM-YYYY").format("DD/MM/YYYY");
            if (!acc[userId]) {
                acc[userId] = [];
            }
            acc[userId].push(date);
            return acc;
        }, {});

        // Create a map for fast lookup of leave records
        const myCheckList = await MyCheckList.find({}).lean();
        let leaveWithCheckList = allLeaveStatus.map((item) => {
            let foundData = myCheckList?.find(
                (dataNew) => dataNew.commonid == item._id
            );
            let areAllGroupsCompleted = foundData?.groups?.every(
                (itemNew) => (itemNew.data !== undefined && itemNew.data !== "") || itemNew.files !== undefined
            );

            if (areAllGroupsCompleted) {
                return {
                    ...item,
                    updatestatus: "Completed",
                };
            }
            return null;
        }).filter(item => item);

        // Create a map for fast lookup of leave records
        const leaveMap = leaveWithCheckList.reduce((acc, item) => {
            const userKey = `${item.employeeid}_${item.employeename}`;
            const leaveDates = item.date.map((date) =>
                moment(date, "DD/MM/YYYY").format("DD/MM/YYYY")
            );
            if (!acc[userKey]) {
                acc[userKey] = [];
            }
            acc[userKey].push(...leaveDates);
            return acc;
        }, {});

        // Create a map for fast lookup of holiday records
        const holidayMap = holidays.reduce((acc, item) => {
            const date = moment(item.date).format("DD/MM/YYYY");
            item.employee.forEach((employee) => {
                if (!acc[employee]) {
                    acc[employee] = [];
                }
                acc[employee].push(date);
            });
            return acc;
        }, {});



        let filterQuery = {
            enquirystatus: {
                $nin: ["Enquiry Purpose"],
            },
            resonablestatus: {
                $nin: [
                    "Not Joined",
                    "Postponed",
                    "Rejected",
                    "Closed",
                    "Releave Employee",
                    "Absconded",
                    "Hold",
                    "Terminate",
                ],
            },
        };

        // if (pageName === "Employee") {
        filterQuery.workmode = {
            $ne: "Internship",
        };
        // } else if (pageName === "Internship") {
        //     filterQuery.workmode = {
        //         $eq: "Internship",
        //     };
        // }

        allusers = await User.countDocuments(filterQuery);
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    // if (!finalArray) {
    //     return next(new ErrorHandler("Users not found", 400));
    // }

    return res.status(200).json({
        // count: finalArray.length,
        // allusers: finalArray,
        allusers
    });
});
exports.getAllUserHomeCountReleive = catchAsyncErrors(async (req, res, next) => {
    let user;

    try {
        user = await User.countDocuments({
            resonablestatus: { $in: ['Absconded', 'Not Joined', 'Hold', 'Terminate', 'Postponed', 'Rejected', 'Closed', 'Releave Employee'] },
            workmode: { $ne: "Internship" }
            // resonablestatus: {
            //     $in: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],

            // },
        });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    // if (!usersstatus) {
    //     return next(new ErrorHandler("Users not found", 400));
    // }

    return res.status(200).json({ user });
});

exports.getAllUserHomeCountNotClockIn = catchAsyncErrors(async (req, res, next) => {
    let user;

    try {
        const currentDate = new Date();
        const formattedDate = `${currentDate.getDate().toString().padStart(2, '0')}-${(currentDate.getMonth() + 1).toString().padStart(2, '0')}-${currentDate.getFullYear()}`;
        user = await Attendance.countDocuments({ date: formattedDate }, {});
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    // if (!usersstatus) {
    //     return next(new ErrorHandler("Users not found", 400));
    // }

    return res.status(200).json({ user });
});

exports.getAllUserHomeCountNotClockInList = catchAsyncErrors(async (req, res, next) => {
    let user, attendance, applyleaves, filtered;

    try {
        const currentDate = new Date();
        const formattedDate = `${currentDate.getDate().toString().padStart(2, '0')}-${(currentDate.getMonth() + 1).toString().padStart(2, '0')}-${currentDate.getFullYear()}`;
        const formattedDateApply = `${currentDate.getDate().toString().padStart(2, '0')}/${(currentDate.getMonth() + 1).toString().padStart(2, '0')}/${currentDate.getFullYear()}`;
        attendance = await Attendance.find({ date: formattedDate }, { username: 1, userid: 1 });

        applyleaves = await ApplyLeave.find({ status: "Approved", date: { $in: formattedDateApply } }, { employeename: 1 })
        let filterQuery = {
            enquirystatus: {
                $nin: ["Enquiry Purpose"],
            },
            resonablestatus: {
                $nin: [
                    "Not Joined",
                    "Postponed",
                    "Rejected",
                    "Closed",
                    "Releave Employee",
                    "Absconded",
                    "Hold",
                    "Terminate",
                ],
            },
        };

        filterQuery.workmode = {
            $ne: "Internship",
        };



        let alluser = await User.find(filterQuery, { company: 1, branch: 1, unit: 1, team: 1, department: 1, username: 1, companyname: 1, empcode: 1, shifttiming: 1 });
        let finalfiltered = alluser.filter(
            (ur) =>
                !attendance.some((oldItem) => {
                    return ur.username === oldItem.username && ur._id == oldItem.userid
                })
        );

        filtered = finalfiltered.filter(
            (ur) =>
                !applyleaves.some((oldItem) => {
                    return ur.companyname === oldItem.employeename
                })
        );

    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    return res.status(200).json({ filtered });
});

// update user by id => /api/user/:id
exports.updatePCUsername = catchAsyncErrors(async (req, res, next) => {
    const { username } = req.body;
    try {

        const id = req.params.id;
        let foundUser = await User.findOne({ username, _id: { $ne: id } });

        if (foundUser) {
            return next(new ErrorHandler("Username Already Exist", 404));
        }
        // Update the user by ID
        const updatedUser = await User.findByIdAndUpdate(id, req.body, { new: true });

        if (!updatedUser) {
            return next(new ErrorHandler("User not found", 404));
        }

        if (!updatedUser) {
            return next(new ErrorHandler("User not found", 404));
        }

        // Return the relevant fields in the response
        return res.status(200).json({
            message: "Updated successfully!",
            userDatas: {
                company: updatedUser?.company,
                branch: updatedUser?.branch,
                unit: updatedUser?.unit,
                team: updatedUser?.team,
                companyname: updatedUser?.companyname,
                empcode: updatedUser?.empcode,
                department: updatedUser?.department
            }
        });
    } catch (err) {
        return next(new ErrorHandler("An error occurred", 500));
    }
});
function getDojFilter() {
    const today = moment();

    const pastThreeDaysISO = [today.clone().format('YYYY-MM-DD'), today.clone().subtract(1, 'days').format('YYYY-MM-DD'), today.clone().subtract(2, 'days').format('YYYY-MM-DD'), today.clone().subtract(3, 'days').format('YYYY-MM-DD')];

    const currentDate = today.clone().format('YYYY-MM-DD');

    return {
        $nin: pastThreeDaysISO,
        $lte: currentDate,
    };
}
exports.getAlluserDataFilterLongAbsendHierarchy = catchAsyncErrors(async (req, res) => {
    try {
        let filteredUsers, filterQuerys;
        let hierarchy,
            secondaryhierarchyfinal,
            tertiaryhierarchyfinal,
            primaryhierarchyfinal,
            hierarchyfilter,
            filteredoverall,
            reportingtobaseduser,
            hierarchyfilter1,
            hierarchyfilter2,
            myallTotalNames,
            hierarchySecond,
            hierarchyMap,
            resulted = [],
            resultedTeam = [],
            hierarchyFinal,
            DataAccessMode = false,
            hierarchyDefault;
        const { company, branch, unit, team, filterin, module, submodule, mainpage, subpage, subsubpage, status, listpageaccessmode } = req.body;

        let levelFinal = req.body?.sector === 'all' ? ['Primary', 'Secondary', 'Tertiary'] : [req.body?.sector];
        let answer = await Hirerarchi.aggregate([
            {
                $match: {
                    supervisorchoose: req?.body?.username, // Match supervisorchoose with username
                    level: { $in: levelFinal }, // Corrected unmatched quotation mark
                },
            },
            {
                $lookup: {
                    from: 'reportingheaders',
                    let: {
                        teamControlsArray: {
                            $ifNull: ['$pagecontrols', []],
                        },
                    },
                    pipeline: [
                        {
                            $match: {
                                $expr: {
                                    $and: [
                                        {
                                            $in: ['$name', '$$teamControlsArray'],
                                        }, // Check if 'name' is in 'teamcontrols' array
                                        {
                                            $in: [
                                                req?.body?.pagename,
                                                '$reportingnew', // Check if 'menuteamloginstatus' is in 'reportingnew' array
                                            ],
                                        }, // Additional condition for reportingnew array
                                    ],
                                },
                            },
                        },
                    ],
                    as: 'reportData', // The resulting matched documents will be in this field
                },
            },
            {
                $project: {
                    supervisorchoose: 1,
                    employeename: 1,
                    reportData: 1,
                },
            },
        ]);

        // Manager Condition Without Supervisor
        const HierarchySupervisorFind = await Hirerarchi.find({ supervisorchoose: req?.body?.username });
        DataAccessMode = req.body.role?.some(role => role.toLowerCase() === "manager") && HierarchySupervisorFind?.length === 0;
        const { uniqueNames, pageControlsData } = await Hierarchyfilter(levelFinal, req?.body?.pagename);




        let restrictList = answer?.filter((data) => data?.reportData?.length > 0)?.flatMap((Data) => Data?.employeename);

        const today = moment();
        const pastThreeDaysISO = [
            today.clone().format('YYYY-MM-DD'),
            today.clone().subtract(1, 'days').format('YYYY-MM-DD'),
            today.clone().subtract(2, 'days').format('YYYY-MM-DD'),
            // today.clone().subtract(3, "days").format("YYYY-MM-DD"),
        ];
        let filterQuery = {
            enquirystatus: {
                $nin: ['Enquiry Purpose'],
            },
            resonablestatus: {
                $nin: ['Not Joined', 'Postponed', 'Rejected', 'Closed', 'Releave Employee', 'Absconded', 'Hold', 'Terminate'],
            },
            doj: getDojFilter(),
            ...(listpageaccessmode === 'Reporting to Based' ? { reportingto: req.body.username } : {}),
        };

        if (Array.isArray(company) && company.length > 0) {
            filterQuery.company = { $in: company };
        }

        if (Array.isArray(branch) && branch.length > 0) {
            filterQuery.branch = { $in: branch };
        }

        if (Array.isArray(unit) && unit.length > 0) {
            filterQuery.unit = { $in: unit };
        }

        if (Array.isArray(team) && team.length > 0) {
            filterQuery.team = { $in: team };
        }

        const removeEmptyArrays = (obj) => {
            return Object.fromEntries(Object.entries(obj).filter(([key, value]) => !Array.isArray(value) || value.length > 0));
        };

        filterQuerys = removeEmptyArrays(filterQuery);
        let resulting = await User.find(filterQuerys, {
            resonablestatus: 1,
            company: 1,
            branch: 1,
            unit: 1,
            team: 1,
            empcode: 1,
            companyname: 1,
            longleaveabsentaprooveddate: 1,
            boardingLog: 1, // Include boardingLog in the result
            username: 1,
            originalpassword: 1,

            firstname: 1,
            lastname: 1,
            aadhar: 1,
            panno: 1,
            dob: 1,
            pstreet: 1,
            pcity: 1,
            ppincode: 1,
            pstate: 1,
            doj: 1,
            pcountry: 1,
        }).lean();

        if ((req.body.hierachy === 'My Hierarchy List' && listpageaccessmode === 'Hierarchy Based') || listpageaccessmode === 'Overall') {
            hierarchy = await Hirerarchi.find({
                supervisorchoose: req.body.username,
                level: req.body.sector,
            });
            hierarchyDefault = await Hirerarchi.find({
                supervisorchoose: req.body.username,
            });

            let answerDef = hierarchyDefault.map((data) => data.employeename);
            hierarchyFinal = req.body.sector === 'all' ? (answerDef.length > 0 ? [].concat(...answerDef) : []) : hierarchy.length > 0 ? [].concat(...hierarchy.map((item) => item.employeename)) : [];
            hierarchyMap = hierarchyFinal.length > 0 ? hierarchyFinal : [];

            hierarchyfilter = await Hirerarchi.find({
                supervisorchoose: req.body.username,
                level: 'Primary',
            });
            primaryhierarchy = hierarchyfilter.map((item) => item.employeename[0]) ? hierarchyfilter.map((item) => item.employeename[0]) : [];

            hierarchyfilter1 = await Hirerarchi.find({
                supervisorchoose: req.body.username,
                level: 'Secondary',
            });
            secondaryhierarchy = hierarchyfilter1.map((item) => item.employeename[0]) ? hierarchyfilter1.map((item) => item.employeename[0]) : [];

            hierarchyfilter2 = await Hirerarchi.find({
                supervisorchoose: req.body.username,
                level: 'Tertiary',
            });
            tertiaryhierarchy = hierarchyfilter2.map((item) => item.employeename[0]) ? hierarchyfilter2.map((item) => item.employeename[0]) : [];

            resulted = resulting
                .map((userObj) => {
                    const matchingHierarchy = hierarchyDefault.find((hierarchyObj) => hierarchyObj.employeename[0] == userObj.companyname);
                    return {
                        ...userObj,
                        companyname: userObj.companyname,
                        unit: userObj.unit,
                        department: userObj.department,
                        team: userObj.team,
                        branch: userObj.branch,
                        doj: userObj.doj,
                        dot: userObj.dot,
                        empcode: userObj.empcode,
                        floor: userObj.floor,
                        designation: userObj.designation,
                        shiftallot: userObj.shiftallot,
                        shifttiming: userObj.shifttiming,
                        boardingLog: userObj.boardingLog,
                        role: userObj.role,
                        weekoff: userObj.weekoff,
                        company: userObj.company,
                        username: userObj.username,
                        _id: userObj._id,
                        control: matchingHierarchy ? matchingHierarchy.control : '',
                    };
                })
                .filter((data) => hierarchyMap.includes(data.companyname));
        }

        if ((req.body.hierachy === 'All Hierarchy List' && listpageaccessmode === 'Hierarchy Based') || listpageaccessmode === 'Overall') {
            hierarchySecond = await Hirerarchi.find({}, { employeename: 1, supervisorchoose: 1, level: 1, control: 1 });
            hierarchyDefault = await Hirerarchi.find({
                supervisorchoose: req.body.username,
            });

            let answerDef = hierarchyDefault.map((data) => data.employeename).flat();

            function findEmployeesRecursive(currentSupervisors, processedSupervisors, users) {
                const filteredData = hierarchySecond.filter((item) => item.supervisorchoose.some((supervisor) => currentSupervisors.includes(supervisor) && !processedSupervisors.has(supervisor)));

                if (filteredData.length === 0) {
                    return users;
                }

                const newEmployees = filteredData.reduce((employees, item) => {
                    employees.push(...item.employeename);
                    processedSupervisors.add(item.supervisorchoose[0]); // Assuming each item has only one supervisorchoose
                    return employees;
                }, []);

                const uniqueNewEmployees = [...new Set(newEmployees)];
                users = [...users, ...filteredData];

                return findEmployeesRecursive(uniqueNewEmployees, processedSupervisors, users);
            }

            const processedSupervisors = new Set();
            const filteredOverallItem = findEmployeesRecursive(answerDef, processedSupervisors, []);
            let answerDeoverall = filteredOverallItem.filter((data) => (req.body.sector == 'all' ? ['Primary', 'Secondary', 'Tertiary'].includes(data.level) : data.level == req.body.sector)).map((item) => item.employeename[0]);

            resultedTeam = resulting
                .map((userObj) => {
                    const matchingHierarchycontrol = filteredOverallItem.find((hierarchyObj) => hierarchyObj.employeename[0] == userObj.companyname);

                    return {
                        ...userObj,
                        companyname: userObj.companyname,
                        unit: userObj.unit,
                        department: userObj.department,
                        team: userObj.team,
                        branch: userObj.branch,
                        doj: userObj.doj,
                        dot: userObj.dot,
                        empcode: userObj.empcode,
                        floor: userObj.floor,
                        designation: userObj.designation,
                        shiftallot: userObj.shiftallot,
                        shifttiming: userObj.shifttiming,
                        boardingLog: userObj.boardingLog,
                        role: userObj.role,
                        weekoff: userObj.weekoff,
                        company: userObj.company,
                        username: userObj.username,
                        _id: userObj._id,
                        level: matchingHierarchycontrol ? matchingHierarchycontrol.level : '',
                        control: matchingHierarchycontrol ? matchingHierarchycontrol.control : '',
                    };
                })
                .filter((data) => answerDeoverall.includes(data.companyname));

            let hierarchyallfinal = await Hirerarchi.find({
                employeename: { $in: answerDeoverall.map((item) => item) },
                level: req.body.sector,
            });
            hierarchyFinal = req.body.sector === 'all' ? (answerDeoverall.length > 0 ? [].concat(...answerDeoverall) : []) : hierarchyallfinal.length > 0 ? [].concat(...hierarchyallfinal.map((item) => item.employeename)) : [];

            primaryhierarchyall = resultedTeam.filter((item) => item.level == 'Primary').map((item) => item.companyname);

            secondaryhierarchyall = resultedTeam.filter((item) => item.level == 'Secondary').map((item) => item.companyname);

            tertiaryhierarchyall = resultedTeam.filter((item) => item.level == 'Tertiary').map((item) => item.companyname);
        }
        //my + all hierarchy list dropdown
        if (((req.body.hierachy === 'My + All Hierarchy List' || req.body.hierachy === 'All Hierarchy List' || req.body.hierachy === 'My Hierarchy List') && listpageaccessmode === 'Hierarchy Based') || listpageaccessmode === 'Overall') {
            hierarchySecond = await Hirerarchi.find({}, { employeename: 1, supervisorchoose: 1, level: 1, control: 1 });
            hierarchyDefault = await Hirerarchi.find({
                supervisorchoose: req.body.username,
            });

            let answerDef = hierarchyDefault.map((data) => data.employeename);

            function findEmployeesRecursive(currentSupervisors, processedSupervisors, users) {
                const filteredData = hierarchySecond.filter((item) => item.supervisorchoose.some((supervisor) => currentSupervisors.includes(supervisor) && !processedSupervisors.has(supervisor)));

                if (filteredData.length === 0) {
                    return users;
                }

                const newEmployees = filteredData.reduce((employees, item) => {
                    employees.push(...item.employeename);
                    processedSupervisors.add(item.supervisorchoose[0]); // Assuming each item has only one supervisorchoose
                    return employees;
                }, []);

                const uniqueNewEmployees = [...new Set(newEmployees)];
                users = [...users, ...filteredData];

                return findEmployeesRecursive(uniqueNewEmployees, processedSupervisors, users);
            }

            const processedSupervisors = new Set();
            const filteredOverallItem = findEmployeesRecursive([req.body.username], processedSupervisors, []);
            let answerDeoverall = filteredOverallItem.filter((data) => (req.body.sector == 'all' ? ['Primary', 'Secondary', 'Tertiary'].includes(data.level) : data.level == req.body.sector)).map((item) => item.employeename[0]);

            filteredoverall = resulting
                .map((userObj) => {
                    const matchingHierarchycontrol = filteredOverallItem.find((hierarchyObj) => hierarchyObj.employeename[0] == userObj.companyname);
                    return {
                        ...userObj,
                        companyname: userObj.companyname,
                        unit: userObj.unit,
                        department: userObj.department,
                        team: userObj.team,
                        branch: userObj.branch,
                        doj: userObj.doj,
                        dot: userObj.dot,
                        empcode: userObj.empcode,
                        floor: userObj.floor,
                        designation: userObj.designation,
                        shiftallot: userObj.shiftallot,
                        shifttiming: userObj.shifttiming,
                        boardingLog: userObj.boardingLog,
                        role: userObj.role,
                        weekoff: userObj.weekoff,
                        company: userObj.company,
                        username: userObj.username,
                        _id: userObj._id,
                        level: matchingHierarchycontrol ? matchingHierarchycontrol.level : '',
                        control: matchingHierarchycontrol ? matchingHierarchycontrol.control : '',
                    };
                })
                .filter((data) => answerDeoverall.includes(data.companyname));

            let hierarchyallfinal = await Hirerarchi.find({
                employeename: { $in: answerDeoverall.map((item) => item) },
                level: req.body.sector,
            });
            hierarchyFinal = req.body.sector === 'all' ? (answerDeoverall.length > 0 ? [].concat(...answerDeoverall) : []) : hierarchyallfinal.length > 0 ? [].concat(...hierarchyallfinal.map((item) => item.employeename)) : [];

            primaryhierarchyfinal = filteredoverall.filter((item) => item.level == 'Primary').map((item) => item.companyname);

            secondaryhierarchyfinal = filteredoverall.filter((item) => item.level == 'Secondary').map((item) => item.companyname);

            tertiaryhierarchyfinal = filteredoverall.filter((item) => item.level == 'Tertiary').map((item) => item.companyname);
        }

        if (listpageaccessmode === 'Reporting to Based') {
            reportingtobaseduser = resulting.map((userObj) => {
                return {
                    ...userObj,
                    companyname: userObj.companyname,
                    unit: userObj.unit,
                    department: userObj.department,
                    team: userObj.team,
                    branch: userObj.branch,
                    doj: userObj.doj,
                    dot: userObj.dot,
                    empcode: userObj.empcode,
                    floor: userObj.floor,
                    designation: userObj.designation,
                    shiftallot: userObj.shiftallot,
                    shifttiming: userObj.shifttiming,
                    boardingLog: userObj.boardingLog,
                    role: userObj.role,
                    weekoff: userObj.weekoff,
                    company: userObj.company,
                    username: userObj.username,
                    _id: userObj._id,
                    level: '',
                    control: '',
                };
            });
        }
        myallTotalNames = DataAccessMode ? uniqueNames : filteredoverall?.map((data) => data?.companyname);

        let finalResult = await User.find({ ...filterQuerys, companyname: { $in: myallTotalNames } }, {
            resonablestatus: 1,
            company: 1,
            branch: 1,
            unit: 1,
            team: 1,
            empcode: 1,
            companyname: 1,
            longleaveabsentaprooveddate: 1,
            boardingLog: 1, // Include boardingLog in the result
            username: 1,
            originalpassword: 1,

            firstname: 1,
            lastname: 1,
            aadhar: 1,
            panno: 1,
            dob: 1,
            pstreet: 1,
            pcity: 1,
            ppincode: 1,
            pstate: 1,
            doj: 1,
            pcountry: 1,
        }).lean();

        console.log(finalResult?.length, 'Length')
        filteredUsers = DataAccessMode ? finalResult : (
            req.body.hierachy === 'My Hierarchy List' && (listpageaccessmode === 'Hierarchy Based' || listpageaccessmode === 'Overall')
                ? resulted
                : req.body.hierachy === 'All Hierarchy List' && (listpageaccessmode === 'Hierarchy Based' || listpageaccessmode === 'Overall')
                    ? resultedTeam
                    : req.body.hierachy === 'My + All Hierarchy List' && (listpageaccessmode === 'Hierarchy Based' || listpageaccessmode === 'Overall')
                        ? filteredoverall
                        : reportingtobaseduser);

        const restrictTeam = await Hirerarchi.aggregate([
            {
                $match: {
                    supervisorchoose: { $in: myallTotalNames }, // Match supervisorchoose with username
                    level: { $in: levelFinal }, // Corrected unmatched quotation mark
                },
            },
            {
                $lookup: {
                    from: 'reportingheaders',
                    let: {
                        teamControlsArray: {
                            $ifNull: ['$pagecontrols', []],
                        },
                    },
                    pipeline: [
                        {
                            $match: {
                                $expr: {
                                    $and: [
                                        {
                                            $in: ['$name', '$$teamControlsArray'],
                                        }, // Check if 'name' is in 'teamcontrols' array
                                        {
                                            $in: [
                                                req?.body?.pagename,
                                                '$reportingnew', // Check if 'menuteamloginstatus' is in 'reportingnew' array
                                            ],
                                        }, // Additional condition for reportingnew array
                                    ],
                                },
                            },
                        },
                    ],
                    as: 'reportData', // The resulting matched documents will be in this field
                },
            },
            {
                $project: {
                    supervisorchoose: 1,
                    employeename: 1,
                    reportData: 1,
                },
            },
        ]);
        let restrictListTeam = DataAccessMode ? pageControlsData : restrictTeam?.filter((data) => data?.reportData?.length > 0)?.flatMap((Data) => Data?.employeename);
        let overallRestrictList = DataAccessMode ? restrictListTeam : req.body.hierachy === 'myhierarchy' ? restrictList : req.body.hierachy === 'allhierarchy' ? restrictListTeam : [...restrictList, ...restrictListTeam];
        console.log(pageControlsData?.length, restrictListTeam?.length, 'Length')
        const currentDateChecklist = moment().format('DD-MM-YYYY');
        const pastThreeAttendaysDays = [
            today.clone().format('DD-MM-YYYY'),
            today.clone().subtract(1, 'days').format('DD-MM-YYYY'),
            today.clone().subtract(2, 'days').format('DD-MM-YYYY'),
            //today.clone().subtract(3, "days").format("DD-MM-YYYY"),
        ];

        const pastThreeLeaveDays = [
            today.clone().format('DD/MM/YYYY'),
            today.clone().subtract(1, 'days').format('DD/MM/YYYY'),
            today.clone().subtract(2, 'days').format('DD/MM/YYYY'),
            //today.clone().subtract(3, "days").format("DD/MM/YYYY"),
        ];

        const [attendance, allLeaveStatus, holidays, checklistData] = await Promise.all([
            Attendance.find(
                {
                    date: {
                        $in: pastThreeAttendaysDays,
                    },
                },
                { date: 1, userid: 1 }
            ).lean(),

            ApplyLeave.find(
                {
                    date: { $in: pastThreeLeaveDays },
                    status: { $nin: ['Rejected', 'Cancel'] },
                },
                { employeename: 1, employeeid: 1, date: 1, status: 1 }
            ).lean(),

            Holiday.find(
                {
                    date: { $in: pastThreeDaysISO },
                },
                {
                    date: 1,
                    employee: 1,
                    company: 1,
                    applicablefor: 1,
                    unit: 1,
                    team: 1,
                }
            ).lean(),
            MyCheckList.find({
                module,
                submodule,
                mainpage,
                subpage,
                subsubpage,
                // status: { $ne: "completed" },
                longleaveabsentaprooveddatechecklist: {
                    $in: [currentDateChecklist],
                },
            }),
        ]);

        const attendanceMap = attendance.reduce((acc, item) => {
            const userId = item.userid.toString();
            const date = moment(item.date, 'DD-MM-YYYY').format('DD/MM/YYYY');
            if (!acc[userId]) {
                acc[userId] = [];
            }
            acc[userId].push(date);
            return acc;
        }, {});

        let allUserEmpname = filteredUsers.map((user) => user.companyname);
        const myCheckList = await MyCheckList.find({ candidatename: { $in: allUserEmpname } }).lean();
        let leaveWithCheckList = allLeaveStatus
            .map((item) => {
                let foundData = myCheckList?.find((dataNew) => dataNew.commonid == item._id);
                let areAllGroupsCompleted = foundData?.groups?.every((itemNew) => (itemNew.data !== undefined && itemNew.data !== '') || itemNew.files !== undefined);

                if (areAllGroupsCompleted) {
                    return {
                        ...item,
                        updatestatus: 'Completed',
                    };
                }
                return null;
            })
            .filter((item) => item);

        const leaveWithCheckListSample = allLeaveStatus;

        // Create a map for fast lookup of leave records
        const leaveMap = leaveWithCheckList.reduce((acc, item) => {
            const userKey = `${item.employeeid}_${item.employeename}`;
            const leaveDates = item.date.map((date) => moment(date, 'DD/MM/YYYY').format('DD/MM/YYYY'));
            if (!acc[userKey]) {
                acc[userKey] = [];
            }
            acc[userKey].push(...leaveDates);
            return acc;
        }, {});

        const employeeMatchesUser = (user, holiday) => {
            return holiday.company.includes(user.company) && holiday.applicablefor.includes(user.branch) && holiday.unit.includes(user.unit) && holiday.team.includes(user.team) && (holiday.employee.includes(user.companyname) || holiday.employee.includes('ALL'));
        };

        const holidayMap = holidays.reduce((acc, item) => {
            const date = moment(item.date).format('DD/MM/YYYY');

            filteredUsers.forEach((user) => {
                if (employeeMatchesUser(user, item)) {
                    if (!acc[user.empcode]) {
                        acc[user.empcode] = [];
                    }
                    acc[user.empcode].push(date);
                }
            });

            return acc;
        }, {});

        const checkStatusForPast3Days = (userId, empcode, employeename, weekOffDays) => {
            const userKey = `${empcode}_${employeename}`;
            let absentDays = 0;
            let leaveDays = 0;
            let holidayDays = 0;

            for (let date of pastThreeLeaveDays) {
                // const dayOfWeek = moment(date, "DD/MM/YYYY").format("dddd"); // Get day of the week

                // if (weekOffDays.includes(dayOfWeek)) {
                //   continue; // Skip week off days
                // }

                if (attendanceMap[userId] && attendanceMap[userId].includes(date)) {
                    continue; // User was present on this date
                } else if (leaveMap[userKey] && leaveMap[userKey].includes(date)) {
                    leaveDays++; // User was on leave on this date
                } else if (holidayMap[empcode] && holidayMap[empcode].includes(date)) {
                    holidayDays++; // Holiday on this date
                } else {
                    absentDays++; // User was absent on this date
                }
            }

            let status = null;
            if (absentDays >= 3) {
                status = 'Long Absent';
            } else if (leaveDays >= 3) {
                status = 'Long Leave';
            }

            return { status, absentDays, leaveDays, holidayDays };
        };

        const determineStatus = (attendanceStatus) => {
            return attendanceStatus ? attendanceStatus : null;
        };
        const limit = pLimit(10);
        const todayDatess = moment().format('DD/MM/YYYY');
        const usersWithoutTodayAttendance = filteredUsers.filter((user) => {
            const userId = user._id.toString();
            return !attendanceMap[userId]?.includes(todayDatess);
        });
        const promises = usersWithoutTodayAttendance.map((user) =>
            limit(async () => {
                const userId = user._id.toString();

                let weekOffDays = [];
                if (user.boardingLog && user.boardingLog.length > 0) {
                    const lastBoardingLog = user.boardingLog[user.boardingLog.length - 1];
                    weekOffDays = lastBoardingLog.weekoff || [];
                }

                // Prepare today and tomorrow dates for API
                const todayDate = moment().format('DD/MM/YYYY');
                const tomorrowDate = moment().add(1, 'day').format('DD/MM/YYYY');

                const daysArray = [
                    {
                        formattedDate: todayDate,
                        dayName: moment().format('dddd'),
                        dayCount: moment().date(),
                        shiftMode: 'Main Shift',
                    },
                    {
                        formattedDate: tomorrowDate,
                        dayName: moment().add(1, 'day').format('dddd'),
                        dayCount: moment().add(1, 'day').date(),
                        shiftMode: 'Main Shift',
                    },
                ];

                let loginusershift = [];
                try {
                    const loginShiftRes = await axios.post(`http://192.168.8.4:7002/api/userclockinclockoutstatusloginstatuscheck`, {
                        userDates: daysArray,
                        empcode: user.empcode,
                    });
                    loginusershift = loginShiftRes?.data?.finaluser || [];
                    // console.log(loginusershift, "loginusershift")
                } catch (error) {
                    console.log('Shift fetch error for user', user.username, user.companyname, error.message);
                }
                const todayShift = loginusershift?.find((entry) => entry.formattedDate === todayDate);
                const tomorrowShiftData = loginusershift.find((d) => d.formattedDate === tomorrowDate);
                const isTodayWorking = todayShift?.shift && todayShift?.shift !== 'Week Off';
                const isTomorrowWeekOff = tomorrowShiftData?.shift === 'Week Off';

                const todayAttendance = attendanceMap[userId]?.includes(todayDate);
                const todayLeave = Object.keys(leaveMap).some((key) => key.startsWith(user.empcode + '_') && leaveMap[key]?.includes(todayDate));
                const todayHoliday = holidayMap[user.empcode]?.includes(todayDate);

                // Calculate current time and shift start time for today
                let hasTodayShiftStarted = false;

                if (isTodayWorking) {
                    const [shiftStartTimeRaw] = todayShift.shift.split('to'); // e.g., '08:30AM'
                    const shiftStartTime = moment(shiftStartTimeRaw.trim(), ['hh:mma', 'h:mma'], true);
                    hasTodayShiftStarted = moment().isSameOrAfter(shiftStartTime);
                }

                let status = null;
                let absentDays = 0;
                let leaveDays = 0;

                // if (!todayAttendance && !todayLeave && !todayHoliday && isTomorrowWeekOff) {
                //   status = "Long Absent";
                // } else if (todayLeave && isTomorrowWeekOff) {
                //   status = "Long Leave";
                // }
                // if (isTomorrowWeekOff) {
                //   console.log(isTomorrowWeekOff, isTodayWorking, hasTodayShiftStarted, !todayAttendance, !todayHoliday)
                //   console.log(user?.username, (isTomorrowWeekOff && isTodayWorking && hasTodayShiftStarted && !todayAttendance && !todayHoliday), loginusershift)
                // }
                if (isTomorrowWeekOff && isTodayWorking && hasTodayShiftStarted && !todayAttendance && !todayHoliday) {
                    if (!todayLeave) {
                        // console.log(user.username, "Long Absent")
                        status = 'Long Absent';
                        absentDays = 1;
                        leaveDays = 0;
                    } else if (todayLeave) {
                        // console.log(user.username, "Long Leave")
                        status = 'Long Leave';
                        absentDays = 0;
                        leaveDays = 1;
                    }
                } else {
                    const pastStatus = checkStatusForPast3Days(userId, user.empcode, user.companyname, weekOffDays);
                    status = pastStatus.status;
                    absentDays = pastStatus.absentDays;
                    leaveDays = pastStatus.leaveDays;
                }

                return {
                    ...user,
                    attendanceStatus: !!status,
                    noticePeriodStatus: false,
                    livestatus: status ? false : null,
                    userstatus: determineStatus(status),
                    longAbsentCount: absentDays,
                    longLeaveCount: leaveDays,
                };
            })
        );

        const resolvedUsers = await Promise.all(promises);

        const resultAccessFilteredBefore = resolvedUsers.filter((user) => user.userstatus && user.userstatus !== 'Long Leave');

        const resultAccessFiltered = resultAccessFilteredBefore?.map((user) => {
            const userId = user._id.toString();

            const checklistItem = checklistData.find((item) => item.commonid === userId);
            // let weekOffDays = [];
            // if (user.boardingLog && user.boardingLog.length > 0) {
            //   const lastBoardingLog = user.boardingLog[user.boardingLog.length - 1];
            //   weekOffDays = lastBoardingLog.weekoff || [];
            // }
            const userLeaves = leaveWithCheckListSample?.filter((leave) => leave.employeeid === user.empcode && leave.employeename === user.companyname);
            // const { status, absentDays, leaveDays } = checkStatusForPast3Days(userId, user.empcode, user.companyname, weekOffDays);

            return {
                ...user,

                checklistassigned: !!checklistItem,
                leaveDetails: userLeaves,
                longleaveabsentaprooveddatechecklist: checklistItem?.longleaveabsentaprooveddatechecklist,
            };
        });
        // .filter((user) => user.userstatus && user.userstatus !== 'Long Leave'); // Filter out users without attendance status

        const enrichedLeaveAttendanceUsers = overallRestrictList?.length > 0 ? resultAccessFiltered?.filter((data) => overallRestrictList?.includes(data?.companyname)) : [];
        return res.status(200).json({
            filterallDatauser: enrichedLeaveAttendanceUsers,
            tableName: filterin,
            DataAccessMode
        });
    } catch (err) {
        console.log(err, "err")
        return res.status(500).json({ error: 'Internal server error' });
    }
});

exports.getAlluserDataFilterLongAutoClockOutHierarchy = catchAsyncErrors(async (req, res) => {
    try {
        let filteredUsers, filterQuerys;
        let hierarchy,
            secondaryhierarchyfinal,
            tertiaryhierarchyfinal,
            primaryhierarchyfinal,
            hierarchyfilter,
            filteredoverall,
            reportingtobaseduser,
            hierarchyfilter1,
            hierarchyfilter2,
            hierarchySecond,
            hierarchyMap,
            resulted = [],
            resultedTeam = [],
            myallTotalNames,
            hierarchyFinal,
            DataAccessMode = false,
            hierarchyDefault;
        const { company, branch, unit, team, filterin, module, submodule, mainpage, subpage, subsubpage, status, listpageaccessmode } = req.body;

        let levelFinal = req.body?.sector === 'all' ? ['Primary', 'Secondary', 'Tertiary'] : [req.body?.sector];
        let answer = await Hirerarchi.aggregate([
            {
                $match: {
                    supervisorchoose: req?.body?.username, // Match supervisorchoose with username
                    level: { $in: levelFinal }, // Corrected unmatched quotation mark
                },
            },
            {
                $lookup: {
                    from: 'reportingheaders',
                    let: {
                        teamControlsArray: {
                            $ifNull: ['$pagecontrols', []],
                        },
                    },
                    pipeline: [
                        {
                            $match: {
                                $expr: {
                                    $and: [
                                        {
                                            $in: ['$name', '$$teamControlsArray'],
                                        }, // Check if 'name' is in 'teamcontrols' array
                                        {
                                            $in: [
                                                req?.body?.pagename,
                                                '$reportingnew', // Check if 'menuteamloginstatus' is in 'reportingnew' array
                                            ],
                                        }, // Additional condition for reportingnew array
                                    ],
                                },
                            },
                        },
                    ],
                    as: 'reportData', // The resulting matched documents will be in this field
                },
            },
            {
                $project: {
                    supervisorchoose: 1,
                    employeename: 1,
                    reportData: 1,
                },
            },
        ]);


        // Manager Condition Without Supervisor
        const HierarchySupervisorFind = await Hirerarchi.find({ supervisorchoose: req?.body?.username });
        DataAccessMode = req.body.role?.some(role => role.toLowerCase() === "manager") && HierarchySupervisorFind?.length === 0;
        const { uniqueNames, pageControlsData } = await Hierarchyfilter(levelFinal, req?.body?.pagename);



        let restrictList = answer?.filter((data) => data?.reportData?.length > 0)?.flatMap((Data) => Data?.employeename);

        const today = moment();
        const pastThreeDaysISO = [
            today.clone().format('YYYY-MM-DD'),
            today.clone().subtract(1, 'days').format('YYYY-MM-DD'),
            today.clone().subtract(2, 'days').format('YYYY-MM-DD'),
            // today.clone().subtract(3, "days").format("YYYY-MM-DD"),
        ];
        let filterQuery = {
            enquirystatus: {
                $nin: ['Enquiry Purpose'],
            },
            resonablestatus: {
                $nin: ['Not Joined', 'Postponed', 'Rejected', 'Closed', 'Releave Employee', 'Absconded', 'Hold', 'Terminate'],
            },
            doj: getDojFilter(),
            ...(listpageaccessmode === 'Reporting to Based' ? { reportingto: req.body.username } : {}),
        };

        // if (Array.isArray(company) && company.length > 0) {
        //     filterQuery.company = { $in: company };
        // }

        // if (Array.isArray(branch) && branch.length > 0) {
        //     filterQuery.branch = { $in: branch };
        // }

        // if (Array.isArray(unit) && unit.length > 0) {
        //     filterQuery.unit = { $in: unit };
        // }

        // if (Array.isArray(team) && team.length > 0) {
        //     filterQuery.team = { $in: team };
        // }

        const removeEmptyArrays = (obj) => {
            return Object.fromEntries(Object.entries(obj).filter(([key, value]) => !Array.isArray(value) || value.length > 0));
        };

        filterQuerys = removeEmptyArrays(filterQuery);
        let resulting = await User.find(filterQuerys, {
            resonablestatus: 1,
            company: 1,
            branch: 1,
            unit: 1,
            team: 1,
            empcode: 1,
            companyname: 1,
            longleaveabsentaprooveddate: 1,
            // boardingLog: 1, // Include boardingLog in the result
            username: 1,
            originalpassword: 1,
            autoclockoutreleasedates: 1,
            firstname: 1,
            lastname: 1,
            aadhar: 1,
            panno: 1,
            dob: 1,
            pstreet: 1,
            pcity: 1,
            ppincode: 1,
            pstate: 1,
            pgenerateviapincode: 1,
            pvillageorcity: 1,
            pdistrict: 1,
            cgenerateviapincode: 1,
            cvillageorcity: 1,
            cdistrict: 1,
            doj: 1,
            pcountry: 1,
        }).lean();

        if ((req.body.hierachy === 'My Hierarchy List' && listpageaccessmode === 'Hierarchy Based') || listpageaccessmode === 'Overall') {
            hierarchy = await Hirerarchi.find({
                supervisorchoose: req.body.username,
                level: req.body.sector,
            });
            hierarchyDefault = await Hirerarchi.find({
                supervisorchoose: req.body.username,
            });

            let answerDef = hierarchyDefault.map((data) => data.employeename);
            hierarchyFinal = req.body.sector === 'all' ? (answerDef.length > 0 ? [].concat(...answerDef) : []) : hierarchy.length > 0 ? [].concat(...hierarchy.map((item) => item.employeename)) : [];
            hierarchyMap = hierarchyFinal.length > 0 ? hierarchyFinal : [];

            hierarchyfilter = await Hirerarchi.find({
                supervisorchoose: req.body.username,
                level: 'Primary',
            });
            primaryhierarchy = hierarchyfilter.map((item) => item.employeename[0]) ? hierarchyfilter.map((item) => item.employeename[0]) : [];

            hierarchyfilter1 = await Hirerarchi.find({
                supervisorchoose: req.body.username,
                level: 'Secondary',
            });
            secondaryhierarchy = hierarchyfilter1.map((item) => item.employeename[0]) ? hierarchyfilter1.map((item) => item.employeename[0]) : [];

            hierarchyfilter2 = await Hirerarchi.find({
                supervisorchoose: req.body.username,
                level: 'Tertiary',
            });
            tertiaryhierarchy = hierarchyfilter2.map((item) => item.employeename[0]) ? hierarchyfilter2.map((item) => item.employeename[0]) : [];

            resulted = resulting
                .map((userObj) => {
                    const matchingHierarchy = hierarchyDefault.find((hierarchyObj) => hierarchyObj.employeename[0] == userObj.companyname);
                    return {
                        ...userObj,
                        companyname: userObj.companyname,
                        unit: userObj.unit,
                        department: userObj.department,
                        team: userObj.team,
                        branch: userObj.branch,
                        doj: userObj.doj,
                        dot: userObj.dot,
                        empcode: userObj.empcode,
                        floor: userObj.floor,
                        designation: userObj.designation,
                        shiftallot: userObj.shiftallot,
                        shifttiming: userObj.shifttiming,
                        boardingLog: userObj.boardingLog,
                        role: userObj.role,
                        weekoff: userObj.weekoff,
                        company: userObj.company,
                        username: userObj.username,
                        _id: userObj._id,
                        control: matchingHierarchy ? matchingHierarchy.control : '',
                    };
                })
                .filter((data) => hierarchyMap.includes(data.companyname));
        }

        if ((req.body.hierachy === 'All Hierarchy List' && listpageaccessmode === 'Hierarchy Based') || listpageaccessmode === 'Overall') {
            hierarchySecond = await Hirerarchi.find({}, { employeename: 1, supervisorchoose: 1, level: 1, control: 1 });
            hierarchyDefault = await Hirerarchi.find({
                supervisorchoose: req.body.username,
            });

            let answerDef = hierarchyDefault.map((data) => data.employeename).flat();

            function findEmployeesRecursive(currentSupervisors, processedSupervisors, users) {
                const filteredData = hierarchySecond.filter((item) => item.supervisorchoose.some((supervisor) => currentSupervisors.includes(supervisor) && !processedSupervisors.has(supervisor)));

                if (filteredData.length === 0) {
                    return users;
                }

                const newEmployees = filteredData.reduce((employees, item) => {
                    employees.push(...item.employeename);
                    processedSupervisors.add(item.supervisorchoose[0]); // Assuming each item has only one supervisorchoose
                    return employees;
                }, []);

                const uniqueNewEmployees = [...new Set(newEmployees)];
                users = [...users, ...filteredData];

                return findEmployeesRecursive(uniqueNewEmployees, processedSupervisors, users);
            }

            const processedSupervisors = new Set();
            const filteredOverallItem = findEmployeesRecursive(answerDef, processedSupervisors, []);
            let answerDeoverall = filteredOverallItem.filter((data) => (req.body.sector == 'all' ? ['Primary', 'Secondary', 'Tertiary'].includes(data.level) : data.level == req.body.sector)).map((item) => item.employeename[0]);

            resultedTeam = resulting
                .map((userObj) => {
                    const matchingHierarchycontrol = filteredOverallItem.find((hierarchyObj) => hierarchyObj.employeename[0] == userObj.companyname);

                    return {
                        ...userObj,
                        companyname: userObj.companyname,
                        unit: userObj.unit,
                        department: userObj.department,
                        team: userObj.team,
                        branch: userObj.branch,
                        doj: userObj.doj,
                        dot: userObj.dot,
                        empcode: userObj.empcode,
                        floor: userObj.floor,
                        designation: userObj.designation,
                        shiftallot: userObj.shiftallot,
                        shifttiming: userObj.shifttiming,
                        boardingLog: userObj.boardingLog,
                        role: userObj.role,
                        weekoff: userObj.weekoff,
                        company: userObj.company,
                        username: userObj.username,
                        _id: userObj._id,
                        level: matchingHierarchycontrol ? matchingHierarchycontrol.level : '',
                        control: matchingHierarchycontrol ? matchingHierarchycontrol.control : '',
                    };
                })
                .filter((data) => answerDeoverall.includes(data.companyname));

            let hierarchyallfinal = await Hirerarchi.find({
                employeename: { $in: answerDeoverall.map((item) => item) },
                level: req.body.sector,
            });
            hierarchyFinal = req.body.sector === 'all' ? (answerDeoverall.length > 0 ? [].concat(...answerDeoverall) : []) : hierarchyallfinal.length > 0 ? [].concat(...hierarchyallfinal.map((item) => item.employeename)) : [];

            primaryhierarchyall = resultedTeam.filter((item) => item.level == 'Primary').map((item) => item.companyname);

            secondaryhierarchyall = resultedTeam.filter((item) => item.level == 'Secondary').map((item) => item.companyname);

            tertiaryhierarchyall = resultedTeam.filter((item) => item.level == 'Tertiary').map((item) => item.companyname);
        }

        //my + all hierarchy list dropdown

        if (((req.body.hierachy === 'My + All Hierarchy List' || req.body.hierachy === 'All Hierarchy List' || req.body.hierachy === 'My Hierarchy List') && listpageaccessmode === 'Hierarchy Based') || listpageaccessmode === 'Overall') {
            hierarchySecond = await Hirerarchi.find({}, { employeename: 1, supervisorchoose: 1, level: 1, control: 1 });
            hierarchyDefault = await Hirerarchi.find({
                supervisorchoose: req.body.username,
            });

            let answerDef = hierarchyDefault.map((data) => data.employeename);

            function findEmployeesRecursive(currentSupervisors, processedSupervisors, users) {
                const filteredData = hierarchySecond.filter((item) => item.supervisorchoose.some((supervisor) => currentSupervisors.includes(supervisor) && !processedSupervisors.has(supervisor)));

                if (filteredData.length === 0) {
                    return users;
                }

                const newEmployees = filteredData.reduce((employees, item) => {
                    employees.push(...item.employeename);
                    processedSupervisors.add(item.supervisorchoose[0]); // Assuming each item has only one supervisorchoose
                    return employees;
                }, []);

                const uniqueNewEmployees = [...new Set(newEmployees)];
                users = [...users, ...filteredData];

                return findEmployeesRecursive(uniqueNewEmployees, processedSupervisors, users);
            }

            const processedSupervisors = new Set();
            const filteredOverallItem = findEmployeesRecursive([req.body.username], processedSupervisors, []);
            let answerDeoverall = filteredOverallItem.filter((data) => (req.body.sector == 'all' ? ['Primary', 'Secondary', 'Tertiary'].includes(data.level) : data.level == req.body.sector)).map((item) => item.employeename[0]);

            filteredoverall = resulting
                .map((userObj) => {
                    const matchingHierarchycontrol = filteredOverallItem.find((hierarchyObj) => hierarchyObj.employeename[0] == userObj.companyname);
                    return {
                        ...userObj,
                        companyname: userObj.companyname,
                        unit: userObj.unit,
                        department: userObj.department,
                        team: userObj.team,
                        branch: userObj.branch,
                        doj: userObj.doj,
                        dot: userObj.dot,
                        empcode: userObj.empcode,
                        floor: userObj.floor,
                        designation: userObj.designation,
                        shiftallot: userObj.shiftallot,
                        shifttiming: userObj.shifttiming,
                        boardingLog: userObj.boardingLog,
                        role: userObj.role,
                        weekoff: userObj.weekoff,
                        company: userObj.company,
                        username: userObj.username,
                        _id: userObj._id,
                        level: matchingHierarchycontrol ? matchingHierarchycontrol.level : '',
                        control: matchingHierarchycontrol ? matchingHierarchycontrol.control : '',
                    };
                })
                .filter((data) => answerDeoverall.includes(data.companyname));

            let hierarchyallfinal = await Hirerarchi.find({
                employeename: { $in: answerDeoverall.map((item) => item) },
                level: req.body.sector,
            });
            hierarchyFinal = req.body.sector === 'all' ? (answerDeoverall.length > 0 ? [].concat(...answerDeoverall) : []) : hierarchyallfinal.length > 0 ? [].concat(...hierarchyallfinal.map((item) => item.employeename)) : [];

            primaryhierarchyfinal = filteredoverall.filter((item) => item.level == 'Primary').map((item) => item.companyname);

            secondaryhierarchyfinal = filteredoverall.filter((item) => item.level == 'Secondary').map((item) => item.companyname);

            tertiaryhierarchyfinal = filteredoverall.filter((item) => item.level == 'Tertiary').map((item) => item.companyname);
        }

        if (listpageaccessmode === 'Reporting to Based') {
            reportingtobaseduser = resulting.map((userObj) => {
                return {
                    ...userObj,
                    companyname: userObj.companyname,
                    unit: userObj.unit,
                    department: userObj.department,
                    team: userObj.team,
                    branch: userObj.branch,
                    doj: userObj.doj,
                    dot: userObj.dot,
                    empcode: userObj.empcode,
                    floor: userObj.floor,
                    designation: userObj.designation,
                    shiftallot: userObj.shiftallot,
                    shifttiming: userObj.shifttiming,
                    boardingLog: userObj.boardingLog,
                    role: userObj.role,
                    weekoff: userObj.weekoff,
                    company: userObj.company,
                    username: userObj.username,
                    _id: userObj._id,
                    level: '',
                    control: '',
                };
            });
        }


        myallTotalNames = DataAccessMode ? uniqueNames : filteredoverall?.map((data) => data?.companyname);

        let finalResult = await User.find({ ...filterQuerys, companyname: { $in: myallTotalNames } }, {
            resonablestatus: 1,
            company: 1,
            branch: 1,
            unit: 1,
            team: 1,
            empcode: 1,
            companyname: 1,
            longleaveabsentaprooveddate: 1,
            // boardingLog: 1, // Include boardingLog in the result
            username: 1,
            originalpassword: 1,
            autoclockoutreleasedates: 1,
            firstname: 1,
            lastname: 1,
            aadhar: 1,
            panno: 1,
            dob: 1,
            pstreet: 1,
            pcity: 1,
            ppincode: 1,
            pstate: 1,
            pgenerateviapincode: 1,
            pvillageorcity: 1,
            pdistrict: 1,
            cgenerateviapincode: 1,
            cvillageorcity: 1,
            cdistrict: 1,
            doj: 1,
            pcountry: 1,
        }).lean();

        filteredUsers = DataAccessMode ? finalResult :
            (req.body.hierachy === 'My Hierarchy List' && (listpageaccessmode === 'Hierarchy Based' || listpageaccessmode === 'Overall')
                ? resulted
                : req.body.hierachy === 'All Hierarchy List' && (listpageaccessmode === 'Hierarchy Based' || listpageaccessmode === 'Overall')
                    ? resultedTeam
                    : req.body.hierachy === 'My + All Hierarchy List' && (listpageaccessmode === 'Hierarchy Based' || listpageaccessmode === 'Overall')
                        ? filteredoverall
                        : reportingtobaseduser);




        const restrictTeam = await Hirerarchi.aggregate([
            {
                $match: {
                    supervisorchoose: { $in: filteredoverall?.map((data) => data?.companyname) }, // Match supervisorchoose with username
                    level: { $in: levelFinal }, // Corrected unmatched quotation mark
                },
            },
            {
                $lookup: {
                    from: 'reportingheaders',
                    let: {
                        teamControlsArray: {
                            $ifNull: ['$pagecontrols', []],
                        },
                    },
                    pipeline: [
                        {
                            $match: {
                                $expr: {
                                    $and: [
                                        {
                                            $in: ['$name', '$$teamControlsArray'],
                                        }, // Check if 'name' is in 'teamcontrols' array
                                        {
                                            $in: [
                                                req?.body?.pagename,
                                                '$reportingnew', // Check if 'menuteamloginstatus' is in 'reportingnew' array
                                            ],
                                        }, // Additional condition for reportingnew array
                                    ],
                                },
                            },
                        },
                    ],
                    as: 'reportData', // The resulting matched documents will be in this field
                },
            },
            {
                $project: {
                    supervisorchoose: 1,
                    employeename: 1,
                    reportData: 1,
                },
            },
        ]);
        let restrictListTeam = DataAccessMode ? pageControlsData : restrictTeam?.filter((data) => data?.reportData?.length > 0)?.flatMap((Data) => Data?.employeename);
        let overallRestrictList = DataAccessMode ? restrictListTeam : (req.body.hierachy === 'myhierarchy' ? restrictList : req.body.hierachy === 'allhierarchy' ? restrictListTeam : [...restrictList, ...restrictListTeam]);

        const currentDate = moment().format('DD-MM-YYYY');

        // const resultAccessFiltered = filteredUsers

        const AttControlCriteria = await ControlCriteria.findOne().sort({ createdAt: -1 }).exec();

        const autoCLockOutCount = AttControlCriteria?.allowedautoclockoutcount ? Number(AttControlCriteria.allowedautoclockoutcount) : 0;
        const finalautoCLockOutCount = autoCLockOutCount + 1;

        // const usersList = await User.find(filterQuery, {
        //   username: 1,
        //   empcode: 1,
        //   companyname: 1,
        //   autoclockoutreleasedates: 1,
        // }).lean();

        // Step 2: Controlled batch processing using p-limit

        const limit = pLimit(10);

        const usersWithAutoClockOutData = await Promise.all(
            filteredUsers.map((user) =>
                limit(async () => {
                    const recentAttendance = await Attendance.find({ userid: user._id }, { autoclockout: 1, date: 1 }).sort({ createdAt: -1 }).limit(finalautoCLockOutCount).lean();

                    const isAutoClockOutUser = recentAttendance.length === finalautoCLockOutCount && recentAttendance.every((entry) => entry.autoclockout === true);

                    return isAutoClockOutUser
                        ? {
                            ...user,
                            recentAttendance, // Include attendance data
                        }
                        : null;
                })
            )
        );

        // Step 3: Clean out nulls
        const resultAccessFiltered = usersWithAutoClockOutData.filter(Boolean);
        // console.log(resultAccessFiltered, "resultAccessFiltered");
        // console.log(resultAccessFiltered?.length, "resultAccessFiltered?.length");

        const enrichedLeaveAttendanceUsers = overallRestrictList?.length > 0 ? resultAccessFiltered?.filter((data) => overallRestrictList?.includes(data?.companyname)) : [];
        return res.status(200).json({
            filterallDatauser: enrichedLeaveAttendanceUsers,
            tableName: filterin,
            currentDate,
            resultedTeam,
            DataAccessMode
        });
    } catch (err) {
        console.log(err, 'err');
        return res.status(500).json({ error: 'Internal server error' });
    }
});

exports.getAlluserDataFilterLongAbsendHierarchyHome = catchAsyncErrors(
    async (req, res) => {
        try {
            let filteredUsers, filterQuerys;
            let hierarchy,
                tertiaryhierarchyfinal,
                hierarchyfilter,
                filteredoverall,
                reportingtobaseduser,
                hierarchyfilter1,
                hierarchyfilter2,
                hierarchySecond,
                hierarchyMap,
                resulted,
                resultedTeam,
                hierarchyFinal,
                hierarchyDefault;
            const {
                company,
                branch,
                unit,
                team,
                filterin,
                module,
                submodule,
                mainpage,
                subpage,
                subsubpage,
                status,
                listpageaccessmode,
            } = req.body;
            const today = moment();
            const pastThreeDaysISO = [
                today.clone().format("YYYY-MM-DD"),
                today.clone().subtract(1, "days").format("YYYY-MM-DD"),
                today.clone().subtract(2, "days").format("YYYY-MM-DD"),
                today.clone().subtract(3, "days").format("YYYY-MM-DD"),
            ];
            let filterQuery = {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
                resonablestatus: {
                    $nin: [
                        "Not Joined",
                        "Postponed",
                        "Rejected",
                        "Closed",
                        "Releave Employee",
                        "Absconded",
                        "Hold",
                        "Terminate",
                    ],
                },
                doj: {
                    $nin: pastThreeDaysISO, // Exclude users whose date of joining falls in the last three days
                },
                ...(listpageaccessmode === "Reporting to Based"
                    ? { reportingto: req.body.username }
                    : {}),
            };

            if (Array.isArray(company) && company.length > 0) {
                filterQuery.company = { $in: company };
            }

            if (Array.isArray(branch) && branch.length > 0) {
                filterQuery.branch = { $in: branch };
            }

            if (Array.isArray(unit) && unit.length > 0) {
                filterQuery.unit = { $in: unit };
            }

            if (Array.isArray(team) && team.length > 0) {
                filterQuery.team = { $in: team };
            }

            const removeEmptyArrays = (obj) => {
                return Object.fromEntries(
                    Object.entries(obj).filter(
                        ([key, value]) => !Array.isArray(value) || value.length > 0
                    )
                );
            };

            filterQuerys = removeEmptyArrays(filterQuery);
            let resulting = await User.find(filterQuerys, {
                resonablestatus: 1,
                company: 1,
                branch: 1,
                unit: 1,
                team: 1,
                empcode: 1,
                companyname: 1,
                longleaveabsentaprooveddate: 1,
                boardingLog: 1,
                attendancemode: 1, // Include boardingLog in the result

                username: 1,
                originalpassword: 1,
                firstname: 1,
                lastname: 1,
                aadhar: 1,
                panno: 1,
                dob: 1,
                pstreet: 1,
                pcity: 1,
                ppincode: 1,
                pstate: 1,
                doj: 1,
                pcountry: 1,
            }).lean();


            //my + all hierarchy list dropdown

            if (
                (req.body.hierachy === "My + All Hierarchy List" &&
                    listpageaccessmode === "Hierarchy Based") ||
                listpageaccessmode === "Overall"
            ) {
                hierarchySecond = await Hirerarchi.find(
                    {},
                    { employeename: 1, supervisorchoose: 1, level: 1, control: 1 }
                );
                hierarchyDefault = await Hirerarchi.find({
                    supervisorchoose: req.body.username,

                });

                let answerDef = hierarchyDefault.map((data) => data.employeename);

                function findEmployeesRecursive(
                    currentSupervisors,
                    processedSupervisors,
                    users
                ) {
                    const filteredData = hierarchySecond.filter((item) =>
                        item.supervisorchoose.some(
                            (supervisor) =>
                                currentSupervisors.includes(supervisor) &&
                                !processedSupervisors.has(supervisor)
                        )
                    );

                    if (filteredData.length === 0) {
                        return users;
                    }

                    const newEmployees = filteredData.reduce((employees, item) => {
                        employees.push(...item.employeename);
                        processedSupervisors.add(item.supervisorchoose[0]); // Assuming each item has only one supervisorchoose
                        return employees;
                    }, []);

                    const uniqueNewEmployees = [...new Set(newEmployees)];
                    users = [...users, ...filteredData];

                    return findEmployeesRecursive(
                        uniqueNewEmployees,
                        processedSupervisors,
                        users
                    );
                }

                const processedSupervisors = new Set();
                const filteredOverallItem = findEmployeesRecursive(
                    [req.body.username],
                    processedSupervisors,
                    []
                );
                let answerDeoverall = filteredOverallItem
                    .filter((data) =>
                        req.body.sector == "all"
                            ? ["Primary", "Secondary", "Tertiary"].includes(data.level)
                            : data.level == req.body.sector
                    )
                    .map((item) => item.employeename[0]);

                filteredoverall = resulting
                    .map((userObj) => {
                        const matchingHierarchycontrol = filteredOverallItem.find(
                            (hierarchyObj) =>
                                hierarchyObj.employeename[0] == userObj.companyname
                        );
                        return {
                            ...userObj,
                            companyname: userObj.companyname,
                            unit: userObj.unit,
                            department: userObj.department,
                            team: userObj.team,
                            branch: userObj.branch,
                            doj: userObj.doj,
                            dot: userObj.dot,
                            empcode: userObj.empcode,
                            floor: userObj.floor,
                            designation: userObj.designation,
                            shiftallot: userObj.shiftallot,
                            shifttiming: userObj.shifttiming,
                            boardingLog: userObj.boardingLog,
                            role: userObj.role,
                            weekoff: userObj.weekoff,
                            company: userObj.company,
                            username: userObj.username,
                            _id: userObj._id,
                            level: matchingHierarchycontrol
                                ? matchingHierarchycontrol.level
                                : "",
                            control: matchingHierarchycontrol
                                ? matchingHierarchycontrol.control
                                : "",
                        };
                    })
                    .filter((data) => answerDeoverall.includes(data.companyname));

                let hierarchyallfinal = await Hirerarchi.find({
                    employeename: { $in: answerDeoverall.map((item) => item) },
                    level: req.body.sector,
                });
                hierarchyFinal =
                    req.body.sector === "all"
                        ? answerDeoverall.length > 0
                            ? [].concat(...answerDeoverall)
                            : []
                        : hierarchyallfinal.length > 0
                            ? [].concat(...hierarchyallfinal.map((item) => item.employeename))
                            : [];

                primaryhierarchyfinal = filteredoverall
                    .filter((item) => item.level == "Primary")
                    .map((item) => item.companyname);

                secondaryhierarchyfinal = filteredoverall
                    .filter((item) => item.level == "Secondary")
                    .map((item) => item.companyname);

                tertiaryhierarchyfinal = filteredoverall
                    .filter((item) => item.level == "Tertiary")
                    .map((item) => item.companyname);
            }

            if (listpageaccessmode === "Reporting to Based") {
                reportingtobaseduser = resulting.map((userObj) => {
                    return {
                        ...userObj,
                        companyname: userObj.companyname,
                        unit: userObj.unit,
                        department: userObj.department,
                        team: userObj.team,
                        branch: userObj.branch,
                        doj: userObj.doj,
                        dot: userObj.dot,
                        empcode: userObj.empcode,
                        floor: userObj.floor,
                        designation: userObj.designation,
                        shiftallot: userObj.shiftallot,
                        shifttiming: userObj.shifttiming,
                        boardingLog: userObj.boardingLog,
                        role: userObj.role,
                        weekoff: userObj.weekoff,
                        company: userObj.company,
                        username: userObj.username,
                        _id: userObj._id,
                        level: "",
                        control: "",
                    };
                });
            }

            filteredUsers =
                req.body.hierachy === "My + All Hierarchy List" &&
                    (listpageaccessmode === "Hierarchy Based" ||
                        listpageaccessmode === "Overall")
                    ? filteredoverall
                    : reportingtobaseduser;

            const currentDateChecklist = moment().format("DD-MM-YYYY");
            const pastThreeAttendaysDays = [
                today.clone().format("DD-MM-YYYY"),
                today.clone().subtract(1, "days").format("DD-MM-YYYY"),
                today.clone().subtract(2, "days").format("DD-MM-YYYY"),
                today.clone().subtract(3, "days").format("DD-MM-YYYY"),
            ];

            const pastThreeLeaveDays = [
                today.clone().format("DD/MM/YYYY"),
                today.clone().subtract(1, "days").format("DD/MM/YYYY"),

                today.clone().subtract(2, "days").format("DD/MM/YYYY"),
                today.clone().subtract(3, "days").format("DD/MM/YYYY"),
            ];

            const [attendance, allLeaveStatus, holidays, checklistData] =
                await Promise.all([
                    Attendance.find(
                        {
                            date: {
                                $in: pastThreeAttendaysDays,
                            },
                        },
                        { date: 1, userid: 1 }
                    ).lean(),

                    ApplyLeave.find(
                        {
                            date: { $in: pastThreeLeaveDays },
                            status: { $nin: ["Rejected"] },
                        },
                        { employeename: 1, employeeid: 1, date: 1 }
                    ).lean(),

                    Holiday.find(
                        {
                            date: { $in: pastThreeDaysISO },
                        },
                        {
                            date: 1,
                            employee: 1,
                            company: 1,
                            applicablefor: 1,
                            unit: 1,
                            team: 1,
                        }
                    ).lean(),
                    MyCheckList.find({
                        module,
                        submodule,
                        mainpage,
                        subpage,
                        subsubpage,
                        // status: { $ne: "completed" },
                        longleaveabsentaprooveddatechecklist: {
                            $in: [currentDateChecklist],
                        },
                    }),
                ]);

            const attendanceMap = attendance.reduce((acc, item) => {
                const userId = item.userid.toString();
                const date = moment(item.date, "DD-MM-YYYY").format("DD/MM/YYYY");
                if (!acc[userId]) {
                    acc[userId] = [];
                }
                acc[userId].push(date);
                return acc;
            }, {});

            let allUserEmpname = filteredUsers.map((user) => user.companyname)
            const myCheckList = await MyCheckList.find({ candidatename: { $in: allUserEmpname } }).lean();
            let leaveWithCheckList = allLeaveStatus.map((item) => {
                let foundData = myCheckList?.find(
                    (dataNew) => dataNew.commonid == item._id
                );
                let areAllGroupsCompleted = foundData?.groups?.every(
                    (itemNew) => (itemNew.data !== undefined && itemNew.data !== "") || itemNew.files !== undefined
                );

                if (areAllGroupsCompleted) {
                    return {
                        ...item,
                        updatestatus: "Completed",
                    };
                }
                return null;
            }).filter(item => item);

            // Create a map for fast lookup of leave records
            const leaveMap = leaveWithCheckList.reduce((acc, item) => {
                const userKey = `${item.employeeid}_${item.employeename}`;
                const leaveDates = item.date.map((date) =>
                    moment(date, "DD/MM/YYYY").format("DD/MM/YYYY")
                );
                if (!acc[userKey]) {
                    acc[userKey] = [];
                }
                acc[userKey].push(...leaveDates);
                return acc;
            }, {});

            const employeeMatchesUser = (user, holiday) => {
                return (
                    holiday.company.includes(user.company) &&
                    holiday.applicablefor.includes(user.branch) &&
                    holiday.unit.includes(user.unit) &&
                    holiday.team.includes(user.team) &&
                    (holiday.employee.includes(user.companyname) ||
                        holiday.employee.includes("ALL"))
                );
            };

            const holidayMap = holidays.reduce((acc, item) => {
                const date = moment(item.date).format("DD/MM/YYYY");

                filteredUsers.forEach((user) => {
                    if (employeeMatchesUser(user, item)) {
                        if (!acc[user.empcode]) {
                            acc[user.empcode] = [];
                        }
                        acc[user.empcode].push(date);
                    }
                });

                return acc;
            }, {});

            const checkStatusForPast3Days = (
                userId,
                empcode,
                employeename,
                weekOffDays
            ) => {
                const userKey = `${empcode}_${employeename}`;
                let absentDays = 0;
                let leaveDays = 0;
                let holidayDays = 0;

                for (let date of pastThreeLeaveDays) {
                    // const dayOfWeek = moment(date, "DD/MM/YYYY").format("dddd"); // Get day of the week

                    // if (weekOffDays.includes(dayOfWeek)) {
                    //   continue; // Skip week off days
                    // }

                    if (attendanceMap[userId] && attendanceMap[userId].includes(date)) {
                        continue; // User was present on this date
                    } else if (leaveMap[userKey] && leaveMap[userKey].includes(date)) {
                        leaveDays++; // User was on leave on this date
                    } else if (
                        holidayMap[empcode] &&
                        holidayMap[empcode].includes(date)
                    ) {
                        holidayDays++; // Holiday on this date
                    } else {
                        absentDays++; // User was absent on this date
                    }
                }

                let status = null;
                if (absentDays >= 4) {
                    status = "Long Absent";
                } else if (leaveDays >= 4) {
                    status = "Long Leave";
                }

                return { status, absentDays, leaveDays, holidayDays };
            };

            const determineStatus = (attendanceStatus) => {
                return attendanceStatus ? attendanceStatus : null;
            };

            const enrichedLeaveAttendanceUsers = filteredUsers
                ?.map((user) => {
                    const userId = user._id.toString();

                    const checklistItem = checklistData.find(
                        (item) => item.commonid === userId
                    );
                    let weekOffDays = [];
                    if (user.boardingLog && user.boardingLog.length > 0) {
                        const lastBoardingLog =
                            user.boardingLog[user.boardingLog.length - 1];
                        weekOffDays = lastBoardingLog.weekoff || [];
                    }

                    const { status, absentDays, leaveDays } = checkStatusForPast3Days(
                        userId,
                        user.empcode,
                        user.companyname,
                        weekOffDays
                    );

                    return {
                        ...user,
                        attendanceStatus: !!status,
                        noticePeriodStatus: false,
                        livestatus: status ? false : null,
                        userstatus: determineStatus(status),
                        longAbsentCount: absentDays, // Long absent count
                        longLeaveCount: leaveDays, // Long leave count
                        checklistassigned: !!checklistItem,
                        longleaveabsentaprooveddatechecklist:
                            checklistItem?.longleaveabsentaprooveddatechecklist,
                    };
                })
                .filter((user) => user.userstatus && user.userstatus !== "Long Leave"); // Filter out users without attendance status


            return res.status(200).json({
                filterallDatauser: enrichedLeaveAttendanceUsers.length,
                tableName: filterin,

            });
        } catch (err) {
            return res.status(500).json({ error: "Internal server error" });
        }
    }
);
exports.getAllUserTotalShiftDaysHome = catchAsyncErrors(async (req, res, next) => {
    let resultshiftallot = [];
    let graceTime;
    let clockOutHours;
    let lateclockincount;
    let earlyclockoutcount;
    let onclockout;
    let earlyclockin;
    let earlyclockout;
    let lateclockin;
    let afterlateclockin;
    let beforeearlyclockout;
    let finaluser = [];
    const { page, pageSize,
    } = req.body;

    try {
        const currentDate = new Date();
        const currentMonth = currentDate.getMonth() + 1; // Months are zero-based, so add 1
        const currentYear = currentDate.getFullYear();

        const ismonth = currentMonth;
        const isyear = currentYear

        const monthNames = ["January", "February", "March", "April", "May", "June",
            "July", "August", "September", "October", "November", "December"
        ];

        let querydeptmonth = {
            monthname: monthNames[ismonth - 1],
            year: isyear
        }
        let [usersAll, depMonthSet, controlcriteria, holidays, leavetype] = await Promise.all([
            User.find(
                {
                    resonablestatus: {
                        $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
                    },
                    enquirystatus: {
                        $nin: ["Enquiry Purpose"],
                    },
                }, {}
            ).skip((page - 1) * pageSize).limit(pageSize),


            DepartmentMonth.find(querydeptmonth, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 }),
            ControlCriteria.find(),
            Holiday.find({}, { date: 1, company: 1, applicablefor: 1, unit: 1, team: 1, employee: 1, noofdays: 1 }),
            Leavetype.find({}, { leavetype: 1, code: 1 })
        ])

        const resultDateArray = depMonthSet.reduce((acc, curr) => {
            if (new Date(curr.fromdate) < new Date(acc.fromdate)) {
                acc.fromdate = curr.fromdate;
            }
            // Compare and update the latest todate
            if (new Date(curr.todate) > new Date(acc.todate)) {
                acc.todate = curr.todate;
            }
            return acc;
        }, {
            fromdate: depMonthSet[0].fromdate,
            todate: depMonthSet[0].todate
        });

        function formatDate(dateString) {
            const [day, month, year] = dateString.split("-");
            return `${year}-${month}-${day}`;
        }

        let attFromDate = (resultDateArray.fromdate)
        let attToDate = (resultDateArray.todate)

        const fromDateSet = [...new Set(depMonthSet.map(d => d.fromdate))];

        let users = usersAll.map(item => {
            let findUserDeprtment = item.department;

            if (item.departmentlog && item.departmentlog.length > 1) {
                // const findDept = item.departmentlog.find(dept => fromDateSet.includes(dept.startdate) );
                const sortedDepartmentLog = item.departmentlog.sort((a, b) => new Date(b.startdate) - new Date(a.startdate));

                const findDept = sortedDepartmentLog.find(dept =>
                    fromDateSet.includes(dept.startdate) ||
                    fromDateSet.some(fromDate => new Date(fromDate) > new Date(dept.startdate))
                );
                findUserDeprtment = findDept ? findDept.department : "";
            } else if (item.departmentlog && item.departmentlog.length > 0) {
                findUserDeprtment = new Date(item.doj) >= new Date(item.departmentlog[0].startdate) ? item.departmentlog[0].department : ""
            }

            // if (department.includes(findUserDeprtment)) {
            return {
                ...item._doc, // Use _doc to avoid including Mongoose metadata
                department: findUserDeprtment,
            };

            // }

            // return null; // Exclude users who don't match the department
        }).filter(item => item !== null);

        const userIds = users.map(user => user._id);
        const userCds = users.map(user => user.companyname);
        const [attendance, allLeaveStatus, permission] = await Promise.all([
            Attendance.find({ userid: { $in: userIds }, createdAt: { $gte: attFromDate, $lte: attToDate } }),
            ApplyLeave.find({ employeename: { $in: userCds } }),
            Permission.find({ employeename: { $in: userCds } }, { employeeid: 1, date: 1, status: 1, applytype: 1, compensationstatus: 1, compensationapplytype: 1, requesthours: 1, shiftmode: 1, })

        ])
        // graceTime = controlcriteria[0].gracetime;
        clockOutHours = controlcriteria[0].clockout;
        lateclockincount = controlcriteria[0].lateclockincount;
        earlyclockoutcount = controlcriteria[0].earlyclockoutcount;
        onclockout = controlcriteria[0].onclockout;
        earlyclockin = controlcriteria[0].earlyclockin;
        lateclockin = controlcriteria[0].lateclockin;
        earlyclockout = controlcriteria[0].earlyclockout;
        afterlateclockin = controlcriteria[0].afterlateclockin;
        beforeearlyclockout = controlcriteria[0].afterlateclockin;


        finaluser = users?.flatMap((item, index) => {

            let isEmployeeGrace = controlcriteria[0].todos && controlcriteria[0].todos.find(d => d.company === item.company &&
                d.branch === item.branch && d.unit === item.unit && d.team === item.team &&
                d.employeename === item.companyname
            )

            if (isEmployeeGrace) {
                graceTime = isEmployeeGrace.employeegracetime;
            }
            else {
                graceTime = controlcriteria[0].gracetime;
            }

            let userDates = [];


            // Remove duplicate entries with the most recent entry
            const uniqueEntriesDep = {};
            item.departmentlog?.forEach(entry => {
                const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                const key = entry.startdate;

                if (!(key in uniqueEntriesDep)) {
                    uniqueEntriesDep[key] = entry;
                }
            });

            const comparedDate = depMonthSet?.filter((d) => d.department === item.department);
            const dojDate = item?.boardingLog.length > 0 ?
                item?.boardingLog[0].startdate
                : item?.doj;

            if (comparedDate && comparedDate.length > 0) {
                comparedDate?.forEach((dep) => {
                    if (!dep.fromdate && !dep.todate) {
                        return '';
                    }

                    if (!item.doj) {
                        return "";
                    }

                    const [year2, month2, day2] = dojDate?.split('-').map(Number);
                    const joiningDate = new Date(year2, month2 - 1, day2);
                    const [year1, month1, day1] = dep.fromdate?.split('-').map(Number);
                    const [year, month, day] = dep.todate?.split('-').map(Number);
                    const lastDate = new Date(year, month - 1, day);
                    const firstDate = new Date(year1, month1 - 1, day1);


                    if (joiningDate < firstDate) {
                        // Check if the shift date is before or equal to the current date
                        if (lastDate >= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(firstDate);
                            // Loop through the dates in the range
                            while (startDate <= currentDateAttStatus) {
                                userDates.push({
                                    formattedDate: format(startDate, 'dd/MM/yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        } else if (lastDate <= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(firstDate);
                            // Loop through the dates in the range
                            while (startDate <= lastDate) {
                                userDates.push({
                                    formattedDate: format(startDate, 'dd/MM/yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        }
                    } else {
                        // Check if the shift date is before or equal to the current date
                        if (lastDate >= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(joiningDate);
                            // Loop through the dates in the range
                            while (startDate <= currentDateAttStatus) {
                                userDates.push({
                                    formattedDate: format(startDate, 'dd/MM/yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        }
                        else if (lastDate <= currentDateAttStatus) {
                            // If matched, push the range from 'fromdate' to 'todate'
                            const startDate = new Date(joiningDate);
                            // Loop through the dates in the range
                            while (startDate <= lastDate) {
                                userDates.push({
                                    formattedDate: format(startDate, 'dd/MM/yyyy'),
                                    dayName: format(startDate, 'EEEE'),
                                    dayCount: startDate.getDate(),
                                });
                                startDate.setDate(startDate.getDate() + 1);
                            }
                        }
                    }
                });
            }
            else {
                const [year2, month2, day2] = dojDate?.split('-').map(Number);
                const joiningDate = new Date(year2, month2 - 1, day2);
                // Calculate the start date of the month based on the selected month
                const startDate = new Date(isyear, ismonth - 1, 1);

                const endDate = new Date(startDate);
                endDate.setMonth(endDate.getMonth() + 1);
                endDate.setDate(endDate.getDate() - 1);

                if (joiningDate < startDate) {
                    // Check if the shift date is before or equal to the current date
                    if (endDate >= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            userDates.push({
                                formattedDate: format(currentDate1, 'dd/MM/yyyy'),
                                dayName: format(currentDate1, 'EEEE'),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    } else if (endDate <= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            userDates.push({
                                formattedDate: format(currentDate1, 'dd/MM/yyyy'),
                                dayName: format(currentDate1, 'EEEE'),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    }
                } else {
                    // Check if the shift date is before or equal to the current date
                    if (endDate >= currentDateAttStatus) {
                        // If matched, push the range from 'fromdate' to 'todate'
                        const startDate = new Date(joiningDate);
                        // Loop through the dates in the range
                        while (startDate <= currentDateAttStatus) {
                            userDates.push({
                                formattedDate: format(startDate, 'dd/MM/yyyy'),
                                dayName: format(startDate, 'EEEE'),
                                dayCount: startDate.getDate(),
                            });
                            startDate.setDate(startDate.getDate() + 1);
                        }
                    } else if (endDate <= currentDateAttStatus) {
                        let currentDate1 = new Date(startDate);

                        while (currentDate1 <= endDate) {
                            userDates.push({
                                formattedDate: format(currentDate1, 'dd/MM/yyyy'),
                                dayName: format(currentDate1, 'EEEE'),
                                dayCount: currentDate1.getDate(),
                            });
                            currentDate1.setDate(currentDate1.getDate() + 1);
                        }
                    }
                }
            }

            item.shiftallot?.map(allot => {
                resultshiftallot.push({ ...allot })
            })

            const filteredMatchingDoubleShiftItem = resultshiftallot?.filter(val => val && val.empcode === item.empcode && val.adjstatus === 'Approved');

            // Filter out the dates that have matching 'Shift Adjustment' todates
            let removedUserDates = userDates.filter(date => {
                // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
                const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem.find(item => item && item.todate === date.formattedDate && item.adjustmenttype === 'Shift Adjustment');

                // If there is no matching 'Shift Adjustment', keep the date
                return !matchingShiftAdjustmentToDate;
            });

            // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
            let uniqueEntries = new Set();

            // Iterate over removedUserDates and add unique entries to the Set
            userDates.forEach(date => {
                uniqueEntries.add(JSON.stringify({
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    shiftMode: 'Main Shift',
                    weekNumberInMonth: date.weekNumberInMonth,
                }));
            });

            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach(item => {
                const [day, month, year] = item._doc.adjdate?.split('/')
                let newFormattedDate = new Date(`${year}-${month}-${day}`);

                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(JSON.stringify({
                        formattedDate: item._doc.adjdate,
                        dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
                        dayCount: parseInt(moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")),
                        shiftMode: 'Second Shift',
                        weekNumberInMonth: (getWeekNumberInMonth(newFormattedDate) === 1 ? `${getWeekNumberInMonth(newFormattedDate)}st Week` :
                            getWeekNumberInMonth(newFormattedDate) === 2 ? `${getWeekNumberInMonth(newFormattedDate)}nd Week` :
                                getWeekNumberInMonth(newFormattedDate) === 3 ? `${getWeekNumberInMonth(newFormattedDate)}rd Week` :
                                    getWeekNumberInMonth(newFormattedDate) > 3 ? `${getWeekNumberInMonth(newFormattedDate)}th Week` : '')
                    }));
                }
            });

            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries).map(entry => JSON.parse(entry));

            function sortUserDates(dates) {
                return dates.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);
            const createdUserDates = sortedCreatedUserDates?.filter(d => {
                const filterData = userDates.some(val => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date) => {
                let filteredRowData = resultshiftallot?.filter((val) => val.empcode == item.empcode);
                const matchingItem = filteredRowData?.find(item => item && item.adjdate == date.formattedDate);
                const matchingItemAllot = filteredRowData?.find(item => item && formatDate(item.date) == date.formattedDate);
                const matchingDoubleShiftItem = filteredRowData?.find(item => item && item.todate === date.formattedDate);
                const matchingRemovedItem = filteredRowData?.find(item => item?._doc?.removedshiftdate === date.formattedDate);
                const matchingAssignShiftItem = filteredRowData?.find(item => item?._doc?.adjdate === date.formattedDate && item?._doc?.adjstatus === 'Approved' && item?._doc?.adjustmenttype === 'Assign Shift');

                const filterBoardingLog = item.boardingLog && item.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                    // return item;
                });
                let attendanceFiltered = attendance.filter(d => d.username === item.username)


                const depMonthSetFiltered = depMonthSet.filter(d => d.department === item.department)
                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item.weekoff?.includes(date.dayName);
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, item.departmentlog, depMonthSetFiltered) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                const row = {
                    id: `${item._id.toString()}_${date.formattedDate}_${date.shiftMode}`,
                    userid: item._id.toString(),
                    company: item.company,
                    branch: item.branch,
                    unit: item.unit,
                    team: item.team,
                    department: item.department,
                    username: item.companyname,
                    empcode: item.empcode,
                    weekoff: item.weekoff,
                    boardingLog: item.boardingLog,
                    shiftallot: item.shiftallot,
                    doj: dojDate,
                    shift: getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered, matchingRemovedItem, matchingAssignShiftItem),
                    date: `${date.formattedDate} ${date.dayName} ${date.dayCount}`,
                    role: item.role,
                    rowformattedDate: date.formattedDate,
                    dayName: date.dayName,
                    shiftMode: date.shiftMode,
                    reasondate: item.reasondate,
                    clockin: checkGetClockInTime(attendanceFiltered, item._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered, matchingRemovedItem, matchingAssignShiftItem),
                        date.shiftMode,
                    ),
                    clockout: checkGetClockOutTime(attendanceFiltered, item._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered, matchingRemovedItem, matchingAssignShiftItem),
                        date.shiftMode,
                    ),
                    clockinstatus: checkClockInStatus(
                        checkGetClockInTime(attendanceFiltered, item._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered, matchingRemovedItem, matchingAssignShiftItem),
                        graceTime, allLeaveStatus, holidays,
                        checkGetClockInDate(attendanceFiltered, item._id.toString(), date.formattedDate, date.shiftMode,), item.branch, item.empcode, item.company, date.formattedDate, item.unit, item.team, item.companyname,
                        earlyclockin, lateclockin, afterlateclockin, leavetype, permission,
                        checkGetClockOutTime(attendanceFiltered, item._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        date.shiftMode, checkWeekOffPresentStatus(attendanceFiltered, item._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    clockoutstatus: checkClockOutStatus(
                        checkGetClockOutTime(attendanceFiltered, item._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        checkGetClockInTime(attendanceFiltered, item._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSetFiltered, matchingRemovedItem, matchingAssignShiftItem),
                        clockOutHours, checkGetClockInDate(attendanceFiltered, item._id.toString(), date.formattedDate, date.shiftMode,),
                        allLeaveStatus, holidays, item.branch, item.empcode, item.company, date.formattedDate, item.unit, item.team, item.companyname, onclockout,
                        earlyclockout, beforeearlyclockout,
                        checkGetClockInAutoStatus(attendanceFiltered, item._id.toString(), date.formattedDate, date.shiftMode,),
                        leavetype, permission, date.shiftMode, checkWeekOffPresentStatus(attendanceFiltered, item._id.toString(), date.formattedDate, date.shiftMode,)
                    ),
                    attendanceautostatus: checkAttendanceStatus(attendanceFiltered, item._id.toString(), date.formattedDate, date.shiftMode,),
                    lateclockincount: lateclockincount,
                    earlyclockoutcount: earlyclockoutcount,
                    totalnumberofdays: getTotalMonthDaysUser(item.department, depMonthSetFiltered, ismonth, isyear),
                    empshiftdays: getTotalMonthDaysForEmpUser(dojDate, item.department, depMonthSetFiltered, ismonth, isyear),
                    totalcounttillcurrendate: getTotalMonthsCurrentDateCountUser(dojDate, item.department, depMonthSetFiltered, ismonth, isyear),
                    totalshift: getTotalShiftHoursUser(item._id.toString(), createdUserDates, attendanceFiltered),
                    weekoffpresentstatus: checkWeekOffPresentStatus(attendanceFiltered, item._id.toString(), date.formattedDate, date.shiftMode,),
                };
                return row;
            });

            return userRows;

        });
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finaluser) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ finaluser });
});


exports.getAllUsersexceldataAssignbranchHome = catchAsyncErrors(async (req, res, next) => {


    const query = {
        workmode: { $ne: "Internship" },
        enquirystatus: { $nin: ["Enquiry Purpose"] },
        resonablestatus: {
            $nin: ["Not Joined", "Postponed", "Rejected", "Closed", "Releave Employee", "Absconded", "Hold", "Terminate"],
        },
        // companyname: "VINITHA.NATESAN",
    }
    const currentDate = new Date();
    const currentMonth = currentDate.toLocaleString('default', { month: 'long' });
    // Months are zero-based, so add 1
    const currentYear = currentDate.getFullYear();

    const month = currentMonth;
    const year = currentYear;

    let users, usersAll, depMonthSet;
    try {
        depMonthSet = await DepartmentMonth.find({ monthname: month, year: year }, { department: 1, fromdate: 1, todate: 1 });

        usersAll = await User.find(query,
            {

            }
        ).limit(6);
        const fromDateSet = [...new Set(depMonthSet.map(d => d.fromdate))];
        users = usersAll.map(item => {
            let findUserDeprtment = item.department;

            if (item.departmentlog && item.departmentlog.length > 1) {
                // const findDept = item.departmentlog.find(dept => fromDateSet.includes(dept.startdate) );
                const sortedDepartmentLog = item.departmentlog.sort((a, b) => new Date(b.startdate) - new Date(a.startdate));

                const findDept = sortedDepartmentLog.find(dept =>
                    fromDateSet.includes(dept.startdate) ||
                    fromDateSet.some(fromDate => new Date(fromDate) > new Date(dept.startdate))
                );
                findUserDeprtment = findDept ? findDept.department : "";
            } else if (item.departmentlog && item.departmentlog.length > 0) {
                findUserDeprtment = new Date(item.doj) >= new Date(item.departmentlog[0].startdate) ? item.departmentlog[0].department : ""
            }
            let findfromtodate = depMonthSet.find(d => d.department === findUserDeprtment)
            let fromdate = findfromtodate ? findfromtodate.fromdate : ""
            let todate = findfromtodate ? findfromtodate.todate : ""
            if (item.reasondate == "" || (item.resonablestatus !== "" && new Date(item.reasondate) >= new Date(fromdate))) {
                return {
                    ...item._doc, // Use _doc to avoid including Mongoose metadata
                    department: findUserDeprtment,
                };
            }

            // return null; // Exclude users who don't match the department
        }).filter(item => item !== null);



    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    // if (!users || users.length === 0) {
    //     return next(new ErrorHandler("Users not found", 400));
    // }
    return res.status(200).json({ users });
});

exports.deleteUserActivityLog = catchAsyncErrors(async (req, res, next) => {
    try {
        // Get the timestamp 24 hours ago from the current time
        const twentyFourHoursAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
        // Find and delete records older than 24 hours
        const deleteResult = await userActivity.deleteMany({ createdAt: { $lt: twentyFourHoursAgo } });

        if (deleteResult.deletedCount > 0) {

            return `${deleteResult.deletedCount} old records  deleted successfully.`;
        } else {
            return `No old records found.`;
        }
    } catch (error) {
        return `Error deleting old files and records:, ${error}`;
    }
});

exports.updateBulkUsersShiftAllotObjects = catchAsyncErrors(async (req, res, next) => {
    try {
        const { shifttype, reason, applydate, applytime, userdataarray, datetochange } = req.body;


        const updateOperations = userdataarray.map(user => ({
            updateOne: {
                filter: { _id: user._id },
                update: {
                    $push: {
                        shiftallot: {
                            userid: user._id,
                            company: user.company,
                            branch: user.branch,
                            unit: user.unit,
                            team: user.team,
                            department: user.department,
                            username: user.companyname,
                            empcode: user.empcode,
                            weekoff: user.weekoff,
                            adjfirstshiftmode: "First Shift",
                            adjustmenttype: shifttype,
                            adjshiftgrptype: "Choose Day/Night",
                            adjchangeshift: "Choose Shift",
                            adjchangeshiftime: "Week Off",
                            adjchangereason: reason,
                            adjdate: datetochange,
                            adjapplydate: applydate,
                            adjapplytime: applytime,
                            adjstatus: "Approved",
                            adjustmentstatus: true,
                        },
                    },
                },
            },
        }));

        await User.bulkWrite(updateOperations);

        return res.status(200).json({ message: "User Shift updated successfully" });
    } catch (err) {
        return next(new ErrorHandler("Error updating shift!", 500));
    }
});

exports.createRocketChatAccountInEdit = catchAsyncErrors(async (req, res, next) => {
    const {
        companyname,
        rocketchatemail,
        password,
        username,
        callingname,
        rocketchatroles,
        createrocketchat,
        employeeid
    } = req.body;
    const newUserData = {
        name: companyname,
        email: rocketchatemail,
        password: password,
        username: username,
        active: true,
        nickname: callingname,
        // bio: "All about the user",
        joinDefaultChannels: true,
        // statusText: "On a vacation",
        roles: rocketchatroles,
        // requirePasswordChange: true,
        // setRandomPassword: true,
        sendWelcomeEmail: true,
        verified: false,
        // customFields: {
        //     clearance: "High",
        //     team: "Queen"
        // }
    };
    let rocketChatData;

    let isRocketchatLive = await checkRocketChatHealth();

    if (isRocketchatLive && createrocketchat) {



        const { rocketchatteamids, rocketchatchannelids } = await findRocketChatTeamChannelIds(req.body)
        rocketChatData = await createUserAndAddToTeamsAndGroups(newUserData, rocketchatteamids, rocketchatchannelids)
        const upuserone = await User.findByIdAndUpdate(employeeid, {
            rocketchatid: createrocketchat ? rocketChatData?.user?._id : "",
            rocketchatemail: createrocketchat ? rocketchatemail : "",
            rocketchatroles: createrocketchat ? rocketChatData?.user?.roles : [],
            rocketchatteamid: createrocketchat ? rocketChatData?.teamIds : [],
            rocketchatchannelid: createrocketchat ? rocketChatData?.groupIds : [],
        });
    }

    return res.status(201).json({
        success: true,
    });
});



// shift adjustment filter page
exports.getAllEmployeesForAttendanceFilterForShiftAdjFilterPage = catchAsyncErrors(async (req, res, next) => {
    let users;
    const { company, branch, unit } = req.body;
    try {

        let query = {
            company: { $in: company },
            branch: { $in: branch },
            unit: { $in: unit },
            enquirystatus: {
                $nin: ["Enquiry Purpose"],
            },
        };

        users = await User.find(query, {
            company: 1,
            branch: 1,
            unit: 1,
            team: 1,
            department: 1,
            doj: 1,
            empcode: 1,
            companyname: 1,
            team: 1,
            floor: 1,
            username: 1,
            designation: 1,
            weekoff: 1,
            shiftallot: 1,
            shifttiming: 1,
            boardingLog: 1,
            attendancemode: 1,
            reasondate: 1,
            departmentlog: 1,
        }
        );

    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ users });
});

const getPreviousDate = (formattedDate) => {

    // Split the date string (assuming DD/MM/YYYY format)
    const [day, month, year] = formattedDate.split('/').map(Number);

    // Create a date object with the parsed values
    const currentDate = new Date(year, month - 1, day); // Month is zero-indexed

    // Calculate the previous day's date
    currentDate.setDate(currentDate.getDate() - 1);

    // Format previous date back to DD/MM/YYYY
    const previousDateFormatted = `${String(currentDate.getDate()).padStart(2, '0')}/${String(currentDate.getMonth() + 1).padStart(2, '0')}/${currentDate.getFullYear()}`;

    return previousDateFormatted;
};

exports.updateBulkUsersShiftAllotObjectsForWeekoffAdjustmentOpt = catchAsyncErrors(async (req, res, next) => {
    try {
        const { shifttype, reason, applydate, applytime, userdataarray, datetochange, weekdate } = req.body;


        const updateOperations = userdataarray.map(user => {
            // Initialize variables for shift details
            let previousDateObject = null;
            let finalPreviousShift = null;
            let getChangeShiftTypeTime = "";

            // Calculate the previous date and shift time if shiftlabel is 'Week Off'
            if (user.shiftlabel === 'Week Off') {
                const previousDate = getPreviousDate(user.formattedDate);
                previousDateObject = user.overalldays.find(d => d.date === previousDate && user.empcode === d.empCode);

                finalPreviousShift = (previousDateObject && previousDateObject.adjstatus === "Approved" && user.empcode === previousDateObject.empCode)
                    ? previousDateObject.shiftlabel.props.children[0].split(': ')[1]
                    : previousDateObject.shiftlabel;

                getChangeShiftTypeTime = `${finalPreviousShift?.split('to')[0]} - ${finalPreviousShift?.split('to')[1]}`;
            }

            // Check if there is an existing shift allocation for the same date with status "Approved"
            const hasMatchingShift = user.shiftallot.some(allot =>
                allot.adjdate === weekdate && allot.adjstatus === "Approved"
            );

            // If a matching shift is found, do not push new data
            if (hasMatchingShift) return null;

            // Return the update operation for each user
            return {
                updateOne: {
                    filter: { _id: user._id },
                    update: {
                        $push: {
                            shiftallot: {
                                userid: user._id,
                                company: user.company,
                                branch: user.branch,
                                unit: user.unit,
                                team: user.team,
                                department: user.department,
                                username: user.companyname,
                                empcode: user.empcode,
                                weekoff: user.weekoff,
                                adjfirstshiftmode: "First Shift",
                                adjustmenttype: shifttype,
                                adjshiftgrptype: "Choose Day/Night",
                                adjchangeshift: "Choose Shift",
                                adjchangeshiftime: getChangeShiftTypeTime,
                                adjchangereason: reason,
                                adjdate: datetochange,
                                adjapplydate: applydate,
                                adjapplytime: applytime,
                                adjstatus: "Approved",
                                adjustmentstatus: true,
                                todate: weekdate,
                                todateshiftmode: "Week Off",
                                selectedDate: weekdate,
                                selectedShifTime: getChangeShiftTypeTime
                            },
                        },
                    },
                },
            };
        }).filter(operation => operation !== null);

        await User.bulkWrite(updateOperations);

        return res.status(200).json({ message: "User Shift updated successfully" });
    } catch (err) {
        return next(new ErrorHandler("Error updating shift!", 500));
    }
});

exports.getTeamWiseEmployees = catchAsyncErrors(async (req, res, next) => {
    let users;

    try {
        let resultArray,
            user,
            result1,
            ans1D,
            i = 1,
            result2,
            result3,
            result4,
            result5,
            result6,
            dataCheck,
            userFilter,
            result,
            hierarchyFilter,
            answerDef,
            hierarchyFinal,
            hierarchy,
            hierarchyDefList,
            resultAccessFilter,
            branch,
            hierarchySecond,
            overallMyallList,
            hierarchyMap,
            resulted,
            resultedTeam,
            myallTotalNames;




        result = await User.find(
            {
                enquirystatus: {
                    $nin: ["Enquiry Purpose"],
                },
                resonablestatus: {
                    $nin: [
                        "Not Joined",
                        "Postponed",
                        "Rejected",
                        "Closed",
                        "Releave Employee",
                        "Absconded",
                        "Hold",
                        "Terminate",
                    ],
                },
            },
            {
                empcode: 1,
                companyname: 1,
                username: 1,
                branch: 1,
                unit: 1,
                designation: 1,
                team: 1,
                department: 1,
                company: 1,
                extratime: 1,
                extrastatus: 1,
                extradate: 1,
                loginUserStatus: 1,
            }
        );

        // Accordig to sector and list filter process
        hierarchyFilter = await Hirerarchi.find({ level: req.body.sector });
        userFilter = hierarchyFilter
            .filter((data) => data.supervisorchoose.includes(req.body.username))
            .map((data) => data.employeename);

        hierarchyDefList = await Hirerarchi.find();
        user = await User.find({ companyname: req.body.username });
        const userFilt = user.length > 0 && user[0].designation;
        const desiGroup = await Designation.find();
        let HierarchyFilt =
            req.body.sector === "all"
                ? hierarchyDefList
                    .filter((data) =>
                        data.supervisorchoose.includes(req.body.username)
                    )
                    .map((data) => data.designationgroup)
                : hierarchyFilter
                    .filter((data) =>
                        data.supervisorchoose.includes(req.body.username)
                    )
                    .map((data) => data.designationgroup);
        const DesifFilter = desiGroup.filter((data) =>
            HierarchyFilt.includes(data.group)
        );
        const desigName = DesifFilter.length > 0 && DesifFilter[0].name;
        const SameDesigUser = HierarchyFilt.includes("All")
            ? true
            : userFilt === desigName;
        //Default Loading of List
        answerDef = hierarchyDefList
            .filter((data) => data.supervisorchoose.includes(req.body.username))
            .map((data) => data.employeename);

        hierarchyFinal =
            req.body.sector === "all"
                ? answerDef.length > 0
                    ? [].concat(...answerDef)
                    : []
                : hierarchyFilter.length > 0
                    ? [].concat(...userFilter)
                    : [];

        hierarchyMap = hierarchyFinal.length > 0 ? hierarchyFinal : [];

        //solo
        ans1D =
            req.body.sector === "all"
                ? answerDef.length > 0
                    ? hierarchyDefList.filter((data) =>
                        data.supervisorchoose.includes(req.body.username)
                    )
                    : []
                : hierarchyFilter.length > 0
                    ? hierarchyFilter.filter((data) =>
                        data.supervisorchoose.includes(req.body.username)
                    )
                    : [];
        result1 =
            ans1D.length > 0
                ? result
                    .map((item1) => {
                        const matchingItem2 = ans1D.find((item2) =>
                            item2.employeename.includes(item1.companyname)
                        );

                        if (matchingItem2) {
                            const plainItem1 = item1.toObject ? item1.toObject() : item1;
                            return {
                                ...plainItem1,
                                level: req.body.sector + "-" + matchingItem2.control,
                            };
                            //   return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                        }
                    })
                    .filter((item) => item !== undefined)
                : [];

        resulted = result1;

        //team
        let branches = [];
        hierarchySecond = await Hirerarchi.find();

        const subBranch =
            hierarchySecond.length > 0
                ? hierarchySecond
                    .filter((item) =>
                        item.supervisorchoose.some((name) =>
                            hierarchyMap.includes(name)
                        )
                    )
                    .map((item) => item.employeename)
                    .flat()
                : "";

        const answerFilterExcel =
            hierarchySecond.length > 0
                ? hierarchySecond.filter((item) =>
                    item.supervisorchoose.some((name) => hierarchyMap.includes(name))
                )
                : [];

        result2 =
            answerFilterExcel.length > 0
                ? result
                    .map((item1) => {
                        const matchingItem2 = answerFilterExcel.find((item2) =>
                            item2.employeename.includes(item1.companyname)
                        );
                        if (matchingItem2) {
                            // If a match is found, inject the control property into the corresponding item in an1
                            const plainItem1 = item1.toObject ? item1.toObject() : item1;
                            return {
                                ...plainItem1,
                                level: req.body.sector + "-" + matchingItem2.control,
                            };
                            // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                        }
                    })
                    .filter((item) => item !== undefined)
                : [];
        branches.push(...subBranch);

        const ans =
            subBranch.length > 0
                ? hierarchySecond
                    .filter((item) =>
                        item.supervisorchoose.some((name) => subBranch.includes(name))
                    )
                    .map((item) => item.employeename)
                    .flat()
                : "";
        const answerFilterExcel2 =
            subBranch.length > 0
                ? hierarchySecond.filter((item) =>
                    item.supervisorchoose.some((name) => subBranch.includes(name))
                )
                : [];

        result3 =
            answerFilterExcel2.length > 0
                ? result
                    .map((item1) => {
                        const matchingItem2 = answerFilterExcel2.find((item2) =>
                            item2.employeename.includes(item1.companyname)
                        );
                        if (matchingItem2) {
                            const plainItem1 = item1.toObject ? item1.toObject() : item1;
                            return {
                                ...plainItem1,
                                level: req.body.sector + "-" + matchingItem2.control,
                            };
                            // If a match is found, inject the control property into the corresponding item in an1
                            // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                        }
                    })
                    .filter((item) => item !== undefined)
                : [];
        branches.push(...ans);

        const loop3 =
            ans.length > 0
                ? hierarchySecond
                    .filter((item) =>
                        item.supervisorchoose.some((name) => ans.includes(name))
                    )
                    .map((item) => item.employeename)
                    .flat()
                : "";

        const answerFilterExcel3 =
            ans.length > 0
                ? hierarchySecond.filter((item) =>
                    item.supervisorchoose.some((name) => ans.includes(name))
                )
                : [];

        result4 =
            answerFilterExcel3.length > 0
                ? result
                    .map((item1) => {
                        const matchingItem2 = answerFilterExcel3?.find((item2) =>
                            item2.employeename.includes(item1.companyname)
                        );
                        if (matchingItem2) {
                            const plainItem1 = item1.toObject ? item1.toObject() : item1;
                            return {
                                ...plainItem1,
                                level: req.body.sector + "-" + matchingItem2.control,
                            };
                            // If a match is found, inject the control property into the corresponding item in an1
                            // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                        }
                    })
                    .filter((item) => item !== undefined)
                : [];
        branches.push(...loop3);

        const loop4 =
            loop3.length > 0
                ? hierarchySecond
                    .filter((item) =>
                        item.supervisorchoose.some((name) => loop3.includes(name))
                    )
                    .map((item) => item.employeename)
                    .flat()
                : [];
        const answerFilterExcel4 =
            loop3.length > 0
                ? hierarchySecond.filter((item) =>
                    item.supervisorchoose.some((name) => loop3.includes(name))
                )
                : [];
        result5 =
            answerFilterExcel4.length > 0
                ? result
                    .map((item1) => {
                        const matchingItem2 = answerFilterExcel4?.find((item2) =>
                            item2.employeename.includes(item1.companyname)
                        );
                        if (matchingItem2) {
                            const plainItem1 = item1.toObject ? item1.toObject() : item1;
                            return {
                                ...plainItem1,
                                level: req.body.sector + "-" + matchingItem2.control,
                            };
                            // If a match is found, inject the control property into the corresponding item in an1
                            // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                        }
                    })
                    .filter((item) => item !== undefined)
                : [];
        branches.push(...loop4);

        const loop5 =
            loop4.length > 0
                ? hierarchySecond
                    .filter((item) =>
                        item.supervisorchoose.some((name) => loop4.includes(name))
                    )
                    .map((item) => item.employeename)
                    .flat()
                : "";
        const answerFilterExcel5 =
            loop4.length > 0
                ? hierarchySecond.filter((item) =>
                    item.supervisorchoose.some((name) => loop4.includes(name))
                )
                : [];
        result6 =
            answerFilterExcel5.length > 0
                ? result
                    .map((item1) => {
                        const matchingItem2 = answerFilterExcel5?.find((item2) =>
                            item2.employeename.includes(item1.companyname)
                        );
                        if (matchingItem2) {
                            const plainItem1 = item1.toObject ? item1.toObject() : item1;
                            return {
                                ...plainItem1,
                                level: req.body.sector + "-" + matchingItem2.control,
                            };
                            // If a match is found, inject the control property into the corresponding item in an1
                            // return { ...item1, level: req.body.sector + "-" + matchingItem2.control };
                        }
                    })
                    .filter((item) => item !== undefined)
                : [];
        branches.push(...loop5);

        resultedTeam = [
            ...result2,
            ...result3,
            ...result4,
            ...result5,
            ...result6,
        ];
        //overall Teams List
        myallTotalNames = [...hierarchyMap, ...branches];
        users = [...resulted, ...resultedTeam];






    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }
    return res.status(200).json({ users });
});

exports.createRocketChatNewuser = catchAsyncErrors(async (req, res, next) => {
    try {



        const { name,
            username,
            password,
            email,
            roles } = req.body;
        const { authToken, userId, rocketchatdomainurl } = await rocketChatLogin();
        const userResponse = await axios.post(
            `${rocketchatdomainurl}/api/v1/users.create`,
            {
                name: name,
                email: email,
                password: password,
                username: username,
                active: true,
                nickname: "",
                // bio: userData.bio,
                joinDefaultChannels: true,
                // statusText: userData.statusText,
                roles: roles || ["user"],
                requirePasswordChange: false,
                setRandomPassword: false,
                sendWelcomeEmail: false,
                verified: false,
                customFields: {}
            },
            {
                headers: {
                    "X-Auth-Token": authToken,
                    "X-User-Id": userId,
                    "Content-Type": "application/json",
                },
            }
        );

        const newUser = userResponse.data.user;
        const resonablestatusarray = [
            "Absconded",
            "Hold",
            "Terminate",
            "Releave Employee",
            "Not Joined",
            "Postponed",
            "Rejected",
            "Closed",
        ];

        let singleUserData = await User.findOne({
            username: newUser?.username,
            resonablestatus: { $nin: resonablestatusarray }
        });

        if (singleUserData && newUser) {

            let shiftgrouping = [];
            let shift = [];

            // Check if the user's boardingLog exists and has entries
            if (singleUserData.boardingLog && singleUserData.boardingLog.length > 0) {
                const lastBoardingLog = singleUserData.boardingLog[singleUserData.boardingLog.length - 1];

                // If shifttype is "Standard", push shiftgrouping and shifttiming values
                if (lastBoardingLog.shifttype === "Standard") {
                    if (lastBoardingLog.shiftgrouping) {
                        shiftgrouping.push(lastBoardingLog.shiftgrouping);
                    }
                    if (lastBoardingLog.shifttiming) {
                        shift.push(lastBoardingLog.shifttiming);
                    }
                } else if (lastBoardingLog.shifttype !== "Standard") {
                    // If shifttype is not "Standard", check the todo array
                    const todo = lastBoardingLog.todo;

                    if (todo && todo.length > 0) {
                        // Iterate over the todo array and push shiftgrouping and shifttiming
                        todo.forEach(item => {
                            if (item.shiftgrouping) {
                                shiftgrouping.push(item.shiftgrouping);
                            }
                            if (item.shifttiming) {
                                shift.push(item.shifttiming);
                            }
                        });
                    }
                }
            }
            let findgrouping = {
                company: singleUserData?.company, branch: singleUserData?.branch, unit: singleUserData?.unit, team: singleUserData?.team, department: singleUserData?.department, designation: singleUserData?.designation, companyname: singleUserData?.companyname, process: singleUserData?.process,
                workmode: singleUserData?.workmode,
                rocketchatshiftgrouping: shiftgrouping,
                rocketchatshift: shift,
            }
            const { rocketchatteamids, rocketchatchannelids } = await findRocketChatTeamChannelIds(findgrouping);
            const teamUpdateResult = await updateUserRocketchatTeams(newUser?._id, newUser?.roles, [], rocketchatteamids);
            let updatedTeamsArray = teamUpdateResult?.updatedTeamsArray
            const channelUpdateResult = await updateUserRocketchatChannels(newUser?._id, [], rocketchatchannelids);
            let updatedChannelArray = channelUpdateResult?.updatedChannelArray;

            await User.findByIdAndUpdate(
                singleUserData?._id,
                {
                    $set: {
                        rocketchatid: newUser?._id,
                        rocketchatemail: email,
                        rocketchatroles: newUser?.roles,
                        rocketchatteamid: updatedTeamsArray || [],
                        rocketchatchannelid: updatedChannelArray || [],
                    },
                },
                { new: true } // Returns the updated document
            );
        }
        return res.status(200).json({
            success: true,
            message: "New User Created successfully",
        });
    } catch (err) {
        const errorMessage = err.response?.data?.error || err.message || "Error Creating Rocketchat User";

        return res.status(400).json({
            success: false,
            message: errorMessage,
            error: err.response?.data || null, // Include detailed error response for debugging
        });
    }
});

exports.getLimitedUserReportProductionMulti = async (req, res) => {
    try {
        const { company, branch, unit, team, reasondate } = req.body;

        let query = {};

        if (company.length > 0) {
            query.company = company;
        }
        if (branch.length > 0) {
            query.branch = branch;
        }
        if (unit.length > 0) {
            query.unit = unit;
        }
        if (team.length > 0) {
            query.team = team;
        }

        query.enquirystatus = {
            $nin: ['Enquiry Purpose'],
        }
        query.$or = [{ reasondate: { $exists: false } }, { reasondate: { $eq: '' } }, { reasondate: { $gte: reasondate } }];

        const users = await User.find(query, { companyname: 1, username: 1 });

        return res.status(200).json({
            users,
        });
    } catch (err) {
        return next(new ErrorHandler('Records not found!', 404));
    }
};
exports.getAllEmployeesForAttendanceFilterProdDayPoint = catchAsyncErrors(async (req, res, next) => {
    let users;
    const { employee, date } = req.body;
    try {
        let dateoneafter = new Date(date);
        dateoneafter.setDate(dateoneafter.getDate() + 1);
        let newDateOnePlus = dateoneafter.toISOString().split('T')[0];

        let datebefore = new Date(date);
        datebefore.setDate(datebefore.getDate() - 1);
        let newDateOneMinus = datebefore.toISOString().split('T')[0];

        let datebeforeoneBefore = new Date(date);
        datebeforeoneBefore.setDate(datebeforeoneBefore.getDate() - 1);
        let newDateOneMinusOneBefore = datebeforeoneBefore.toISOString().split('T')[0];

        let dateoneaftertwoplus = new Date(date);
        dateoneaftertwoplus.setDate(dateoneaftertwoplus.getDate() + 2);
        let newDateTwoPlus = dateoneaftertwoplus.toISOString().split('T')[0];


        let userQuery = {
            enquirystatus: {
                $nin: ['Enquiry Purpose'],
            },

            $or: [{ reasondate: { $exists: false } }, { reasondate: { $eq: '' } }, { reasondate: { $gte: date } }],
        };


        users = await User.find(userQuery, {
            companyname: 1,
        });

    } catch (err) {
        return next(new ErrorHandler('Records not found!', 404));
    }
    if (!users) {
        return next(new ErrorHandler('Users not found', 400));
    }
    return res.status(200).json({ users });
});

exports.getAllUserClockinAndClockoutStatusFilterProdDayPoint = catchAsyncErrors(async (req, res, next) => {
    let users, finaluser;
    const { employee, date } = req.body;
    try {
        let dateoneafter = new Date(date);
        dateoneafter.setDate(dateoneafter.getDate() + 1);
        let newDateOnePlus = dateoneafter.toISOString().split('T')[0];

        let datebefore = new Date(date);
        datebefore.setDate(datebefore.getDate() - 1);
        let newDateOneMinus = datebefore.toISOString().split('T')[0];

        let datebeforeoneBefore = new Date(date);
        datebeforeoneBefore.setDate(datebeforeoneBefore.getDate() - 1);
        let newDateOneMinusOneBefore = datebeforeoneBefore.toISOString().split('T')[0];

        let dateoneaftertwoplus = new Date(date);
        dateoneaftertwoplus.setDate(dateoneaftertwoplus.getDate() + 2);
        let newDateTwoPlus = dateoneaftertwoplus.toISOString().split('T')[0];

        let dateNow = new Date(date);
        let datevalue = dateNow.toISOString().split('T')[0];

        let deptMonthQuery = {
            fromdate: { $lte: datevalue },
            todate: { $gte: datevalue },
        };
        let userQuery = {
            enquirystatus: {
                $nin: ['Enquiry Purpose'],
            },

            companyname: { $in: employee },
            // companyname:{$in:["MUTHU.MANIKANDAN", "AMSADHGAN.S"]},
            $or: [{ reasondate: { $exists: false } }, { reasondate: { $eq: '' } }, { reasondate: { $gte: date } }],
        };
        let logidQuery = {
            loginallotlog: { $exists: true, $ne: [] },
            //  allotted: 'allotted',
        };
        let startMonthDateMinus = new Date(date);
        let startdate = startMonthDateMinus.setDate(startMonthDateMinus.getDate() - 1);
        let startMonthDate = new Date(startdate);

        let firstDate = new Date(date);
        let enddate = firstDate.setDate(firstDate.getDate() + 2);
        let endMonthDate = new Date(enddate);

        const daysArray = [];
        while (startMonthDate <= endMonthDate) {
            const formattedDate = `${String(startMonthDate.getDate()).padStart(2, '0')}/${String(startMonthDate.getMonth() + 1).padStart(2, '0')}/${startMonthDate.getFullYear()}`;
            const dayName = startMonthDate.toLocaleDateString('en-US', {
                weekday: 'long',
            });
            const dayCount = startMonthDate.getDate();
            const shiftMode = 'Main Shift';
            const weekNumberInMonth =
                getWeekNumberInMonth(startMonthDate) === 1
                    ? `${getWeekNumberInMonth(startMonthDate)}st Week`
                    : getWeekNumberInMonth(startMonthDate) === 2
                        ? `${getWeekNumberInMonth(startMonthDate)}nd Week`
                        : getWeekNumberInMonth(startMonthDate) === 3
                            ? `${getWeekNumberInMonth(startMonthDate)}rd Week`
                            : getWeekNumberInMonth(startMonthDate) > 3
                                ? `${getWeekNumberInMonth(startMonthDate)}th Week`
                                : '';

            daysArray.push({
                formattedDate,
                dayName,
                dayCount,
                shiftMode,
                weekNumberInMonth,
            });

            // Move to the next day
            startMonthDate.setDate(startMonthDate.getDate() + 1);
        }
        const userDates = daysArray;
        const formattedUserDates = userDates.map((data) => moment(data.formattedDate, 'DD/MM/YYYY').format('DD-MM-YYYY'));

        let dateSelectedFormat = moment(date).format('DD/MM/YYYY');
        let dateSelectedFormatOnePlus = moment(newDateOnePlus).format('DD/MM/YYYY');
        let dateSelectedFormatOneMinus = moment(newDateOneMinus).format('DD/MM/YYYY');
        let dateSelectedFormatTwoPlus = moment(newDateTwoPlus).format('DD/MM/YYYY');

        let shiftEndTime = `${date}T00:00:00.000Z`;
        let shiftFromTime = `${date}T00:00:00.000Z`;
        let shiftOnlyFromTime = `${date}T00:00:00.000Z`;
        let shiftOnlyEndTime = `${date}T00:00:00.000Z`;

        const [attendenceControlCriteria, depMonthSets, usersAll, loginids, shift, attendances, holidays, leavetype] = await Promise.all([
            ControlCriteria.findOne().sort({ createdAt: -1 }).exec(),
            DepartmentMonth.find(deptMonthQuery, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 }),
            User.find(userQuery, {
                companyname: 1,
                empcode: 1,
                company: 1,
                departmentlog: 1,
                unit: 1,
                branch: 1,
                team: 1,
                username: 1,
                processlog: 1,
                shifttiming: 1,
                department: 1,
                doj: 1,
                reasondate: 1,
                assignExpLog: 1,
                shiftallot: 1,
                boardingLog: 1,
                intStartDate: 1,
            }),
            ClientUserid.find(logidQuery, { empname: 1, userid: 1, projectvendor: 1, loginallotlog: 1 }).lean(),
            Shift.find({}, { name: 1, fromhour: 1, tohour: 1, frommin: 1, tomin: 1, fromtime: 1, totime: 1 }),
            Attendance.find({
                date: { $in: formattedUserDates },
            }),
            Holiday.find({}, { date: 1, company: 1, applicablefor: 1, unit: 1, team: 1, employee: 1, noofdays: 1 }),
            Leavetype.find({}, { leavetype: 1, code: 1 }),
        ]);
        let dayShiftBeforeHrs = attendenceControlCriteria && attendenceControlCriteria.dayactive && attendenceControlCriteria.dayactive == true ? Number(attendenceControlCriteria.calcshifthourday) : 4;
        let dayShiftBeforeMin = attendenceControlCriteria && attendenceControlCriteria.dayactive && attendenceControlCriteria.dayactive == true ? Number(attendenceControlCriteria.calcshiftminday) : 0;
        let nightShiftBeforeHrs = attendenceControlCriteria && attendenceControlCriteria.nightactive && attendenceControlCriteria.nightactive == true ? Number(attendenceControlCriteria.calcshifthournight) : 4;
        let nightShiftBeforeMin = attendenceControlCriteria && attendenceControlCriteria.nightactive && attendenceControlCriteria.nightactive == true ? Number(attendenceControlCriteria.calcshiftminnight) : 0;

        clockOutHours = attendenceControlCriteria.clockout;
        lateclockincount = attendenceControlCriteria.lateclockincount;
        earlyclockoutcount = attendenceControlCriteria.earlyclockoutcount;
        onclockout = attendenceControlCriteria.onclockout;
        earlyclockin = attendenceControlCriteria.earlyclockin;
        lateclockin = attendenceControlCriteria.lateclockin;
        earlyclockout = attendenceControlCriteria.earlyclockout;
        afterlateclockin = attendenceControlCriteria.afterlateclockin;
        beforeearlyclockout = attendenceControlCriteria.afterlateclockin;

        let users1 = usersAll.map((item) => {
            let findUserDepartment = item.department;
            let findUserTeam = item.team;
            let findUserProcess = item.process;
            let findexpval = item.experience;
            let userids = [];

            // const loginallot = loginids.filter((login) => login.loginallotlog.some((d) => d.empname === item.companyname));

            const dojDate = item.boardingLog.length > 0 ? item.boardingLog[0].startdate : item.doj;

            // Handling team change with boardingLog
            if (item.boardingLog && item.boardingLog.length > 0) {
                // Check if there's any team change
                const teamChangeLog = item.boardingLog.filter((log) => log.logcreation !== 'shift' && log.ischangeteam === true);

                if (teamChangeLog.length > 0) {
                    // Sort by startdate descending
                    const sortedTeamLog = teamChangeLog.sort((a, b) => {
                        // First, compare startdate
                        const startDateComparison = new Date(b.startdate) - new Date(a.startdate);
                        if (startDateComparison !== 0) {
                            return startDateComparison;
                        }

                        // If startdate is the same, compare createdat
                        return b.updateddatetime - a.updateddatetime;
                    });

                    // Find the relevant team change based on the 'date'
                    const findTeam = sortedTeamLog.find((log) => new Date(date) >= new Date(log.startdate));
                    findUserTeam = findTeam ? findTeam.team : item.team;
                }
            }

            // Handling department change with departmentlog
            if (item.departmentlog && item.departmentlog.length > 0) {
                if (item.departmentlog.length > 1) {
                    // Sort department logs by startdate descending
                    const sortedDepartmentLog = item.departmentlog.sort((a, b) => {
                        // First, compare startdate
                        const startDateComparison = new Date(b.startdate) - new Date(a.startdate);
                        if (startDateComparison !== 0) {
                            return startDateComparison;
                        }

                        // If startdate is the same, compare createdat
                        return b.updateddatetime - a.updateddatetime;
                    });

                    // Find the relevant department change based on the 'date'
                    const findDept =
                        sortedDepartmentLog.length > 1 && sortedDepartmentLog.map((item) => item.department).includes('Internship')
                            ? sortedDepartmentLog.filter((item) => item.department != 'Internship').find((dept) => new Date(date) >= new Date(dept.startdate))
                            : sortedDepartmentLog.find((dept) => new Date(date) >= new Date(dept.startdate));
                    findUserDepartment = findDept ? findDept.department : item.department;
                } else if (item.departmentlog.length === 1) {
                    findUserDepartment = new Date(date) >= new Date(item.departmentlog[0].startdate) ? item.departmentlog[0].department : item.department;
                } else {
                    findUserDepartment = item.department;
                }
            }

            if (item && item.processlog) {
                const groupedByMonthProcs = {};

                // Group items by month
                item.processlog &&
                    item.processlog
                        ?.sort((a, b) => {
                            return new Date(a.date) - new Date(b.date);
                        })
                        ?.forEach((d) => {
                            const monthYear = d.date?.split('-').slice(0, 2).join('-');
                            if (!groupedByMonthProcs[monthYear]) {
                                groupedByMonthProcs[monthYear] = [];
                            }
                            groupedByMonthProcs[monthYear].push(d);
                        });

                // Extract the last item of each group
                const lastItemsForEachMonthPros = Object.values(groupedByMonthProcs).map((group) => group[group.length - 1]);

                // Filter the data array based on the month and year
                lastItemsForEachMonthPros.sort((a, b) => {
                    return new Date(a.date) - new Date(b.date);
                });
                // Find the first item in the sorted array that meets the criteria

                for (let i = 0; i < lastItemsForEachMonthPros.length; i++) {
                    const date = lastItemsForEachMonthPros[i].date;

                    if (new Date(req.body.date) >= new Date(date)) {
                        findUserProcess = lastItemsForEachMonthPros[i];
                    } else {
                        break;
                    }
                }
            }
            const groupedByMonth = {};
            if (item.assignExpLog && item.assignExpLog.length > 0) {
                const findMonthStartDate = depMonthSets.find((data) => new Date(date) >= new Date(data.fromdate) && new Date(date) <= new Date(data.todate) && data.department == findUserDepartment);
                let findDate = findMonthStartDate ? findMonthStartDate.fromdate : date;
                item.assignExpLog &&
                    item.assignExpLog.length > 0 &&
                    item.assignExpLog
                        .filter((d) => d.expmode != 'Auto' && d.expmode != 'Manual')
                        .sort((a, b) => {
                            return new Date(a.updatedate) - new Date(b.updatedate);
                        })
                        .forEach((item) => {
                            const monthYear = item.updatedate?.split('-').slice(0, 2).join('-');
                            if (!groupedByMonth[monthYear]) {
                                groupedByMonth[monthYear] = [];
                            }
                            groupedByMonth[monthYear].push(item);
                        });

                // Extract the last item of each group
                const lastItemsForEachMonth = Object.values(groupedByMonth).map((group) => group[group.length - 1]);

                // Find the first item in the sorted array that meets the criteria

                // Find the first item in the sorted array that meets the criteria
                let filteredItem = null;

                for (let i = 0; i < lastItemsForEachMonth.length; i++) {
                    const date1 = lastItemsForEachMonth[i].updatedate;

                    if (date >= date1) {
                        filteredItem = lastItemsForEachMonth[i];
                    } else {
                        break;
                    }
                }

                let modevalue = filteredItem;

                const calculateMonthsBetweenDates = (startDate, endDate) => {
                    if (startDate && endDate) {
                        const start = new Date(startDate);
                        const end = new Date(endDate);

                        let years = end.getFullYear() - start.getFullYear();
                        let months = end.getMonth() - start.getMonth();
                        let days = end.getDate() - start.getDate();

                        // Convert years to months
                        months += years * 12;

                        // Adjust for negative days
                        if (days < 0) {
                            months -= 1; // Subtract a month
                            days += new Date(end.getFullYear(), end.getMonth(), 0).getDate(); // Add days of the previous month
                        }

                        // Adjust for days 15 and above
                        if (days >= 15) {
                            months += 1; // Count the month if 15 or more days have passed
                        }

                        return months <= 0 ? 0 : months;
                    }

                    return 0; // Return 0 if either date is missing
                };

                // Calculate difference in months between findDate and item.doj
                let differenceInMonths, differenceInMonthsexp, differenceInMonthstar;
                if (modevalue) {
                    //findexp end difference yes/no
                    if (modevalue.endexp === 'Yes') {
                        differenceInMonthsexp = calculateMonthsBetweenDates(item.doj, modevalue.endexpdate);
                        //  Math.floor((new Date(modevalue.endexpdate) - new Date(item.doj)) / (30 * 24 * 60 * 60 * 1000));
                        if (modevalue.expmode === 'Add') {
                            differenceInMonthsexp += parseInt(modevalue.expval);
                        } else if (modevalue.expmode === 'Minus') {
                            differenceInMonthsexp -= parseInt(modevalue.expval);
                        } else if (modevalue.expmode === 'Fix') {
                            differenceInMonthsexp = parseInt(modevalue.expval);
                        }
                    } else {
                        differenceInMonthsexp = calculateMonthsBetweenDates(item.doj, findDate);
                        // Math.floor((new Date(findDate) - new Date(item.doj)) / (30 * 24 * 60 * 60 * 1000));
                        if (modevalue.expmode === 'Add') {
                            differenceInMonthsexp += parseInt(modevalue.expval);
                        } else if (modevalue.expmode === 'Minus') {
                            differenceInMonthsexp -= parseInt(modevalue.expval);
                        } else if (modevalue.expmode === 'Fix') {
                            differenceInMonthsexp = parseInt(modevalue.expval);
                        } else {
                            // differenceInMonths = parseInt(modevalue.expval);
                            differenceInMonthsexp = calculateMonthsBetweenDates(item.doj, findDate);
                        }
                    }

                    //findtar end difference yes/no
                    if (modevalue.endtar === 'Yes') {
                        differenceInMonthstar = calculateMonthsBetweenDates(item.doj, modevalue.endtardate);
                        //  Math.floor((new Date(modevalue.endtardate) - new Date(item.doj)) / (30 * 24 * 60 * 60 * 1000));
                        if (modevalue.expmode === 'Add') {
                            differenceInMonthstar += parseInt(modevalue.expval);
                        } else if (modevalue.expmode === 'Minus') {
                            differenceInMonthstar -= parseInt(modevalue.expval);
                        } else if (modevalue.expmode === 'Fix') {
                            differenceInMonthstar = parseInt(modevalue.expval);
                        }
                    } else {
                        differenceInMonthstar = calculateMonthsBetweenDates(item.doj, findDate);
                        if (modevalue.expmode === 'Add') {
                            differenceInMonthstar += parseInt(modevalue.expval);
                        } else if (modevalue.expmode === 'Minus') {
                            differenceInMonthstar -= parseInt(modevalue.expval);
                        } else if (modevalue.expmode === 'Fix') {
                            differenceInMonthstar = parseInt(modevalue.expval);
                        } else {
                            // differenceInMonths = parseInt(modevalue.expval);
                            differenceInMonthstar = calculateMonthsBetweenDates(item.doj, findDate);
                        }
                    }

                    differenceInMonths = calculateMonthsBetweenDates(item.doj, findDate);
                    if (modevalue.expmode === 'Add') {
                        differenceInMonths += parseInt(modevalue.expval);
                    } else if (modevalue.expmode === 'Minus') {
                        differenceInMonths -= parseInt(modevalue.expval);
                    } else if (modevalue.expmode === 'Fix') {
                        differenceInMonths = parseInt(modevalue.expval);
                    } else {
                        // differenceInMonths = parseInt(modevalue.expval);
                        differenceInMonths = calculateMonthsBetweenDates(item.doj, findDate);
                    }
                } else {
                    differenceInMonthsexp = calculateMonthsBetweenDates(item.doj, findDate);
                    differenceInMonthstar = calculateMonthsBetweenDates(item.doj, findDate);
                    differenceInMonths = calculateMonthsBetweenDates(item.doj, findDate);
                }
                findexpval = differenceInMonthstar < 1 ? '00' : differenceInMonthstar <= 9 ? '0' + differenceInMonthstar : differenceInMonthstar;
            }
            let findUserProcessFinal = findUserProcess ? findUserProcess.process : item.process;


            return {
                ...item._doc,
                department: findUserDepartment,
                team: findUserTeam,
                process: findUserProcessFinal,
                exp: findexpval,
                dojDate: dojDate,
                // userids: loginallot.map(item),
            };
        });
        const userCds = users1.map((user) => user.companyname);
        // const userIds = users1.map((user) => user._id);
        const [allLeaveStatus, permission] = await Promise.all([ApplyLeave.find({ employeename: { $in: userCds } }), Permission.find({ employeename: { $in: userCds } }, { employeeid: 1, date: 1, status: 1, applytype: 1, compensationstatus: 1, compensationapplytype: 1, requesthours: 1, shiftmode: 1, })]);
        const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
        let resultshiftallot = [];
        let userShifts = users1;

        let finalusers =
            userShifts &&
            userShifts.length > 0 &&
            userShifts?.flatMap((item, index) => {
                try {
                    let isEmployeeGrace = attendenceControlCriteria.todos && attendenceControlCriteria.todos.find((d) => d.company === item.company && d.branch === item.branch && d.unit === item.unit && d.team === item.team && d.employeename === item.companyname);

                    if (isEmployeeGrace) {
                        graceTime = isEmployeeGrace.employeegracetime;
                    } else {
                        graceTime = attendenceControlCriteria.gracetime;
                    }

                    item.shiftallot?.map((allot) => {
                        resultshiftallot.push({ ...allot });
                    });

                    const findShiftTimingsts = (shiftName) => {
                        const foundShift = shift?.find((d) => d.name === shiftName);
                        return foundShift ? `${foundShift.isallowance}` : '';
                    };

                    const filteredMatchingDoubleShiftItem = item.shiftallot?.filter((val) => val && val.empcode === item.empcode && val.adjstatus === 'Approved');

                    // Filter out the dates that have matching 'Shift Adjustment' todates
                    let removedUserDates = userDates.filter((date) => {
                        // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
                        const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem?.find((item) => item && item.todate === date.formattedDate && item.adjustmenttype === 'Shift Adjustment');

                        // If there is no matching 'Shift Adjustment', keep the date
                        return !matchingShiftAdjustmentToDate;
                    });

                    // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
                    let uniqueEntries = new Set();

                    // Iterate over removedUserDates and add unique entries to the Set
                    userDates.forEach((date) => {
                        uniqueEntries.add(
                            JSON.stringify({
                                formattedDate: date.formattedDate,
                                dayName: date.dayName,
                                dayCount: date.dayCount,
                                shiftMode: 'Main Shift',
                                weekNumberInMonth: date.weekNumberInMonth,
                            })
                        );
                    });

                    // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
                    filteredMatchingDoubleShiftItem &&
                        filteredMatchingDoubleShiftItem?.forEach((item) => {
                            const [day, month, year] = item.adjdate?.split('/');
                            let newFormattedDate = new Date(`${year}-${month}-${day}`);

                            if (item.adjustmenttype === 'Shift Adjustment' || item.adjustmenttype === 'Add On Shift' || item.adjustmenttype === 'Shift Weekoff Swap') {
                                uniqueEntries.add(
                                    JSON.stringify({
                                        formattedDate: item.adjdate,
                                        dayName: moment(item.adjdate, 'DD/MM/YYYY').format('dddd'),
                                        dayCount: parseInt(moment(item.adjdate, 'DD/MM/YYYY').format('DD')),
                                        shiftMode: 'Second Shift',
                                        weekNumberInMonth:
                                            getWeekNumberInMonth(newFormattedDate) === 1
                                                ? `${getWeekNumberInMonth(newFormattedDate)}st Week`
                                                : getWeekNumberInMonth(newFormattedDate) === 2
                                                    ? `${getWeekNumberInMonth(newFormattedDate)}nd Week`
                                                    : getWeekNumberInMonth(newFormattedDate) === 3
                                                        ? `${getWeekNumberInMonth(newFormattedDate)}rd Week`
                                                        : getWeekNumberInMonth(newFormattedDate) > 3
                                                            ? `${getWeekNumberInMonth(newFormattedDate)}th Week`
                                                            : '',
                                    })
                                );
                            }
                        });

                    // Convert Set back to an array of objects
                    let createdUserDatesUnique = Array.from(uniqueEntries).map((entry) => JSON.parse(entry));

                    function sortUserDates(dates) {
                        return dates.sort((a, b) => {
                            if (a.formattedDate === b.formattedDate) {
                                // If dates are the same, sort by shift mode
                                if (a.shiftMode < b.shiftMode) return -1;
                                if (a.shiftMode > b.shiftMode) return 1;
                                return 0;
                            } else {
                                // Otherwise, sort by date
                                const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                                const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                                return dateA - dateB;
                            }
                        });
                    }

                    // Sort the array
                    const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);
                    const createdUserDates = sortedCreatedUserDates?.filter((d) => {
                        const filterData = userDates.some((val) => val.formattedDate === d.formattedDate);
                        if (filterData) {
                            return d;
                        }
                    });

                    // Map each user date to a row
                    const userRows = createdUserDates?.map((date) => {
                        let filteredRowData = item.shiftallot?.filter((val) => val.empcode == item.empcode);
                        const matchingItem = filteredRowData?.find((item) => item && item.adjdate == date.formattedDate);
                        const matchingItemAllot = filteredRowData?.find((item) => item && formatDate(item.date) == date.formattedDate);
                        const matchingDoubleShiftItem = filteredRowData?.find((item) => item && item.todate === date.formattedDate);
                        const matchingRemovedItem = filteredRowData?.find((item) => item.removedshiftdate === date.formattedDate);
                        const matchingAssignShiftItem = filteredRowData?.find(item => item.adjdate === date.formattedDate && item.adjstatus === 'Approved' && item.adjustmenttype === 'Assign Shift');

                        const filterBoardingLog =
                            item.boardingLog &&
                            item.boardingLog?.filter((item) => {
                                return item.logcreation === 'user' || item.logcreation === 'shift';
                            });

                        // Check if the dayName is Sunday or Monday
                        // const isWeekOff = item.weekoff?.includes(date.dayName);

                        const depMonthSet = depMonthSets.filter((d) => d.department === item.department);
                        const attendance = attendances.filter((d) => d.username === item.username);

                        const isWeekOff = getWeekOffDay(date, filterBoardingLog, item.department, depMonthSet) === 'Week Off' ? true : false;
                        const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                        const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                        // const row = {
                        //   company: item.company,
                        //   branch: item.branch,
                        //   unit: item.unit,
                        //   team: item.team,
                        //   companyname: item.companyname,
                        //   empcode: item.empcode,
                        //   username: item.username,
                        //   shifttiming: getShiftForDateProdDay(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSet,matchingRemovedItem),
                        //   date: date.formattedDate,
                        //   shiftmode: date.shiftMode,

                        //   shiftsts: findShiftTimingsts(getShiftForDateProdDay(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSet)),
                        // };
                        const row = {
                            id: `${item._id.toString()}_${date.formattedDate}_${date.shiftMode}`,
                            userid: item._id.toString(),
                            company: item.company,
                            branch: item.branch,
                            unit: item.unit,
                            team: item.team,
                            process: item.process,
                            exp: item.exp,
                            dojDate: item.dojDate,
                            assignExpLog: item.assignExpLog,
                            processlog: item.processlog,
                            // shifttiming: getShiftForDateProdDay(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSet,matchingRemovedItem),
                            shiftsts: findShiftTimingsts(getShiftForDateProdDay(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem)),

                            department: item.department,
                            username: item.companyname,
                            companyname: item.companyname,
                            empcode: item.empcode,
                            weekoff: item.weekoff,
                            boardingLog: item.boardingLog,
                            shiftallot: item.shiftallot,
                            doj: item.doj,
                            shift: getShiftForDateProdDay(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                            shifttiming: getShiftForDateProdDay(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                            date: `${date.formattedDate} ${date.dayName} ${date.dayCount}`,
                            rowformattedDate: date.formattedDate,
                            dayName: date.dayName,
                            shiftMode: date.shiftMode,
                            reasondate: item.reasondate ? item.reasondate : "",
                            clockin: checkGetClockInTime(
                                attendance,
                                item._id.toString(),
                                date.formattedDate,
                                getShiftForDateProdDay(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode
                            ),
                            clockout: checkGetClockOutTime(
                                attendance,
                                item._id.toString(),
                                date.formattedDate,
                                getShiftForDateProdDay(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode
                            ),
                            clockinstatus: checkClockInStatus(
                                checkGetClockInTime(
                                    attendance,
                                    item._id.toString(),
                                    date.formattedDate,
                                    getShiftForDateProdDay(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode
                                ),
                                getShiftForDateProdDay(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem), graceTime,
                                allLeaveStatus,
                                holidays,
                                checkGetClockInDate(attendance, item._id.toString(), date.formattedDate, date.shiftMode),
                                item.branch,
                                item.empcode,
                                item.company,
                                date.formattedDate,
                                item.unit,
                                item.team,
                                item.companyname,
                                earlyclockin,
                                lateclockin,
                                afterlateclockin,
                                leavetype,
                                permission,
                                checkGetClockOutTime(
                                    attendance,
                                    item._id.toString(),
                                    date.formattedDate,
                                    getShiftForDateProdDay(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem), graceTime,
                                ),
                                date.shiftMode,
                                checkWeekOffPresentStatus(attendance, item._id.toString(), date.formattedDate, date.shiftMode)
                            ),
                            clockoutstatus: checkClockOutStatus(
                                checkGetClockOutTime(
                                    attendance,
                                    item._id.toString(),
                                    date.formattedDate,
                                    getShiftForDateProdDay(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode
                                ),
                                checkGetClockInTime(
                                    attendance,
                                    item._id.toString(),
                                    date.formattedDate,
                                    getShiftForDateProdDay(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode
                                ),
                                getShiftForDateProdDay(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, item.department, depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                                //  graceTime,
                                clockOutHours,
                                checkGetClockInDate(attendance, item._id.toString(), date.formattedDate, date.shiftMode),
                                allLeaveStatus,
                                holidays,
                                item.branch,
                                item.empcode,
                                item.company,
                                date.formattedDate,
                                item.unit,
                                item.team,
                                item.companyname,
                                onclockout,
                                earlyclockout,
                                beforeearlyclockout,
                                checkGetClockInAutoStatus(attendance, item._id.toString(), date.formattedDate, date.shiftMode),
                                leavetype,
                                permission,
                                date.shiftMode,
                                checkWeekOffPresentStatus(attendance, item._id.toString(), date.formattedDate, date.shiftMode)
                            ),
                            attendanceautostatus: checkAttendanceStatus(attendance, item._id.toString(), date.formattedDate, date.shiftMode),
                            lateclockincount: lateclockincount,
                            earlyclockoutcount: earlyclockoutcount,
                            weekoffpresentstatus: checkWeekOffPresentStatus(attendance, item._id.toString(), date.formattedDate, date.shiftMode),
                        };

                        return row;
                    });
                    return userRows;
                } catch (err) {
                }

            });

        finaluser = users1.flatMap((item) => {
            try {
                let finaluserFiltered = finalusers.filter((d) => d.shifttiming != undefined && d.companyname === item.companyname);

                function filterData(data) {
                    const previousEntry = data.find((d) => d.rowformattedDate === dateSelectedFormatOneMinus);
                    const firstEntry = data.find((d) => d.rowformattedDate === dateSelectedFormat);
                    const secondEntry = data.find((d) => d.rowformattedDate === dateSelectedFormatOnePlus);
                    const firstEntryDoubleShift = data.find((d) => d.rowformattedDate === dateSelectedFormat && d.shiftMode === 'Second Shift' && d.shifttiming != undefined);
                    const firstEntryDoubleShiftPM = data.find((d) => d.rowformattedDate === dateSelectedFormat && d.shiftMode === 'Second Shift' && d.shifttiming != undefined && d.shifttiming.split('to')[0].includes('PM'));
                    const thirdEntry = data.find((d) => d.rowformattedDate === dateSelectedFormatTwoPlus);
                    const isBeforeDayDoubleShift = data.find((d) => d.rowformattedDate === dateSelectedFormatOneMinus && d.shiftMode === 'Second Shift' && d.shifttiming != undefined);
                    const isBeforeDayDoubleShiftPM = isBeforeDayDoubleShift && isBeforeDayDoubleShift.shifttiming.split('to')[0].includes('PM');

                    // if (!firstEntry) return [];
                    const ispreviousShiftWeekoff = previousEntry && previousEntry.shifttiming !== '' && previousEntry.shifttiming == 'Week Off';
                    const isFirstShiftWeekoff = firstEntry && firstEntry.shifttiming !== '' && firstEntry.shifttiming == 'Week Off';
                    const isSecondShiftWeekoff = secondEntry && secondEntry.shifttiming !== '' && secondEntry.shifttiming == 'Week Off';
                    const isFirstShiftPM = firstEntry && firstEntry.shifttiming !== '' && firstEntry.shifttiming != 'Week Off' ? firstEntry.shifttiming.split('to')[0].includes('PM') : '';
                    const isSecondShiftPM = secondEntry && secondEntry.shifttiming !== '' && secondEntry.shifttiming != 'Week Off' ? secondEntry.shifttiming.split('to')[0].includes('PM') : '';
                    const isPreviousShiftPM = previousEntry && previousEntry.shifttiming !== '' && previousEntry.shifttiming != 'Week Off' ? previousEntry.shifttiming.split('to')[0].includes('PM') : '';

                    const isMainShift = firstEntry && firstEntry.shiftMode === 'Main Shift';
                    const isPlusShift = firstEntry && firstEntry.plusshift && firstEntry.plusshift != '';

                    function convertTo24Hour(time) {
                        // Remove any extra spaces or unexpected characters
                        time = time.trim();

                        // Use regular expression to capture time and AM/PM
                        const match = time.match(/^(\d{1,2}):(\d{2})(AM|PM)$/);
                        if (!match) return null; // Return null if the format is incorrect

                        let hours = parseInt(match[1], 10);
                        const minutes = match[2];
                        const period = match[3];

                        // Convert to 24-hour format
                        if (period === 'PM' && hours < 12) {
                            hours += 12;
                        }
                        if (period === 'AM' && hours === 12) {
                            hours = 0;
                        }

                        // Format the time as 'HH:MM'
                        return `${hours.toString().padStart(2, '0')}:${minutes}`;
                    }

                    if (isFirstShiftWeekoff && isSecondShiftWeekoff) {
                        let newFromTime = isPreviousShiftPM ? new Date(`${date}T10:00:00Z`) : new Date(`${date}T01:00:00Z`);
                        let newEndTime = isPreviousShiftPM ? new Date(`${newDateOnePlus}T${convertTo24Hour(previousEntry.shifttiming.split('to')[0])}Z`) : new Date(`${newDateOnePlus}T${convertTo24Hour(previousEntry.shifttiming.split('to')[0])}Z`);

                        shiftOnlyFromTime = new Date(`${date}T00:00:00Z`);
                        shiftOnlyEndTime = new Date(`${date}T00:00:00Z`);

                        let finalHrs = isPreviousShiftPM === 'PM' ? nightShiftBeforeHrs : dayShiftBeforeHrs;
                        let finalMin = isPreviousShiftPM === 'PM' ? nightShiftBeforeMin : dayShiftBeforeMin;
                        shiftEndTime = new Date(newEndTime.getTime() - (finalHrs * 60 * 60 * 1000 + (finalMin + 1) * 60 * 1000));
                        shiftFromTime = new Date(newFromTime.getTime() + 60 * 1000);

                        shiftEndTime = new Date(shiftEndTime.setSeconds(shiftEndTime.getSeconds() + 59));

                        data = { shiftFromTime, shiftEndTime, shiftsts: 'Disable', shifttiming: firstEntry.shift, shiftOnlyFromTime, shiftOnlyEndTime };
                    } else if (isFirstShiftWeekoff && ispreviousShiftWeekoff) {
                        let newFromTime = isPreviousShiftPM ? new Date(`${date}T${convertTo24Hour(secondEntry.shifttiming.split('to')[0])}Z`) : new Date(`${date}T${convertTo24Hour(secondEntry.shifttiming.split('to')[0])}Z`);
                        let newEndTime = isPreviousShiftPM ? new Date(`${newDateOnePlus}T${convertTo24Hour(secondEntry.shifttiming.split('to')[0])}Z`) : new Date(`${newDateOnePlus}T${convertTo24Hour(secondEntry.shifttiming.split('to')[0])}Z`);

                        shiftOnlyFromTime = new Date(`${date}T00:00:00Z`);
                        shiftOnlyEndTime = new Date(`${date}T00:00:00Z`);

                        let finalHrs = isPreviousShiftPM === 'PM' ? nightShiftBeforeHrs : dayShiftBeforeHrs;
                        let finalMin = isPreviousShiftPM === 'PM' ? nightShiftBeforeMin : dayShiftBeforeMin;
                        shiftEndTime = new Date(newEndTime.getTime() - (finalHrs * 60 * 60 * 1000 + finalMin * 60 * 1000));
                        shiftFromTime = new Date(newFromTime.getTime() - (finalHrs * 60 * 60 * 1000 + finalMin * 60 * 1000));

                        shiftEndTime = new Date(shiftEndTime.setSeconds(shiftEndTime.getSeconds() - 1));

                        data = { shiftFromTime, shiftEndTime, shiftsts: 'Disable', shifttiming: firstEntry.shift, shiftOnlyFromTime, shiftOnlyEndTime };
                    } else if (isFirstShiftWeekoff) {
                        let newFromTime = isPreviousShiftPM ? new Date(`${date}T10:00:00Z`) : new Date(`${date}T01:00:00Z`);
                        let newEndTime = isPreviousShiftPM ? new Date(`${newDateOnePlus}T${convertTo24Hour(secondEntry.shifttiming.split('to')[0])}Z`) : new Date(`${newDateOnePlus}T${convertTo24Hour(secondEntry.shifttiming.split('to')[0])}Z`);

                        shiftOnlyFromTime = new Date(`${date}T00:00:00Z`);
                        shiftOnlyEndTime = new Date(`${date}T00:00:00Z`);

                        let finalHrs = isPreviousShiftPM === 'PM' ? nightShiftBeforeHrs : dayShiftBeforeHrs;
                        let finalMin = isPreviousShiftPM === 'PM' ? nightShiftBeforeMin : dayShiftBeforeMin;
                        shiftEndTime = new Date(newEndTime.getTime() - (finalHrs * 60 * 60 * 1000 + (finalMin + 1) * 60 * 1000));
                        shiftFromTime = new Date(newFromTime.getTime() + 60 * 1000);

                        shiftEndTime = new Date(shiftEndTime.setSeconds(shiftEndTime.getSeconds() + 59));

                        data = { shiftFromTime, shiftEndTime, shiftsts: 'Disable', shifttiming: firstEntry.shift, shiftOnlyFromTime, shiftOnlyEndTime };
                    } else if (isSecondShiftWeekoff) {
                        let newFromTime = isFirstShiftPM ? new Date(`${date}T${convertTo24Hour(firstEntry.shifttiming.split('to')[0])}Z`) : new Date(`${date}T${convertTo24Hour(firstEntry.shifttiming.split('to')[0])}Z`);
                        let newEndTime = isFirstShiftPM ? new Date(`${newDateOnePlus}T10:00:00Z`) : new Date(`${newDateOnePlus}T01:00:00Z`);

                        shiftOnlyFromTime = isFirstShiftPM ? new Date(`${date}T${convertTo24Hour(firstEntry.shifttiming.split('to')[0])}Z`) : new Date(`${date}T${convertTo24Hour(firstEntry.shifttiming.split('to')[0])}Z`);
                        shiftOnlyEndTime = isFirstShiftPM ? new Date(`${newDateOnePlus}T${convertTo24Hour(firstEntry.shifttiming.split('to')[1])}Z`) : new Date(`${date}T${convertTo24Hour(firstEntry.shifttiming.split('to')[1])}Z`);

                        let finalHrs = isPreviousShiftPM === 'PM' ? nightShiftBeforeHrs : dayShiftBeforeHrs;
                        let finalMin = isPreviousShiftPM === 'PM' ? nightShiftBeforeMin : dayShiftBeforeMin;
                        shiftEndTime = new Date(newEndTime);
                        shiftFromTime = new Date(newFromTime.getTime() - (finalHrs * 60 * 60 * 1000 + finalMin * 60 * 1000));
                        shiftEndTime = new Date(shiftEndTime.setSeconds(shiftEndTime.getSeconds() + 59));

                        data = { shiftFromTime, shiftEndTime, shiftsts: firstEntry.shiftsts, shifttiming: firstEntry.shifttiming, shiftOnlyFromTime, shiftOnlyEndTime };
                    }
                    //  else if (firstEntryDoubleShift && thirdEntry) {
                    //   // return data.filter(entry => [dateSelectedFormat, dateSelectedFormatOnePlus].includes(entry.date) && entry.shiftmode === "Main Shift");
                    //   let newFromTime = isFirstShiftPM ? new Date(`${date}T${convertTo24Hour(firstEntry.shifttiming.split('to')[0])}Z`) : new Date(`${date}T${convertTo24Hour(firstEntry.shifttiming.split('to')[0])}Z`);
                    //   let newEndTime = isFirstShiftPM ? new Date(`${newDateOnePlus}T${convertTo24Hour(firstEntryDoubleShift.shifttiming.split('to')[0])}Z`) : new Date(`${date}T${convertTo24Hour(firstEntryDoubleShift.shifttiming.split('to')[0])}Z`);

                    //   let newFromTimeSecondShift = isFirstShiftPM ? new Date(`${newDateOnePlus}T${convertTo24Hour(firstEntryDoubleShift.shifttiming.split('to')[0])}Z`) : new Date(`${date}T${convertTo24Hour(firstEntryDoubleShift.shifttiming.split('to')[0])}Z`);
                    //   let newEndTimeSecondShift = isFirstShiftPM ? new Date(`${newDateOnePlus}T${convertTo24Hour(firstEntryDoubleShift.shifttiming.split('to')[1])}Z`) : new Date(`${newDateOnePlus}T${convertTo24Hour(firstEntryDoubleShift.shifttiming.split('to')[1])}Z`);

                    //   shiftOnlyFromTime = isFirstShiftPM ? new Date(`${date}T${convertTo24Hour(firstEntry.shifttiming.split('to')[0])}Z`) : new Date(`${date}T${convertTo24Hour(firstEntry.shifttiming.split('to')[0])}Z`);
                    //   shiftOnlyEndTime = isFirstShiftPM ? new Date(`${newDateOnePlus}T${convertTo24Hour(firstEntry.shifttiming.split('to')[1])}Z`) : new Date(`${date}T${convertTo24Hour(firstEntry.shifttiming.split('to')[1])}Z`);

                    //   const shiftOnlyFromTimeSecondShift = firstEntryDoubleShiftPM ? new Date(`${date}T${convertTo24Hour(firstEntryDoubleShift.shifttiming.split('to')[0])}Z`) : new Date(`${date}T${convertTo24Hour(firstEntryDoubleShift.shifttiming.split('to')[0])}Z`);
                    //   const shiftOnlyEndTimeSecondShift = firstEntryDoubleShiftPM ? new Date(`${newDateOnePlus}T${convertTo24Hour(firstEntryDoubleShift.shifttiming.split('to')[1])}Z`) : new Date(`${date}T${convertTo24Hour(firstEntryDoubleShift.shifttiming.split('to')[1])}Z`);

                    //   const finalHrs = isPreviousShiftPM === 'PM' ? nightShiftBeforeHrs : dayShiftBeforeHrs;
                    //   const finalMin = isPreviousShiftPM === 'PM' ? nightShiftBeforeMin : dayShiftBeforeMin;
                    //   shiftFromTime = new Date(newFromTime.getTime() - (finalHrs * 60 * 60 * 1000 + finalMin * 60 * 1000));

                    //   shiftEndTime = new Date(newEndTime.getTime() - (finalHrs * 60 * 60 * 1000 + (finalMin + 1) * 60 * 1000));
                    //   shiftEndTime = new Date(shiftEndTime.setSeconds(shiftEndTime.getSeconds() + 59));

                    //   shiftEndTimeFirstShift = newEndTime;

                    //   const shiftFromTimeSecondShift = new Date(newFromTimeSecondShift.setSeconds(newFromTimeSecondShift.getSeconds() + 1));
                    //   let shiftEndTimeSecondShift = new Date(newEndTimeSecondShift);
                    //   // shiftEndTimeSecondShift = new Date(shiftEndTimeSecondShift.setSeconds(shiftEndTimeSecondShift.getSeconds() + 59));

                    //   data = [
                    //     { shiftFromTime, shiftEndTime: shiftEndTimeFirstShift, shiftsts: 'Disable', shifttiming: firstEntry.shifttiming, shiftOnlyFromTime, shiftOnlyEndTime },
                    //     { shiftFromTime: shiftFromTimeSecondShift, shiftEndTime: shiftEndTimeSecondShift, shiftsts: 'Disable', shifttiming: firstEntryDoubleShift.shifttiming, shiftOnlyFromTime: shiftOnlyFromTimeSecondShift, shiftOnlyEndTime: shiftOnlyEndTimeSecondShift },
                    //   ];
                    // } else if (isBeforeDayDoubleShift && secondEntry) {
                    //   // return data.filter(entry => [dateSelectedFormat, dateSelectedFormatOnePlus].includes(entry.date) && entry.shiftmode === "Main Shift");
                    //   let newFromTime = isBeforeDayDoubleShiftPM ? new Date(`${date}T${convertTo24Hour(isBeforeDayDoubleShift.shifttiming.split('to')[1])}Z`) : new Date(`${date}T${convertTo24Hour(isBeforeDayDoubleShift.shifttiming.split('to')[1])}Z`);
                    //   let newEndTime = isBeforeDayDoubleShiftPM ? new Date(`${newDateOnePlus}T${convertTo24Hour(secondEntry.shifttiming.split('to')[0])}Z`) : new Date(`${newDateOnePlus}T${convertTo24Hour(secondEntry.shifttiming.split('to')[0])}Z`);

                    //   shiftOnlyFromTime = isFirstShiftPM ? new Date(`${date}T${'00:00:00'}Z`) : new Date(`${date}T${'00:00:00'}Z`);
                    //   shiftOnlyEndTime = isFirstShiftPM ? new Date(`${date}T${'00:00:00'}Z`) : new Date(`${date}T${'00:00:00'}Z`);

                    //   let finalHrs = isPreviousShiftPM === 'PM' ? nightShiftBeforeHrs : dayShiftBeforeHrs;
                    //   let finalMin = isPreviousShiftPM === 'PM' ? nightShiftBeforeMin : dayShiftBeforeMin;
                    //   shiftEndTime = new Date(newEndTime.getTime() - (finalHrs * 60 * 60 * 1000 + (finalMin + 1) * 60 * 1000));
                    //   // shiftFromTime = new Date(newFromTime.getTime() - (finalHrs * 60 * 60 * 1000 + finalMin * 60 * 1000));
                    //   shiftFromTime = new Date(newFromTime.getTime() + 60 * 1000);
                    //   shiftFromTime = new Date(shiftFromTime.setSeconds(shiftFromTime.getSeconds() - 59));

                    //   shiftEndTime = new Date(shiftEndTime.setSeconds(shiftEndTime.getSeconds() + 59));

                    //   data = { shiftFromTime, shiftEndTime, shiftsts: 'Disable', shifttiming: 'Not Allot', shiftOnlyFromTime, shiftOnlyEndTime };
                    // } else if (firstEntry && secondEntry) {
                    //   // return data.filter(entry => [dateSelectedFormat, dateSelectedFormatOnePlus].includes(entry.date) && entry.shiftmode === "Main Shift");
                    //   let newFromTime = isFirstShiftPM ? new Date(`${date}T${convertTo24Hour(firstEntry.shifttiming.split('to')[0])}Z`) : new Date(`${date}T${convertTo24Hour(firstEntry.shifttiming.split('to')[0])}Z`);
                    //   let newEndTime = isFirstShiftPM ? new Date(`${newDateOnePlus}T${convertTo24Hour(secondEntry.shifttiming.split('to')[0])}Z`) : new Date(`${newDateOnePlus}T${convertTo24Hour(secondEntry.shifttiming.split('to')[0])}Z`);

                    //   shiftOnlyFromTime = isFirstShiftPM ? new Date(`${date}T${convertTo24Hour(firstEntry.shifttiming.split('to')[0])}Z`) : new Date(`${date}T${convertTo24Hour(firstEntry.shifttiming.split('to')[0])}Z`);
                    //   shiftOnlyEndTime = isFirstShiftPM ? new Date(`${newDateOnePlus}T${convertTo24Hour(firstEntry.shifttiming.split('to')[1])}Z`) : new Date(`${date}T${convertTo24Hour(firstEntry.shifttiming.split('to')[1])}Z`);

                    //   let finalHrs = isPreviousShiftPM === 'PM' ? nightShiftBeforeHrs : dayShiftBeforeHrs;
                    //   let finalMin = isPreviousShiftPM === 'PM' ? nightShiftBeforeMin : dayShiftBeforeMin;
                    //   shiftEndTime = new Date(newEndTime.getTime() - (finalHrs * 60 * 60 * 1000 + (finalMin + 1) * 60 * 1000));
                    //   shiftFromTime = new Date(newFromTime.getTime() - (finalHrs * 60 * 60 * 1000 + finalMin * 60 * 1000));

                    //   shiftEndTime = new Date(shiftEndTime.setSeconds(shiftEndTime.getSeconds() + 59));

                    //   data = { shiftFromTime, shiftEndTime, shiftsts: firstEntry.shiftsts, shifttiming: firstEntry.shifttiming, shiftOnlyFromTime, shiftOnlyEndTime };
                    // }
                    else if (firstEntryDoubleShift && secondEntry.shifttiming === "Not Allotted") {
                        // return data.filter(entry => [dateSelectedFormat, dateSelectedFormatOnePlus].includes(entry.date) && entry.shiftmode === "Main Shift");
                        let newFromTime = isFirstShiftPM ? new Date(`${date}T${convertTo24Hour(firstEntry.shifttiming.split('to')[0])}Z`) : new Date(`${date}T${convertTo24Hour(firstEntry.shifttiming.split('to')[0])}Z`);
                        let newEndTime = isFirstShiftPM ? new Date(`${newDateOnePlus}T${convertTo24Hour(firstEntryDoubleShift.shifttiming.split('to')[0])}Z`) : new Date(`${date}T${convertTo24Hour(firstEntryDoubleShift.shifttiming.split('to')[0])}Z`);

                        let newFromTimeSecondShift = isFirstShiftPM ? new Date(`${newDateOnePlus}T${convertTo24Hour(firstEntryDoubleShift.shifttiming.split('to')[0])}Z`) : new Date(`${date}T${convertTo24Hour(firstEntryDoubleShift.shifttiming.split('to')[0])}Z`);
                        let newEndTimeSecondShift = isFirstShiftPM ? new Date(`${newDateOnePlus}T${convertTo24Hour(firstEntryDoubleShift.shifttiming.split('to')[1])}Z`) : new Date(`${newDateOnePlus}T${convertTo24Hour(firstEntryDoubleShift.shifttiming.split('to')[1])}Z`);

                        shiftOnlyFromTime = isFirstShiftPM ? new Date(`${date}T${convertTo24Hour(firstEntry.shifttiming.split('to')[0])}Z`) : new Date(`${date}T${convertTo24Hour(firstEntry.shifttiming.split('to')[0])}Z`);
                        shiftOnlyEndTime = isFirstShiftPM ? new Date(`${newDateOnePlus}T${convertTo24Hour(firstEntry.shifttiming.split('to')[1])}Z`) : new Date(`${date}T${convertTo24Hour(firstEntry.shifttiming.split('to')[1])}Z`);

                        const shiftOnlyFromTimeSecondShift = firstEntryDoubleShiftPM ? new Date(`${date}T${convertTo24Hour(firstEntryDoubleShift.shifttiming.split('to')[0])}Z`) : new Date(`${date}T${convertTo24Hour(firstEntryDoubleShift.shifttiming.split('to')[0])}Z`);
                        const shiftOnlyEndTimeSecondShift = firstEntryDoubleShiftPM ? new Date(`${newDateOnePlus}T${convertTo24Hour(firstEntryDoubleShift.shifttiming.split('to')[1])}Z`) : new Date(`${date}T${convertTo24Hour(firstEntryDoubleShift.shifttiming.split('to')[1])}Z`);

                        const finalHrs = isPreviousShiftPM === 'PM' ? nightShiftBeforeHrs : dayShiftBeforeHrs;
                        const finalMin = isPreviousShiftPM === 'PM' ? nightShiftBeforeMin : dayShiftBeforeMin;
                        shiftFromTime = new Date(newFromTime.getTime() - (finalHrs * 60 * 60 * 1000 + finalMin * 60 * 1000));

                        shiftEndTime = new Date(newEndTime.getTime() - (finalHrs * 60 * 60 * 1000 + (finalMin + 1) * 60 * 1000));
                        shiftEndTime = new Date(shiftEndTime.setSeconds(shiftEndTime.getSeconds() + 59));

                        let shiftEndTimeFirstShift = newEndTime;

                        const shiftFromTimeSecondShift = new Date(newFromTimeSecondShift.setSeconds(newFromTimeSecondShift.getSeconds() + 1));
                        let shiftEndTimeSecondShift = new Date(newEndTimeSecondShift);
                        // shiftEndTimeSecondShift = new Date(shiftEndTimeSecondShift.setSeconds(shiftEndTimeSecondShift.getSeconds() + 59));

                        data = [
                            { shiftFromTime, shiftEndTime: shiftEndTimeFirstShift, shiftsts: 'Disable', shifttiming: firstEntry.shifttiming, shiftOnlyFromTime, shiftOnlyEndTime },
                            { shiftFromTime: shiftFromTimeSecondShift, shiftEndTime: shiftEndTimeSecondShift, shiftsts: 'Disable', shifttiming: firstEntryDoubleShift.shifttiming, shiftOnlyFromTime: shiftOnlyFromTimeSecondShift, shiftOnlyEndTime: shiftOnlyEndTimeSecondShift },
                        ];
                    }
                    else if (firstEntryDoubleShift && secondEntry.shifttiming != "Not Allotted") {
                        // return data.filter(entry => [dateSelectedFormat, dateSelectedFormatOnePlus].includes(entry.date) && entry.shiftmode === "Main Shift");
                        let newFromTime = isFirstShiftPM ? new Date(`${date}T${convertTo24Hour(firstEntry.shifttiming.split('to')[0])}Z`) : new Date(`${date}T${convertTo24Hour(firstEntry.shifttiming.split('to')[0])}Z`);
                        let newEndTime = firstEntryDoubleShiftPM ? new Date(`${newDateOnePlus}T${convertTo24Hour(firstEntryDoubleShift.shifttiming.split('to')[0])}Z`) : new Date(`${newDateOnePlus}T${convertTo24Hour(firstEntryDoubleShift.shifttiming.split('to')[0])}Z`);

                        let newFromTimeSecondShift = isFirstShiftPM ? new Date(`${newDateOnePlus}T${convertTo24Hour(firstEntryDoubleShift.shifttiming.split('to')[0])}Z`) : new Date(`${date}T${convertTo24Hour(firstEntryDoubleShift.shifttiming.split('to')[0])}Z`);
                        let newEndTimeSecondShift = isSecondShiftPM ? new Date(`${newDateOnePlus}T${convertTo24Hour(secondEntry.shifttiming.split('to')[0])}Z`) : new Date(`${newDateOnePlus}T${convertTo24Hour(secondEntry.shifttiming.split('to')[0])}Z`);

                        shiftOnlyFromTime = isFirstShiftPM ? new Date(`${date}T${convertTo24Hour(firstEntry.shifttiming.split('to')[0])}Z`) : new Date(`${date}T${convertTo24Hour(firstEntry.shifttiming.split('to')[0])}Z`);
                        shiftOnlyEndTime = isFirstShiftPM ? new Date(`${newDateOnePlus}T${convertTo24Hour(firstEntry.shifttiming.split('to')[1])}Z`) : new Date(`${date}T${convertTo24Hour(firstEntry.shifttiming.split('to')[1])}Z`);

                        const shiftOnlyFromTimeSecondShift = firstEntryDoubleShiftPM ? new Date(`${date}T${convertTo24Hour(firstEntryDoubleShift.shifttiming.split('to')[0])}Z`) : new Date(`${date}T${convertTo24Hour(firstEntryDoubleShift.shifttiming.split('to')[0])}Z`);
                        const shiftOnlyEndTimeSecondShift = firstEntryDoubleShiftPM ? new Date(`${newDateOnePlus}T${convertTo24Hour(firstEntryDoubleShift.shifttiming.split('to')[1])}Z`) : new Date(`${date}T${convertTo24Hour(firstEntryDoubleShift.shifttiming.split('to')[1])}Z`);

                        const finalHrs = isPreviousShiftPM === 'PM' ? nightShiftBeforeHrs : dayShiftBeforeHrs;
                        const finalMin = isPreviousShiftPM === 'PM' ? nightShiftBeforeMin : dayShiftBeforeMin;
                        shiftFromTime = new Date(newFromTime.getTime() - (finalHrs * 60 * 60 * 1000 + finalMin * 60 * 1000));

                        shiftEndTime = new Date(newEndTime.getTime() - (finalHrs * 60 * 60 * 1000 + (finalMin + 1) * 60 * 1000));
                        shiftEndTime = new Date(shiftEndTime.setSeconds(shiftEndTime.getSeconds() + 59));

                        let shiftEndTimeSecondShift = new Date(newEndTimeSecondShift.getTime() - (finalHrs * 60 * 60 * 1000 + (finalMin + 1) * 60 * 1000));
                        shiftEndTimeSecondShift = new Date(shiftEndTimeSecondShift.setSeconds(shiftEndTimeSecondShift.getSeconds() + 59));

                        let shiftEndTimeFirstShift = newEndTime;

                        const shiftFromTimeSecondShift = new Date(newFromTimeSecondShift.setSeconds(newFromTimeSecondShift.getSeconds() + 1));
                        //  let shiftEndTimeFirstShift = newEndTime;

                        //   const shiftFromTimeSecondShift = new Date(newFromTimeSecondShift.setSeconds(newFromTimeSecondShift.getSeconds() + 1));
                        //   let shiftEndTimeSecondShift = new Date(newEndTimeSecondShift);
                        // shiftEndTimeSecondShift = new Date(shiftEndTimeSecondShift.setSeconds(shiftEndTimeSecondShift.getSeconds() + 59));

                        data = [
                            { shiftFromTime, shiftEndTime: shiftEndTimeFirstShift, shiftsts: 'Disable', shifttiming: firstEntry.shifttiming, shiftOnlyFromTime, shiftOnlyEndTime },
                            { shiftFromTime: shiftFromTimeSecondShift, shiftEndTime: shiftEndTimeSecondShift, shiftsts: 'Disable', shifttiming: firstEntryDoubleShift.shifttiming, shiftOnlyFromTime: shiftOnlyFromTimeSecondShift, shiftOnlyEndTime: shiftOnlyEndTimeSecondShift },
                        ];
                    }
                    else if (isBeforeDayDoubleShift && firstEntry.shifttiming === "Not Allotted" && secondEntry) {
                        // return data.filter(entry => [dateSelectedFormat, dateSelectedFormatOnePlus].includes(entry.date) && entry.shiftmode === "Main Shift");
                        let newFromTime = isBeforeDayDoubleShiftPM ? new Date(`${date}T${convertTo24Hour(isBeforeDayDoubleShift.shifttiming.split('to')[1])}Z`) : new Date(`${date}T${convertTo24Hour(isBeforeDayDoubleShift.shifttiming.split('to')[1])}Z`);
                        let newEndTime = isBeforeDayDoubleShiftPM ? new Date(`${newDateOnePlus}T${convertTo24Hour(secondEntry.shifttiming.split('to')[0])}Z`) : new Date(`${newDateOnePlus}T${convertTo24Hour(secondEntry.shifttiming.split('to')[0])}Z`);

                        shiftOnlyFromTime = isFirstShiftPM ? new Date(`${date}T${'00:00:00'}Z`) : new Date(`${date}T${'00:00:00'}Z`);
                        shiftOnlyEndTime = isFirstShiftPM ? new Date(`${date}T${'00:00:00'}Z`) : new Date(`${date}T${'00:00:00'}Z`);

                        let finalHrs = isPreviousShiftPM === 'PM' ? nightShiftBeforeHrs : dayShiftBeforeHrs;
                        let finalMin = isPreviousShiftPM === 'PM' ? nightShiftBeforeMin : dayShiftBeforeMin;
                        shiftEndTime = new Date(newEndTime.getTime() - (finalHrs * 60 * 60 * 1000 + (finalMin + 1) * 60 * 1000));
                        // shiftFromTime = new Date(newFromTime.getTime() - (finalHrs * 60 * 60 * 1000 + finalMin * 60 * 1000));
                        shiftFromTime = new Date(newFromTime.getTime() + 60 * 1000);
                        shiftFromTime = new Date(shiftFromTime.setSeconds(shiftFromTime.getSeconds() - 59));

                        shiftEndTime = new Date(shiftEndTime.setSeconds(shiftEndTime.getSeconds() + 59));

                        data = { shiftFromTime, shiftEndTime, shiftsts: 'Disable', shifttiming: 'Not Allot', shiftOnlyFromTime, shiftOnlyEndTime };
                    }
                    else if (firstEntry.shifttiming === "Not Allotted" && secondEntry && previousEntry) {
                        // return data.filter(entry => [dateSelectedFormat, dateSelectedFormatOnePlus].includes(entry.date) && entry.shiftmode === "Main Shift");
                        let newFromTime = isPreviousShiftPM ? new Date(`${date}T${convertTo24Hour(previousEntry.shifttiming.split('to')[1])}Z`) : new Date(`${newDateOneMinus}T${convertTo24Hour(previousEntry.shifttiming.split('to')[1])}Z`);
                        let newEndTime = isSecondShiftPM ? new Date(`${newDateOnePlus}T${convertTo24Hour(secondEntry.shifttiming.split('to')[0])}Z`) : new Date(`${newDateOnePlus}T${convertTo24Hour(secondEntry.shifttiming.split('to')[0])}Z`);

                        shiftOnlyFromTime = isFirstShiftPM ? new Date(`${date}T${'00:00:00'}Z`) : new Date(`${date}T${'00:00:00'}Z`);
                        shiftOnlyEndTime = isFirstShiftPM ? new Date(`${date}T${'00:00:00'}Z`) : new Date(`${date}T${'00:00:00'}Z`);

                        let finalHrs = isPreviousShiftPM === 'PM' ? nightShiftBeforeHrs : dayShiftBeforeHrs;
                        let finalMin = isPreviousShiftPM === 'PM' ? nightShiftBeforeMin : dayShiftBeforeMin;
                        shiftEndTime = new Date(newEndTime.getTime() - (finalHrs * 60 * 60 * 1000 + (finalMin + 1) * 60 * 1000));
                        // shiftFromTime = new Date(newFromTime.getTime() - (finalHrs * 60 * 60 * 1000 + finalMin * 60 * 1000));
                        shiftFromTime = new Date(newFromTime.getTime() + 60 * 1000);
                        shiftFromTime = new Date(shiftFromTime.setSeconds(shiftFromTime.getSeconds() - 59));

                        shiftEndTime = new Date(shiftEndTime.setSeconds(shiftEndTime.getSeconds() + 59));

                        data = { shiftFromTime, shiftEndTime, shiftsts: 'Disable', shifttiming: 'Not Allot', shiftOnlyFromTime, shiftOnlyEndTime };
                    }
                    else if (firstEntry && secondEntry.shifttiming === "Not Allotted") {
                        // return data.filter(entry => [dateSelectedFormat, dateSelectedFormatOnePlus].includes(entry.date) && entry.shiftmode === "Main Shift");
                        let newFromTime = isFirstShiftPM ? new Date(`${date}T${convertTo24Hour(firstEntry.shifttiming.split('to')[0])}Z`) : new Date(`${date}T${convertTo24Hour(firstEntry.shifttiming.split('to')[0])}Z`);
                        let newEndTime = isFirstShiftPM ? new Date(`${newDateOnePlus}T${convertTo24Hour(firstEntry.shifttiming.split('to')[1])}Z`) : new Date(`${date}T${convertTo24Hour(firstEntry.shifttiming.split('to')[1])}Z`);

                        shiftOnlyFromTime = isFirstShiftPM ? new Date(`${date}T${convertTo24Hour(firstEntry.shifttiming.split('to')[0])}Z`) : new Date(`${date}T${convertTo24Hour(firstEntry.shifttiming.split('to')[0])}Z`);
                        shiftOnlyEndTime = isFirstShiftPM ? new Date(`${newDateOnePlus}T${convertTo24Hour(firstEntry.shifttiming.split('to')[1])}Z`) : new Date(`${date}T${convertTo24Hour(firstEntry.shifttiming.split('to')[1])}Z`);

                        let finalHrs = isPreviousShiftPM === 'PM' ? nightShiftBeforeHrs : dayShiftBeforeHrs;
                        let finalMin = isPreviousShiftPM === 'PM' ? nightShiftBeforeMin : dayShiftBeforeMin;
                        // shiftEndTime = new Date(newEndTime.getTime() - (finalHrs * 60 * 60 * 1000 + (finalMin + 1) * 60 * 1000));
                        shiftFromTime = new Date(newFromTime.getTime() - (finalHrs * 60 * 60 * 1000 + finalMin * 60 * 1000));

                        // shiftEndTime = new Date(shiftEndTime.setSeconds(shiftEndTime.getSeconds() + 59));
                        shiftEndTime = newEndTime;
                        data = { shiftFromTime, shiftEndTime, shiftsts: firstEntry.shiftsts, shifttiming: firstEntry.shifttiming, shiftOnlyFromTime, shiftOnlyEndTime };
                    }
                    else if (firstEntry && secondEntry) {
                        // return data.filter(entry => [dateSelectedFormat, dateSelectedFormatOnePlus].includes(entry.date) && entry.shiftmode === "Main Shift");
                        let newFromTime = isFirstShiftPM ? new Date(`${date}T${convertTo24Hour(firstEntry.shifttiming.split('to')[0])}Z`) : new Date(`${date}T${convertTo24Hour(firstEntry.shifttiming.split('to')[0])}Z`);
                        let newEndTime = isFirstShiftPM ? new Date(`${newDateOnePlus}T${convertTo24Hour(secondEntry.shifttiming.split('to')[0])}Z`) : new Date(`${newDateOnePlus}T${convertTo24Hour(secondEntry.shifttiming.split('to')[0])}Z`);

                        shiftOnlyFromTime = isFirstShiftPM ? new Date(`${date}T${convertTo24Hour(firstEntry.shifttiming.split('to')[0])}Z`) : new Date(`${date}T${convertTo24Hour(firstEntry.shifttiming.split('to')[0])}Z`);
                        shiftOnlyEndTime = isFirstShiftPM ? new Date(`${newDateOnePlus}T${convertTo24Hour(firstEntry.shifttiming.split('to')[1])}Z`) : new Date(`${date}T${convertTo24Hour(firstEntry.shifttiming.split('to')[1])}Z`);

                        let finalHrs = isPreviousShiftPM === 'PM' ? nightShiftBeforeHrs : dayShiftBeforeHrs;
                        let finalMin = isPreviousShiftPM === 'PM' ? nightShiftBeforeMin : dayShiftBeforeMin;
                        shiftEndTime = new Date(newEndTime.getTime() - (finalHrs * 60 * 60 * 1000 + (finalMin + 1) * 60 * 1000));
                        shiftFromTime = new Date(newFromTime.getTime() - (finalHrs * 60 * 60 * 1000 + finalMin * 60 * 1000));

                        shiftEndTime = new Date(shiftEndTime.setSeconds(shiftEndTime.getSeconds() + 59));

                        data = { shiftFromTime, shiftEndTime, shiftsts: firstEntry.shiftsts, shifttiming: firstEntry.shifttiming, shiftOnlyFromTime, shiftOnlyEndTime };
                    }

                    else {
                        data = { shiftFromTime: new Date(shiftFromTime), shiftEndTime: new Date(shiftEndTime), shiftOnlyFromTime, shiftOnlyEndTime, shiftsts: 'Disable' };
                    }

                    return data; // Return the original data if conditions are not met
                }

                userShiftTimings = finaluserFiltered.length >= 3 ? filterData(finaluserFiltered) : { shiftFromTime: new Date(shiftFromTime), shiftEndTime: new Date(shiftEndTime), shiftOnlyFromTime, shiftOnlyEndTime, shiftsts: 'Disable' };

                if (finaluserFiltered.find((d) => d.rowformattedDate === dateSelectedFormat && d.shiftMode === 'Second Shift' && d.shifttiming != undefined)) {
                    return [
                        {
                            ...item,
                            ...(finaluserFiltered.find((d) => d.rowformattedDate === dateSelectedFormat && d.shiftMode === 'Main Shift') || {}),
                            companyname: item.companyname,
                            empcode: item.empcode,
                            company: item.company,
                            unit: item.unit,
                            branch: item.branch,
                            team: item.team,
                            username: item.username,
                            department: item.department,
                            doj: item.doj,
                            exp: item.exp,
                            process: item.process,
                            dojDate: item.dojDate,
                            userids: item.userids,
                            userShiftTimings: userShiftTimings[0],

                            // rowformattedDate: dateSelectedFormat,
                            departmentlog: [],
                            processlog: [],
                            boardingLog: [],
                            assignExpLog: [],
                            shiftallot: [],
                            username: item.companyname,
                        },
                        {
                            ...item,
                            ...(finaluserFiltered.find((d) => d.rowformattedDate === dateSelectedFormat && d.shiftMode === 'Second Shift') || {}),
                            companyname: item.companyname,
                            empcode: item.empcode,
                            company: item.company,
                            unit: item.unit,
                            branch: item.branch,
                            team: item.team,
                            username: item.username,
                            department: item.department,
                            doj: item.doj,
                            exp: item.exp,
                            process: item.process,
                            dojDate: item.dojDate,
                            userids: item.userids,
                            userShiftTimings: userShiftTimings[1],

                            // rowformattedDate: dateSelectedFormat,
                            departmentlog: [],
                            processlog: [],
                            boardingLog: [],
                            assignExpLog: [],
                            shiftallot: [],
                            username: item.companyname,
                        },
                    ];
                } else {
                    return {
                        ...item,
                        ...(finaluserFiltered.find((d) => d.rowformattedDate === dateSelectedFormat) || {}),
                        companyname: item.companyname,
                        empcode: item.empcode,
                        company: item.company,
                        unit: item.unit,
                        branch: item.branch,
                        team: item.team,
                        username: item.username,
                        department: item.department,
                        doj: item.doj,
                        exp: item.exp,
                        process: item.process,
                        dojDate: item.dojDate,
                        userids: item.userids,
                        //  assignExpLog: item.assignExpLog.filter((d) => d.expmode != 'Auto' && d.expmode != 'Manual').sort((a, b) => new Date(a.updatedate) - new Date(b.updatedate)),
                        userShiftTimings: userShiftTimings,

                        // rowformattedDate: dateSelectedFormat,
                        departmentlog: [],
                        processlog: [],
                        boardingLog: [],
                        assignExpLog: [],
                        shiftallot: [],
                        username: item.companyname,
                    };
                }
            } catch (err) {
            }
        });
    } catch (err) {
        return next(new ErrorHandler('Records not found!', 404));
    }
    return res.status(200).json({ finaluser });
});
exports.updateLoginAllotMoveToLive = catchAsyncErrors(async (req, res, next) => {
    const { empname, company, branch, unit, team, date, time } = req.body;

    // Validate required fields
    if (!empname || !company || !branch || !unit || !team || !date || !time) {
        return next(new ErrorHandler("All fields are required.", 400));
    }

    try {
        // Step 1: Update the outer fields if empname matches
        const updateFields = { company, branch, unit, team, date, time };
        const outerUpdateResult = await ClientUserID.updateMany(
            { empname },
            { $set: updateFields }
        );

        // If no documents were updated, respond early
        if (outerUpdateResult.modifiedCount === 0) {
            return res.status(200).json({
                success: true,
                message: "No records found for the given employee name.",
            });
        }

        // Step 2: Fetch matching documents and prepare bulk operations
        const matchingDocuments = await ClientUserID.find({ empname });
        const bulkOperations = matchingDocuments.map((doc) => ({
            updateOne: {
                filter: { _id: doc._id },
                update: {
                    $push: {
                        loginallotlog: {
                            ...updateFields, // Use spread to avoid repetition
                            empname: doc.empname,
                            empcode: doc.empcode,
                            userid: doc.userid,
                        },
                    },
                },
            },
        }));

        // Step 3: Perform bulk write operation
        await ClientUserID.bulkWrite(bulkOperations);

        return res.status(200).json({
            success: true,
            message: `${outerUpdateResult.modifiedCount} employee record(s) updated successfully.`,
        });
    } catch (error) {
        // Handle errors gracefully
        const errorMessage =
            error.response?.data?.message || "Error updating employee details!";
        const statusCode = error.response?.status || 500;
        return next(new ErrorHandler(errorMessage, statusCode));
    }
});
exports.updateLoginAllotLogPages = catchAsyncErrors(async (req, res, next) => {
    const { empname, company, branch, unit, team, date } = req.body;
    if (!empname || !company || !branch || !unit || !team || !date) {
        return next(new ErrorHandler("All fields are required.", 400));
    }

    // Parse the provided date
    const providedDate = new Date(date);

    // Calculate the date 1 month prior
    const oneMonthBeforeDate = new Date(providedDate);
    oneMonthBeforeDate.setMonth(providedDate.getMonth() + 1);

    const firstDate = moment(oneMonthBeforeDate).format("YYYY-MM-DD");
    const secondDate = moment(providedDate).format("YYYY-MM-DD");
    try {
        // Step 1: Update outer fields if empname matches and date condition is satisfied
        const outerUpdateResult = await ClientUserID.updateMany(
            {
                empname,
                date: { $gte: secondDate, $lte: firstDate },
            },
            {
                $set: {
                    company,
                    branch,
                    unit,
                    team,
                },
            }
        );


        // Step 3: Ensure the last object in the array matches the date condition
        // const lastArrayUpdateResult = await ClientUserID.updateMany(
        //   {
        //     "loginallotlog.empname": empname,
        //     "loginallotlog.date": { $gte: secondDate, $lte: firstDate },
        //   },
        //   {
        //     $set: {
        //       "loginallotlog.$[lastLog].company": company,
        //       "loginallotlog.$[lastLog].branch": branch,
        //       "loginallotlog.$[lastLog].unit": unit,
        //       "loginallotlog.$[lastLog].team": team,
        //     },
        //   },
        //   {
        //     arrayFilters: [
        //       {
        //         "lastLog.empname": empname,
        //         "lastLog.date": { $gte: secondDate, $lte: firstDate },
        //       },
        //     ],
        //   }
        // );

        const documents = await ClientUserID.find({
            "loginallotlog.empname": empname,
            "loginallotlog.date": { $gte: secondDate, $lte: firstDate },
        });

        if (documents.length === 0) {
        } else {
            for (const document of documents) {
                // Find the last matching index in the `loginallotlog` array
                const logs = document?.loginallotlog;
                let lastIndex = -1;

                // for (let i = logs.length - 1; i >= 0; i--) {
                if (
                    logs[logs.length - 1].empname === empname &&
                    logs[logs.length - 1].date >= secondDate &&
                    logs[logs.length - 1].date <= firstDate &&
                    logs.length !== 0
                ) {
                    lastIndex = logs.length - 1;
                    // break;
                }
                // }
                if (lastIndex !== -1) {
                    // Construct the update query dynamically
                    const updateFields = {};
                    updateFields[`loginallotlog.${lastIndex}.company`] = company;
                    updateFields[`loginallotlog.${lastIndex}.branch`] = branch;
                    updateFields[`loginallotlog.${lastIndex}.unit`] = unit;
                    updateFields[`loginallotlog.${lastIndex}.team`] = team;
                    // Update the document
                    await ClientUserID.updateOne(
                        { _id: document._id },
                        { $set: updateFields }
                    );

                } else {
                }
            }
        }



        // If no updates were made, return a 404


        return res.status(200).json({
            success: true,
            message: "Employee details updated successfully.",
        });

    } catch (error) {
        if (error.response) {
            return next(
                new ErrorHandler(
                    error.response.data.message || "An error occurred",
                    error.response.status || 500
                )
            );
        } else if (error.request) {
            return next(new ErrorHandler("No response received from server", 500));
        } else {
            return next(new ErrorHandler("Error updating employee details!", 500));
        }
    }
});
exports.getBiometricUsersAll = catchAsyncErrors(async (req, res, next) => {
    let finalarray;

    try {
        const {
            pageName,
            company,
            branch,
            unit,
            team,
            department,
            employee,
            profileimage,
        } = req.body;

        // Define the past 3 days range
        const today = moment();
        const pastThreeAttendaysDays = [
            today.clone().format("DD-MM-YYYY"),
            today.clone().subtract(1, "days").format("DD-MM-YYYY"),
            today.clone().subtract(2, "days").format("DD-MM-YYYY"),
            today.clone().subtract(3, "days").format("DD-MM-YYYY"),
        ];
        const pastThreeLeaveDays = [
            today.clone().format("DD/MM/YYYY"),
            today.clone().subtract(1, "days").format("DD/MM/YYYY"),
            today.clone().subtract(2, "days").format("DD/MM/YYYY"),
            today.clone().subtract(3, "days").format("DD/MM/YYYY"),
        ];
        const pastThreeDaysISO = [
            today.clone().format("YYYY-MM-DD"),
            today.clone().subtract(1, "days").format("YYYY-MM-DD"),
            today.clone().subtract(2, "days").format("YYYY-MM-DD"),
            today.clone().subtract(3, "days").format("YYYY-MM-DD"),
        ];
        // Fetch relevant attendance records for the past 3 days
        let filterQuery = {
            enquirystatus: {
                $nin: ["Enquiry Purpose"],
            },
            resonablestatus: {
                $nin: [
                    "Not Joined",
                    "Postponed",
                    "Rejected",
                    "Closed",
                    "Releave Employee",
                    "Absconded",
                    "Hold",
                    "Terminate",
                ],
            },

            // Conditional company filter
            ...(company.length && { company: { $in: company } }),
            // Conditional branch filter
            ...(branch.length && { branch: { $in: branch } }),
            // Conditional unit filter
            ...(unit.length && { unit: { $in: unit } }),
            // Conditional team filter
            ...(team.length && { team: { $in: team } }),
            // Conditional department filter
            ...(department.length && { department: { $in: department } }),
            // Conditional employee filter
            ...(employee.length && { companyname: { $in: employee } }),
        };

        if (pageName === "Employee") {
            filterQuery.workmode = {
                $ne: "Internship",
            };
        } else if (pageName === "Internship") {
            filterQuery.workmode = {
                $eq: "Internship",
            };
        }

        const noticeperiodpipeline = [
            {
                // Sort by empname and then by createdAt in descending order
                $sort: { empname: 1, createdAt: -1 },
            },
            {
                // Group by empname and select the first document per group (most recent)
                $group: {
                    _id: "$empname", // Group by empname
                    mostRecentDocument: { $first: "$$ROOT" }, // Select the most recent document per empname
                },
            },
            {
                // Project the necessary fields from the most recent document
                $replaceRoot: { newRoot: "$mostRecentDocument" },
            },
            {
                $match: {
                    $or: [
                        {
                            exitstatus: true,
                        },
                        // Condition for "Approved" status
                        {
                            approvedStatus: "true",
                            cancelstatus: false,
                        },
                        // Condition for "Applied" status
                        {
                            status: "Applied",
                        },
                    ],
                    // Add the new conditions
                    rejectStatus: { $ne: "true" },
                    cancelstatus: { $ne: true },
                    continuestatus: { $ne: true },
                },
            },
            {
                $project: {
                    empname: 1,
                    empcode: 1,
                    status: 1,
                    rejectStatus: 1,
                    cancelstatus: 1,
                    approvedStatus: 1,
                    continuestatus: 1,
                    recheckStatus: 1,
                    exitstatus: 1,
                    createdAt: 1,
                },
            },
        ];
        // Run all queries in parallel using Promise.all
        const [allusers, attendance, allLeaveStatus, holidays, noticeperiodstatus] =
            await Promise.all([
                User.find(filterQuery, {
                    status: 1,
                    empcode: 1,
                    nexttime: 1,

                    companyname: 1,
                    username: 1,
                    email: 1,
                    employeecount: 1,
                    systemmode: 1,
                    companyemail: 1,
                    branch: 1,
                    unit: 1,
                    team: 1,
                    company: 1,
                    shift: 1,
                    experience: 1,
                    doj: 1,
                    dot: 1,
                    workmode: 1,
                    internstatus: 1,
                    resonablestatus: 1,
                    reasonname: 1,
                    rejoin: 1,
                    reasonablestatusremarks: 1,
                    department: 1,
                    dob: 1,
                    approvedremotestatus: 1,
                    company: 1,
                    reasondate: 1,
                    empreason: 1,
                    percentage: 1,
                    doj: 1,
                    dot: 1,
                    role: 1,
                    assignExpLog: 1,
                    resonablestatus: 1,
                    reasonname: 1,
                    rejoin: 1,
                    reasonablestatusremarks: 1,
                    department: 1,
                    dob: 1,
                    gender: 1,
                    maritalstatus: 1,
                    bloodgroup: 1,
                    location: 1,
                    aadhar: 1,
                    panno: 1,
                    panstatus: 1,
                    panrefno: 1,
                    fathername: 1,
                    mothername: 1,
                    contactfamily: 1,
                    contactno: 1,
                    prefix: 1,
                    assignExpMode: 1,
                    assignExpvalue: 1,
                    processtype: 1,
                    processduration: 1,
                    date: 1,
                    time: 1,
                    grosssalary: 1,
                    timemins: 1,
                    modeexperience: 1,
                    targetexperience: 1,
                    targetpts: 1,
                    dom: 1,
                    contactpersonal: 1,
                    designationlog: 1,
                    processlog: 1,
                    boardingLog: 1,
                    attendancemode: 1,
                    company: 1,
                    reasondate: 1,
                    empreason: 1,
                    percentage: 1,
                    empcode: 1,
                    companyname: 1,
                    team: 1,
                    username: 1,
                    usernameautogenerate: 1,
                    workmode: 1,
                    email: 1,
                    employeecount: 1,
                    systemmode: 1,
                    companyemail: 1,
                    unit: 1,
                    branch: 1,
                    designation: 1,
                    floor: 1,
                    shift: 1,
                    reportingto: 1,
                    experience: 1,
                    doj: 1,
                    dot: 1,
                    bankdetails: 1,
                    shifttiming: 1,
                    shiftgrouping: 1,
                    shifttype: 1,
                    legalname: 1,
                    callingname: 1,
                    pdoorno: 1,
                    pstreet: 1,
                    parea: 1,
                    plandmark: 1,
                    ptaluk: 1,
                    ppost: 1,
                    ppincode: 1,
                    pcountry: 1,
                    pstate: 1,
                    pcity: 1,
                    cdoorno: 1,
                    cstreet: 1,
                    carea: 1,
                    role: 1,
                    clandmark: 1,
                    ctaluk: 1,
                    cpost: 1,
                    cpincode: 1,
                    ccountry: 1,
                    cstate: 1,
                    ccity: 1,
                    reasondate: 1,
                    process: 1,
                    workstation: 1,
                    workstationinput: 1,
                    workstationofficestatus: 1,
                    weekoff: 1,
                    originalpassword: 1,
                    enquirystatus: 1,
                    area: 1,
                    enableworkstation: 1,
                    wordcheck: 1,
                    shiftallot: 1,
                    firstname: 1,
                    lastname: 1,
                    employeecount: 1,
                    emergencyno: 1,
                    name: 1,
                    salarysetup: 1,
                    mode: 1,
                    salarycode: 1,
                    basic: 1,
                    hra: 1,
                    conveyance: 1,
                    medicalallowance: 1,
                    productionallowance: 1,
                    otherallowance: 1,
                    productionallowancetwo: 1,
                    pffromdate: 1,
                    pfenddate: 1,
                    esifromdate: 1,
                    esienddate: 1,
                    pfesistatus: 1,
                    remoteworkmodestatus: 1,
                    addremoteworkmode: 1,
                    cardnumber: 1,
                }).lean(),

                Attendance.find(
                    {
                        date: {
                            $in: pastThreeAttendaysDays,
                        },
                    },
                    { date: 1, userid: 1 }
                ).lean(),

                ApplyLeave.find(
                    {
                        date: { $in: pastThreeLeaveDays },
                        status: { $nin: ["Rejected"] },
                    },
                    { employeename: 1, employeeid: 1, date: 1 }
                ).lean(),

                Holiday.find(
                    {
                        date: { $in: pastThreeDaysISO },
                    },
                    {
                        date: 1,
                        employee: 1,
                        company: 1,
                        applicablefor: 1,
                        unit: 1,
                        team: 1,
                    }
                ).lean(),

                Noticeperiod.aggregate(noticeperiodpipeline).exec(),
            ]);

        let employeeDocumentsMap = {};

        // Fetch profile images only if profileimage is true
        if (profileimage) {
            const employeeDocuments = await EmployeeDocuments.find(
                {
                    commonid: { $in: allusers.map((user) => user._id.toString()) },
                },
                { profileimage: 1, commonid: 1 }
            ).lean();

            // Create a map of employee documents by commonid (user's _id)
            employeeDocumentsMap = employeeDocuments.reduce((acc, doc) => {
                acc[doc.commonid] = doc.profileimage || "";
                return acc;
            }, {});
        }
        // Create a map for fast lookup of attendance records
        const attendanceMap = attendance.reduce((acc, item) => {
            const userId = item.userid.toString();
            const date = moment(item.date, "DD-MM-YYYY").format("DD/MM/YYYY");
            if (!acc[userId]) {
                acc[userId] = [];
            }
            acc[userId].push(date);
            return acc;
        }, {});

        // Create a map for fast lookup of leave records
        let allUserEmpname = allusers.map((user) => user.companyname)
        const myCheckList = await MyCheckList.find({ candidatename: { $in: allUserEmpname } }).lean();
        let leaveWithCheckList = allLeaveStatus.map((item) => {
            let foundData = myCheckList?.find(
                (dataNew) => dataNew.commonid == item._id
            );
            let areAllGroupsCompleted = foundData?.groups?.every(
                (itemNew) => (itemNew.data !== undefined && itemNew.data !== "") || itemNew.files !== undefined
            );

            if (areAllGroupsCompleted) {
                return {
                    ...item,
                    updatestatus: "Completed",
                };
            }
            return null;
        }).filter(item => item);

        // Create a map for fast lookup of leave records
        const leaveMap = leaveWithCheckList.reduce((acc, item) => {
            const userKey = `${item.employeeid}_${item.employeename}`;
            const leaveDates = item.date.map((date) =>
                moment(date, "DD/MM/YYYY").format("DD/MM/YYYY")
            );
            if (!acc[userKey]) {
                acc[userKey] = [];
            }
            acc[userKey].push(...leaveDates);
            return acc;
        }, {});

        // Create a map for fast lookup of holiday records
        const employeeMatchesUser = (user, holiday) => {

            return (
                holiday.company.includes(user.company) &&
                holiday.applicablefor.includes(user.branch) &&
                holiday.unit.includes(user.unit) &&
                holiday.team.includes(user.team) &&
                (holiday.employee.includes(user.companyname) ||
                    holiday.employee.includes("ALL"))
            );
        };
        const holidayMap = holidays.reduce((acc, item) => {
            const date = moment(item.date).format("DD/MM/YYYY");

            allusers.forEach((user) => {
                if (employeeMatchesUser(user, item)) {
                    if (!acc[user.empcode]) {
                        acc[user.empcode] = [];
                    }
                    acc[user.empcode].push(date);
                }
            });

            return acc;
        }, {});

        // Create a map for fast lookup
        const noticePeriodMap = noticeperiodstatus.reduce((acc, item) => {
            const key = `${item.empname}_${item.empcode}`;
            acc[key] = item;
            return acc;
        }, {});

        // Function to check the status for the past 3 days
        const checkStatusForPast3Days = (
            userId,
            empcode,
            employeename,
            weekOffDays,
            doj
        ) => {
            const userKey = `${empcode}_${employeename}`;
            let absentDays = 0;
            let leaveDays = 0;
            let holidayDays = 0;
            const isNewJoiner = pastThreeDaysISO.includes(doj);
            for (let date of pastThreeLeaveDays) {
                // const dayOfWeek = moment(date, "DD/MM/YYYY").format("dddd"); // Get day of the week

                // if (weekOffDays.includes(dayOfWeek)) {
                //   continue; // Skip week off days
                // }
                if (attendanceMap[userId] && attendanceMap[userId].includes(date)) {
                    // User was present on this date
                    continue;
                } else if (leaveMap[userKey] && leaveMap[userKey].includes(date)) {
                    // User was on leave on this date
                    leaveDays++;
                } else if (holidayMap[empcode] && holidayMap[empcode].includes(date)) {
                    holidayDays++;
                } else {
                    // User was absent on this date
                    absentDays++;
                }
            }

            let status = null;
            if (isNewJoiner) {
                status = null;
            } else if (absentDays >= 4) {
                status = "Long Absent";
            } else if (leaveDays >= 4) {
                status = "Long Leave";
            }

            return { status, absentDays, leaveDays, holidayDays };
        };

        // Function to determine the status
        const determineStatus = (
            attendanceStatus,
            noticePeriodStatus,
            livestatus
        ) => {
            if (noticePeriodStatus === "Exit Confirmed") {
                return `Exit Confirmed`;
            } else if (!livestatus && noticePeriodStatus && attendanceStatus) {
                return `Notice Period ${noticePeriodStatus} and ${attendanceStatus}`;
            } else if (noticePeriodStatus) {
                return `Notice Period ${noticePeriodStatus}`;
            } else if (!noticePeriodStatus && attendanceStatus) {
                return attendanceStatus;
            } else if (!noticePeriodStatus && !attendanceStatus && livestatus) {
                return livestatus;
            } else {
                return "No Status";
            }
        };

        // Enrich users with status
        const enrichedLeaveAttendanceUsers = allusers.map((user) => {
            const userId = user._id.toString();
            let weekOffDays = [];
            if (user.boardingLog && user.boardingLog.length > 0) {
                const lastBoardingLog = user.boardingLog[user.boardingLog.length - 1];
                weekOffDays = lastBoardingLog.weekoff || [];
            }
            const userKey = `${user.companyname}_${user.empcode}`;
            const { status, absentDays, leaveDays } = checkStatusForPast3Days(
                userId,
                user.empcode,
                user.companyname,
                weekOffDays,
                user?.doj
            );
            const noticePeriodStatus =
                noticePeriodMap[userKey]?.exitstatus === true
                    ? "Exit Confirmed"
                    : noticePeriodMap[userKey]?.approvedStatus === "true" &&
                        noticePeriodMap[userKey]?.cancelstatus === false &&
                        noticePeriodMap[userKey]?.continuestatus === false
                        ? "Approved"
                        : noticePeriodMap[userKey]?.approvedStatus === "true" &&
                            noticePeriodMap[userKey]?.cancelstatus === true
                            ? "Cancelled"
                            : noticePeriodMap[userKey]?.approvedStatus === "true" &&
                                noticePeriodMap[userKey]?.continuestatus === true
                                ? "Continue"
                                : noticePeriodMap[userKey]?.rejectStatus === "true"
                                    ? "Rejected"
                                    : noticePeriodMap[userKey]?.recheckStatus === "true"
                                        ? "Recheck"
                                        : noticePeriodMap[userKey]?.status || null;
            const livestatus = !status && !noticePeriodStatus ? "Live" : null;
            const profileImage = profileimage
                ? employeeDocumentsMap[userId] || ""
                : null;
            return {
                ...user,
                attendanceStatus: noticePeriodStatus ? true : false,
                noticePeriodStatus: noticePeriodStatus ? true : false,
                livestatus: livestatus ? true : false,
                status: determineStatus(status, noticePeriodStatus, livestatus),
                longAbsentCount: absentDays, // Long absent count
                longLeaveCount: leaveDays, // Long leave count
                profileimage: profileimage ? profileImage : "",
            };
        });

        finalArray = enrichedLeaveAttendanceUsers;
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finalArray) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({
        count: finalArray.length,
        allusers: finalArray,
    });
});

exports.getAllUserstatusAnswerDefine = catchAsyncErrors(async (req, res, next) => {
    let usersstatus;

    try {
        usersstatus = await User.findOne(
            { companyname: req?.body?.employeename },
            {
                status: 1,
                resonablestatus: 1,
                reasonname: 1,
                lastworkday: 1,
                rejoin: 1,
                reasonablestatusremarks: 1,
                department: 1,
                dob: 1,
                contactpersonal: 1,
                processlog: 1,
                boardingLog: 1,
                attendancemode: 1,
                designationlog: 1,
                company: 1,
                reasondate: 1,
                empreason: 1,
                percentage: 1,
                empcode: 1,
                companyname: 1,
                team: 1,
                usernameautogenerate: 1,
                workmode: 1,
                email: 1,
                employeecount: 1,
                systemmode: 1,
                companyemail: 1,
                addremoteworkmode: 1,

                unit: 1,
                branch: 1,
                department: 1,
                username: 1,
                designation: 1,
                team: 1,
                shift: 1,
                reportingto: 1,
                experience: 1,
                doj: 1,
                dot: 1,
                role: 1,
                bankname: 1,
                bankdetails: 1,
                bankbranchname: 1,
                accountholdername: 1,
                accountnumber: 1,
                ifsccode: 1,
                shifttiming: 1,
                shiftgrouping: 1,
                legalname: 1,
                callingname: 1,
                pdoorno: 1,
                pstreet: 1,
                parea: 1,
                plandmark: 1,
                ptaluk: 1,
                ppost: 1,
                ppincode: 1,
                pcountry: 1,
                pstate: 1,
                pcity: 1,
                cdoorno: 1,
                cstreet: 1,
                carea: 1,
                clandmark: 1,
                ctaluk: 1,
                cpost: 1,
                cpincode: 1,
                ccountry: 1,
                cstate: 1,
                ccity: 1,
                reasondate: 1,
                process: 1,
                workstation: 1,
                weekoff: 1,
                originalpassword: 1,
                enquirystatus: 1,
                area: 1,
                enableworkstation: 1,
                wordcheck: 1,
                shiftallot: 1,
                aadhar: 1,
                panno: 1,
                panstatus: 1,
                panrefno: 1,
                firstname: 1,
                lastname: 1,
                gender: 1,
                prefix: 1,

            }
        );
    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }
    return res.status(200).json({ usersstatus });
});

exports.getAllUserClockinAndClockoutStatusWithShiftModeFilterBulkUpdate = catchAsyncErrors(async (req, res, next) => {

    let allLeaveStatus;
    let permission;
    let resultshiftallot = [];
    let graceTime;
    let clockOutHours;
    let lateclockincount;
    let earlyclockoutcount;
    let onclockout;
    let earlyclockin;
    let earlyclockout;
    let lateclockin;
    let afterlateclockin;
    let beforeearlyclockout;
    let finaluser = [];

    const { userDates, shiftmode } = req.body;

    const formattedUserDates = userDates.map((data) => moment(data.formattedDate, "DD/MM/YYYY").format("DD-MM-YYYY"));

    let query = {
        enquirystatus: {
            $nin: ["Enquiry Purpose"],
        },
    }

    try {
        const [users, controlcriteria, depMonthSets, attendances, holidays, leavetype] = await Promise.all([
            User.find(query,
                {
                    company: 1,
                    branch: 1,
                    unit: 1,
                    team: 1,
                    department: 1,
                    doj: 1,
                    empcode: 1,
                    companyname: 1,
                    team: 1,
                    floor: 1,
                    username: 1,
                    designation: 1,
                    weekoff: 1,
                    shiftallot: 1,
                    shifttiming: 1,
                    boardingLog: 1,
                    attendancemode: 1,
                    reasondate: 1,
                    departmentlog: 1,
                    designationlog: 1,
                }
            ),
            ControlCriteria.find(),
            DepartmentMonth.find({}, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 }),
            Attendance.find({
                date: { $in: formattedUserDates },
            }),
            Holiday.find({}, { date: 1, company: 1, applicablefor: 1, unit: 1, team: 1, employee: 1, noofdays: 1 }),
            Leavetype.find({}, { leavetype: 1, code: 1 })
        ])

        const userCds = users.map(user => user.companyname);
        allLeaveStatus = await ApplyLeave.find({ employeename: { $in: userCds } });
        permission = await Permission.find({ employeename: { $in: userCds } }, { employeeid: 1, date: 1, status: 1, applytype: 1, compensationstatus: 1, compensationapplytype: 1, requesthours: 1, shiftmode: 1, });

        // graceTime = controlcriteria[0].gracetime;
        clockOutHours = controlcriteria[0].clockout;
        lateclockincount = controlcriteria[0].lateclockincount;
        earlyclockoutcount = controlcriteria[0].earlyclockoutcount;
        onclockout = controlcriteria[0].onclockout;
        earlyclockin = controlcriteria[0].earlyclockin;
        lateclockin = controlcriteria[0].lateclockin;
        earlyclockout = controlcriteria[0].earlyclockout;
        afterlateclockin = controlcriteria[0].afterlateclockin;
        beforeearlyclockout = controlcriteria[0].afterlateclockin;

        finaluser = users?.flatMap((item, index) => {

            let isEmployeeGrace = controlcriteria[0].todos && controlcriteria[0].todos.find(d => d.company === item.company &&
                d.branch === item.branch && d.unit === item.unit && d.team === item.team &&
                d.employeename === item.companyname
            )

            if (isEmployeeGrace) {
                graceTime = isEmployeeGrace.employeegracetime;
            }
            else {
                graceTime = controlcriteria[0].gracetime;
            }

            item.shiftallot?.map(allot => {
                resultshiftallot.push({ ...allot })
            })

            const filteredMatchingDoubleShiftItem = resultshiftallot?.filter(val => val && val?._doc?.empcode === item?._doc?.empcode && val?._doc?.adjstatus === 'Approved');
            const dojDate = item?._doc?.boardingLog.length > 0 ?
                item?._doc?.boardingLog[0].startdate
                : item?._doc?.doj;

            // Filter out the dates that have matching 'Shift Adjustment' todates
            let removedUserDates = userDates?.filter(date => {
                // Check if there is no matching 'Shift Adjustment' for the current user and formattedDate
                const matchingShiftAdjustmentToDate = filteredMatchingDoubleShiftItem.find(item => item && item?._doc?.todate === date.formattedDate && item?._doc?.adjustmenttype === 'Shift Adjustment');

                // If there is no matching 'Shift Adjustment', keep the date
                return !matchingShiftAdjustmentToDate;
            });

            // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
            let uniqueEntries = new Set();

            // Iterate over removedUserDates and add unique entries to the Set
            userDates?.forEach(date => {
                uniqueEntries.add(JSON.stringify({
                    formattedDate: date.formattedDate,
                    dayName: date.dayName,
                    dayCount: date.dayCount,
                    shiftMode: 'Main Shift',
                    weekNumberInMonth: date.weekNumberInMonth
                }));
            });

            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach(item => {
                const [day, month, year] = item._doc.adjdate?.split('/')
                let newFormattedDate = new Date(`${year}-${month}-${day}`);

                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(JSON.stringify({
                        formattedDate: item._doc.adjdate,
                        dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
                        dayCount: parseInt(moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")),
                        shiftMode: 'Second Shift',
                        weekNumberInMonth: (getWeekNumberInMonth(newFormattedDate) === 1 ? `${getWeekNumberInMonth(newFormattedDate)}st Week` :
                            getWeekNumberInMonth(newFormattedDate) === 2 ? `${getWeekNumberInMonth(newFormattedDate)}nd Week` :
                                getWeekNumberInMonth(newFormattedDate) === 3 ? `${getWeekNumberInMonth(newFormattedDate)}rd Week` :
                                    getWeekNumberInMonth(newFormattedDate) > 3 ? `${getWeekNumberInMonth(newFormattedDate)}th Week` : '')
                    }));
                }
            });

            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries)?.map(entry => JSON.parse(entry));

            function sortUserDates(dates) {
                return dates.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);
            const createdUserDates = sortedCreatedUserDates?.filter(d => {
                const filterData = userDates.some(val => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date) => {
                let filteredRowData = resultshiftallot?.filter((val) => val?._doc?.empcode == item?._doc?.empcode);
                const matchingItem = filteredRowData?.find(item => item && item?._doc?.adjdate == date.formattedDate);
                const matchingItemAllot = filteredRowData?.find(item => item && formatDate(item?._doc?.date) == date.formattedDate);
                const matchingDoubleShiftItem = filteredRowData?.find(item => item && item?._doc?.todate === date.formattedDate);
                const matchingRemovedItem = filteredRowData?.find(item => item?._doc?.removedshiftdate === date.formattedDate);
                const matchingAssignShiftItem = filteredRowData?.find(item => item?._doc?.adjdate === date.formattedDate && item?._doc?.adjstatus === 'Approved' && item?._doc?.adjustmenttype === 'Assign Shift');

                const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                    // return item;
                });

                // Remove duplicate entries with the most recent entry
                const uniqueEntriesDep = {};
                item?._doc?.departmentlog?.forEach(entry => {
                    const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                    const key = entry.startdate;
                    if (!(key in uniqueEntriesDep)) {
                        uniqueEntriesDep[key] = entry;
                    }
                });

                const uniqueDepLog = Object.values(uniqueEntriesDep);
                const [columnDay, columnMonth, columnYear] = date.formattedDate?.split('/');
                const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

                // Find the relevant log entry for the given date     
                const relevantDepLogEntry = uniqueDepLog
                    .filter(log => log.startdate <= finalDate)
                    .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

                // Remove duplicate entries with the most recent entry
                const uniqueEntriesDesig = {};
                item?._doc?.designationlog?.forEach(entry => {
                    const entryDate = new Date(entry.startdate);
                    const key = entry.startdate;
                    if (!(key in uniqueEntriesDesig)) {
                        uniqueEntriesDesig[key] = entry;
                    }
                });

                const uniqueDesigLog = Object.values(uniqueEntriesDesig);

                // Find the relevant log entry for the given date     
                const relevantDesigLogEntry = uniqueDesigLog
                    .filter(log => log.startdate <= finalDate)
                    .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

                const depMonthSet = depMonthSets.filter(d => d.department === (relevantDepLogEntry && relevantDepLogEntry?.department))
                const attendance = attendances.filter(d => d.username === item?._doc?.username)

                // Check if the dayName is Sunday or Monday
                // const isWeekOff = item?._doc?.weekoff?.includes(date.dayName);
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                const row = {
                    id: `${item?._doc?._id.toString()}_${date.formattedDate}_${date.shiftMode}`,
                    userid: item?._doc?._id.toString(),
                    company: item?._doc?.company,
                    branch: item?._doc?.branch,
                    unit: item?._doc?.unit,
                    team: item?._doc?.team,
                    department: (relevantDepLogEntry && relevantDepLogEntry?.department),
                    designation: (relevantDesigLogEntry && relevantDesigLogEntry?.designation),
                    companyname: item?._doc?.companyname,
                    username: item?._doc?.companyname,
                    rowusername: item?._doc?.username,
                    empcode: item?._doc?.empcode,
                    weekoff: item?._doc?.weekoff,
                    boardingLog: item?._doc?.boardingLog,
                    shiftallot: item?._doc?.shiftallot,
                    doj: dojDate,
                    shift: getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                    date: `${date.formattedDate} ${date.dayName} ${date.dayCount}`,
                    rowformattedDate: date.formattedDate,
                    dayName: date.dayName,
                    shiftMode: date.shiftMode,
                    reasondate: item?._doc?.reasondate,
                    clockin: checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        date.shiftMode,
                    ),
                    clockout: checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate,
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        date.shiftMode,
                    ),
                    clockinstatus: checkClockInStatus(
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        graceTime, allLeaveStatus, holidays,
                        checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,), item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname,
                        earlyclockin, lateclockin, afterlateclockin, leavetype, permission,
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    clockoutstatus: checkClockOutStatus(
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem), date.shiftMode,),
                        getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, (relevantDepLogEntry && relevantDepLogEntry?.department), depMonthSet, matchingRemovedItem, matchingAssignShiftItem),
                        clockOutHours, checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        allLeaveStatus, holidays, item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname, onclockout,
                        earlyclockout, beforeearlyclockout,
                        checkGetClockInAutoStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        leavetype, permission, date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    attendanceautostatus: checkAttendanceStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    lateclockincount: lateclockincount,
                    earlyclockoutcount: earlyclockoutcount,
                    weekoffpresentstatus: checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                };

                return row;
            });

            return userRows;

        }).filter(data => data.shiftMode === shiftmode);

    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    if (!finaluser) {
        return next(new ErrorHandler("Users not found", 400));
    }

    return res.status(200).json({ finaluser });
});

exports.getSingleRemoteWorkMode = catchAsyncErrors(async (req, res, next) => {
    const id = req.query.employeeid;

    let data = await RemoteWorkMode.findOne({ employeeid: id });

    if (!data) {
        return res.status(200).json({
            exist: false,
            addremoteworkmode: [],
        });
    } else {

        return res.status(200).json({
            exist: true,
            addremoteworkmode: data?.addremoteworkmode,
        });
    }
});

exports.updateAnyLogValuesOfRemoteWorkmode = catchAsyncErrors(async (req, res, next) => {
    const { logid, logname } = req.query;
    // const updateFields = req.body;
    const updateFields = JSON.parse(req.body[logname]);
    // console.log(updateFields, 'updateFields')

    try {
        const query = {};
        query[`${logname}._id`] = logid;

        console.log("logid", logid);
        console.log("logname", logname);
        if (req.files) {
            if (req.files.wfhsetupphoto) {
                updateFields.wfhsetupphoto = req.files.wfhsetupphoto.map(file => ({
                    filename: file.filename,
                    name: file.originalname,
                    path: file.path,
                    mimetype: file.mimetype
                }));
            }

            if (req.files.internetssidphoto) {
                updateFields.internetssidphoto = req.files.internetssidphoto.map(file => ({
                    filename: file.filename,
                    name: file.originalname,
                    path: file.path,
                    mimetype: file.mimetype
                }));
            }
        }
        console.log(updateFields, 'updateFields')
        const updateObj = { $set: {} };
        for (const key in updateFields) {
            updateObj.$set[`${logname}.$.${key}`] = updateFields[key];
        }

        const uploaddata = await RemoteWorkMode.findOneAndUpdate(query, updateObj, {
            new: true,
        });

        if (uploaddata) {
            return res
                .status(200)
                .json({ message: "Updated successfully", succcess: true });
        } else {
            return next(new ErrorHandler("Something went wrong", 500));

        }
    } catch (err) {
        console.log(err, 'err')
        return next(new ErrorHandler("Internal Server Error", 500));
    }
});




// exports.updateRemoteWorkmode = catchAsyncErrors(async (req, res, next) => {
//     const { employeeid } = req.params;
//     const { addremoteworkmode } = req.body;

//     try {
//         // Ensure employeeid is treated as a string
//         const employeeIdString = employeeid.toString();

//         // Check if employee already exists
//         const existingData = await RemoteWorkMode.findOne({ employeeid: employeeIdString });

//         if (existingData) {
//             // Update the existing record
//             existingData.addremoteworkmode = addremoteworkmode;
//             await existingData.save();
//             return res.status(200).json({ message: "Updated successfully", success: true });
//         } else if (addremoteworkmode && addremoteworkmode.length > 0) {
//             // If employee doesn't exist and addremoteworkmode is not empty, create a new record
//             const newRemoteWorkMode = new RemoteWorkMode({
//                 employeeid: employeeIdString, // Ensure employeeid is stored as a string
//                 addremoteworkmode
//             });

//             await newRemoteWorkMode.save();
//             return res.status(201).json({ message: "Created successfully", success: true });
//         }

//         return next(new ErrorHandler("No data provided for update or creation", 400));
//     } catch (err) {
//         return next(new ErrorHandler("Internal Server Error", 500));
//     }
// });


exports.updateRemoteWorkmode = catchAsyncErrors(async (req, res, next) => {
    const { employeeid } = req.params;
    const { addremoteworkmode, userDataUpdate, oldworkModeData } = req.body;
    // console.log(oldworkModeData)
    try {

        const employeeIdString = employeeid.toString();
        const parsedWorkMode = JSON.parse(addremoteworkmode); // Ensure it's an object
        const parsedUserUpdateStatus = JSON.parse(userDataUpdate); // Ensure it's an object
        const parsedoldworkModeData = oldworkModeData ? JSON.parse(oldworkModeData) : []; // Ensure it's an object
        // console.log(parsedWorkMode , 'parsedWorkMode')
        // Extract file paths from Multer
        const setupPhotos = (req.files?.wfhsetupphoto || []).map(file => ({
            filename: file.filename,
            name: file.originalname,
            path: file.path,
            mimetype: file.mimetype,
        }));
        const ssidPhotos = (req.files?.internetssidphoto || []).map(file => ({
            filename: file.filename,
            name: file.originalname,
            path: file.path,
            mimetype: file.mimetype,
        }));
        const UpdatedRemote = {
            ...parsedWorkMode[0],               // flatten the form data
            wfhsetupphoto: setupPhotos?.length > 0 ? setupPhotos : parsedoldworkModeData?.length > 0 ? parsedoldworkModeData[parsedoldworkModeData?.length - 1].wfhsetupphoto : [],     // add setup photo file details
            internetssidphoto: ssidPhotos?.length > 0 ? ssidPhotos : parsedoldworkModeData?.length > 0 ? parsedoldworkModeData[parsedoldworkModeData?.length - 1].internetssidphoto : [],   // add ssid photo file details
        };

        console.log(UpdatedRemote, "parsed")

        let existingData = await RemoteWorkMode.findOne({ employeeid: employeeIdString });
        let existingUser = await User.findOne({ _id: new mongoose.Types.ObjectId(employeeIdString) });
        if (existingUser) {
            existingUser.approvedremotestatus = parsedUserUpdateStatus?.approvedremotestatus;
            existingUser.workstationofficestatus = parsedUserUpdateStatus?.workstationofficestatus;
            existingUser.workstationinput = parsedUserUpdateStatus?.workstationinput;
            existingUser.addremoteworkmode = [UpdatedRemote];

            await existingUser.save();
        }
        if (existingData) {
            existingData.addremoteworkmode = [...parsedoldworkModeData, UpdatedRemote];
            await existingData.save();
            return res.status(200).json({ message: "Updated successfully", success: true });
        } else {
            const newRemoteWorkMode = new RemoteWorkMode({
                employeeid: employeeIdString,
                addremoteworkmode: [UpdatedRemote]
            });
            await newRemoteWorkMode.save();
            return res.status(201).json({ message: "Created successfully", success: true });
        }

    } catch (err) {
        console.error(err, 'Error');
        return next(new ErrorHandler("Failed to process data", 500));
    }
});



exports.getCurrentServerTime = catchAsyncErrors(async (req, res, next) => {
    try {
        const currentNewDate = new Date();
        const currenttoLocaleTimeString = new Date().toLocaleTimeString();
        const formatted = moment(currentNewDate).format("DD-MM-YYYY HH:mm:ss A");
        return res.status(200).json({
            success: true,
            formatted,
            currentNewDate,
            currenttoLocaleTimeString
        });
    } catch (err) {
        return next(new ErrorHandler("Internal Server Error", 500));
    }
});

const checkRocketChatHealth = async () => {
    try {

        const rocketchatCredentials = await ChatConfiguration.findOne()
            .sort({ createdAt: -1 })
            .select("domainurl username password");
        if (!rocketchatCredentials) {
            return false;
        }

        const response = await axios.get(`${rocketchatCredentials?.domainurl}/api/v1/info`, {
            timeout: 3000
        });
        return response.status === 200;
    } catch (error) {
        return false;
    }
};

// Calculate accuracy
const calculateAccuracy = (finalData, userid, rowdate) => {
    const accuracyRecord = finalData?.find((d) => userid.includes(d.loginid) && d.date === rowdate);
    if (accuracyRecord) {
        return accuracyRecord.accuracy;
    }
    return 0;
};

// Calculate totalfield
const calculateTotalField = (finalData, userid, rowdate) => {
    const accuracyRecord = finalData?.find((d) => userid.includes(d.loginid) && d.date === rowdate);
    if (accuracyRecord) {
        return accuracyRecord.totalfield;
    }
    return 0;
};

const calculateAutoError = (accuracy, totalfield) => {
    return Math.round(totalfield * (1 - (accuracy / 100)));
}

// overall production review for singledate
exports.dayPointsFilterForSingleDateWithAttendance = catchAsyncErrors(async (req, res, next) => {
    let productionupload, graceTime;

    try {
        const { less, greater, compare, betweenfrom, betweento, empnames, userDates, pagename } = req.body;

        let userQuery = {
            enquirystatus: {
                $nin: ['Enquiry Purpose'],
            },
            companyname: { $in: empnames },
        };

        const formattedUserDates = userDates.map((data) => moment(data.formattedDate, "DD/MM/YYYY").format("DD-MM-YYYY"));
        const formattedUserDatesForError = userDates.map((data) => moment(data.formattedDate, "DD/MM/YYYY").format("YYYY-MM-DD"));

        const [salSlabs, manageshortagemasters, revenueAmount, acPointCal, departments, users, depMonthSets, controlcriteria, holidays, leavetype, daypointsupload, daypointsuploadtemp] = await Promise.all([
            Salaryslab.find({}, { company: 1, branch: 1, salarycode: 1, basic: 1, hra: 1, salaryslablimited: 1, medicalallowance: 1, conveyance: 1, productionallowance: 1, otherallowance: 1 }).lean(),
            ShortageMaster.find({}, { department: 1, from: 1, to: 1, amount: 1 }).lean(),
            RevenueAmount.find({}, { branch: 1, company: 1, processcode: 1, amount: 1 }).lean(),
            AcPointVal.find({}, { branch: 1, company: 1, department: 1, dividevalue: 1, multiplevalue: 1 }).lean(),
            Department.find({}, { deptname: 1, prod: 1 }).lean(),
            User.find(userQuery, {
                company: 1, branch: 1, unit: 1, team: 1, department: 1, doj: 1, empcode: 1, companyname: 1, team: 1, floor: 1,
                username: 1, designation: 1, weekoff: 1, shiftallot: 1, shifttiming: 1, boardingLog: 1, attendancemode: 1, reasondate: 1, departmentlog: 1, designationlog: 1,
            }),
            DepartmentMonth.find({}, { department: 1, year: 1, month: 1, monthname: 1, fromdate: 1, todate: 1, totaldays: 1 }).lean(),
            ControlCriteria.find({}, { todos: 1, gracetime: 1, clockout: 1, onclockout: 1, earlyclockin: 1, lateclockin: 1, earlyclockout: 1, afterlateclockin: 1, beforeearlyclockout: 1 }).lean(),
            Holiday.find({}, { date: 1, company: 1, applicablefor: 1, unit: 1, team: 1, employee: 1, noofdays: 1 }).lean(),
            Leavetype.find({}, { leavetype: 1, code: 1 }).lean(),
            DayPointsUpload.find({ date: { $in: formattedUserDatesForError }, }, { uploaddata: 1 }).lean(),
            DayPointsUploadTemp.find({ date: { $in: formattedUserDatesForError }, }, { uploaddata: 1 }).lean(),
        ]);

        const userIds = users.map(user => user._id);
        const userCds = users.map(user => user.companyname);

        const [attendance, allLeaveStatus, permission, penaltyclienterror] = await Promise.all([
            Attendance.find({ userid: { $in: userIds }, date: { $in: formattedUserDates }, }, { date: 1, userid: 1, clockintime: 1, clockouttime: 1, shiftmode: 1, attendancestatus: 1, autoclockout: 1, weekoffpresentstatus: 1, }).lean(),
            ApplyLeave.find({ employeename: { $in: userCds } }, { employeeid: 1, leavetype: 1, usershifts: 1, status: 1, noofshift: 1 }).lean(),
            Permission.find({ employeename: { $in: userCds } }, { employeeid: 1, date: 1, status: 1, applytype: 1, compensationstatus: 1, compensationapplytype: 1, requesthours: 1, shiftmode: 1, }).lean(),
            PenaltyClientError.find({ employeename: { $in: userCds }, date: { $in: formattedUserDatesForError }, errorstatus: { $eq: "Approved" }, history: { $elemMatch: { mode: "Percentage", status: "Approved" } }, }, { date: 1, employeeid: 1, employeename: 1, clientamount: 1, amount: 1, }).lean(),
        ]);

        const control = controlcriteria[0] || {};
        const {
            clockout: clockOutHours,
            onclockout,
            earlyclockin,
            earlyclockout,
            lateclockin,
            afterlateclockin,
            beforeearlyclockout,
            gracetime,
            todos,
        } = control;

        const filtereddaypointsupload = daypointsupload.flatMap((data) => data.uploaddata);
        const filtereddaypointsuploadtemp = daypointsuploadtemp.flatMap((data) => data.uploaddata);

        // Aggregate clientamount by employeeid
        const aggregatedData = penaltyclienterror.reduce((acc, item) => {
            const existingEmployee = acc.find((entry) => entry.date === item.date && entry.employeeid === item.employeeid);

            if (existingEmployee) {
                existingEmployee.clientamount += item.clientamount;
                existingEmployee.amount += item.amount;
            } else {
                acc.push({
                    date: moment(item.date, "YYYY-MM-DD").format("DD/MM/YYYY"),
                    employeeid: item.employeeid,
                    employeename: item.employeename,
                    clientamount: item.clientamount,
                    amount: item.amount,
                });
            }
            return acc;
        }, []);

        let accuracydata = filtereddaypointsupload.flatMap((daypoint) => {
            // Find all matching approved penalty client errors
            const matchedItems = filtereddaypointsuploadtemp.filter((daypointtemp) =>
                daypoint.empcode === daypointtemp.empcode && daypoint.date === daypointtemp.date
            );

            // Map each matched item to include the client amount
            return matchedItems.map((matchedItem) => ({
                ...daypoint,
                temppoint: matchedItem?.point,
                tempprocesscode: matchedItem?.processcode,
                tempavgpoint: matchedItem?.avgpoint,
            }));
        });

        const userLoginIds = accuracydata.flatMap(id => id.users);
        const accuracy = await Achievedaccuracyindividualuploaddatas.find({ date: { $in: formattedUserDatesForError }, loginid: { $in: userLoginIds }, accuracy: { $ne: 'NA' } }, { date: 1, project: 1, vendor: 1, loginid: 1, accuracy: 1, totalfield: 1 }).lean();

        // Aggregate clientamount by employeeid
        const aggregatedDataAccuracy = accuracy.reduce((acc, item) => {
            const existingEmployee = acc.find((entry) => entry.date === item.date && entry.loginid === item.loginid);

            const itemAccuracy = parseFloat(item.accuracy) || 0;
            const itemTotalField = parseFloat(item.totalfield) || 0;

            if (existingEmployee) {
                existingEmployee.accuracy += itemAccuracy;
                existingEmployee.count += 1;
                existingEmployee.totalfield += itemTotalField;
            } else {
                acc.push({
                    date: item.date,
                    project: item.project,
                    loginid: item.loginid,
                    vendor: item.vendor,
                    accuracy: itemAccuracy,
                    totalfield: itemTotalField,
                    count: 1
                });
            }
            return acc;
        }, []);

        // Calculate the average accuracy for each loginid
        const finalData = aggregatedDataAccuracy.map(entry => ({
            ...entry,
            accuracy: Number((entry.accuracy / entry.count).toFixed(2)),
        }));

        let answer = accuracydata.flatMap(entry => ({
            ...entry,
            accuracy: calculateAccuracy(finalData, entry.users, entry.date),
            totalfield: calculateTotalField(finalData, entry.users, entry.date),
            autoerrorcalculation: calculateAutoError(calculateAccuracy(finalData, entry.users, entry.date), calculateTotalField(finalData, entry.users, entry.date))
        }));

        let finaluser = users.flatMap((item) => {

            let isEmployeeGrace = todos && todos.find(d => d.company === item.company &&
                d.branch === item.branch && d.unit === item.unit && d.team === item.team &&
                d.employeename === item.companyname
            )

            if (isEmployeeGrace) {
                graceTime = isEmployeeGrace.employeegracetime;
            }
            else {
                graceTime = gracetime;
            }

            const filteredMatchingDoubleShiftItem = item.shiftallot?.filter(val => val && val?._doc?.empcode === item?._doc?.empcode && val?._doc?.adjstatus === 'Approved');
            const dojDate = item?._doc?.boardingLog.length > 0 ?
                item?._doc?.boardingLog[0].startdate
                : item?._doc?.doj;

            // Create a Set to store unique entries based on formattedDate, dayName, dayCount, and shiftMode
            let uniqueEntries = new Set();

            // Iterate over removedUserDates and add unique entries to the Set
            userDates?.forEach(date => {
                uniqueEntries.add(JSON.stringify({
                    ...date,
                }));
            });

            // Iterate over filteredMatchingDoubleShiftItem and add unique entries to the Set
            filteredMatchingDoubleShiftItem.forEach(item => {
                const [day, month, year] = item._doc.adjdate?.split('/')
                let newFormattedDate = new Date(`${year}-${month}-${day}`);

                if (item._doc.adjustmenttype === 'Shift Adjustment' || item._doc.adjustmenttype === 'Add On Shift' || item._doc.adjustmenttype === 'Shift Weekoff Swap') {
                    uniqueEntries.add(JSON.stringify({
                        formattedDate: item._doc.adjdate,
                        dayName: moment(item._doc.adjdate, "DD/MM/YYYY").format("dddd"),
                        dayCount: parseInt(moment(item._doc.adjdate, "DD/MM/YYYY").format("DD")),
                        shiftMode: 'Second Shift',
                        weekNumberInMonth: (getWeekNumberInMonth(newFormattedDate) === 1 ? `${getWeekNumberInMonth(newFormattedDate)}st Week` :
                            getWeekNumberInMonth(newFormattedDate) === 2 ? `${getWeekNumberInMonth(newFormattedDate)}nd Week` :
                                getWeekNumberInMonth(newFormattedDate) === 3 ? `${getWeekNumberInMonth(newFormattedDate)}rd Week` :
                                    getWeekNumberInMonth(newFormattedDate) > 3 ? `${getWeekNumberInMonth(newFormattedDate)}th Week` : '')
                    }));
                }
            });

            // Convert Set back to an array of objects
            let createdUserDatesUnique = Array.from(uniqueEntries)?.map(entry => JSON.parse(entry));

            function sortUserDates(dates) {
                return dates.sort((a, b) => {
                    if (a.formattedDate === b.formattedDate) {
                        // If dates are the same, sort by shift mode
                        if (a.shiftMode < b.shiftMode) return -1;
                        if (a.shiftMode > b.shiftMode) return 1;
                        return 0;
                    } else {
                        // Otherwise, sort by date
                        const dateA = new Date(a.formattedDate.split('/').reverse().join('/'));
                        const dateB = new Date(b.formattedDate.split('/').reverse().join('/'));
                        return dateA - dateB;
                    }
                });
            }

            // Sort the array
            const sortedCreatedUserDates = sortUserDates(createdUserDatesUnique);
            const createdUserDates = sortedCreatedUserDates?.filter(d => {
                const filterData = userDates.some(val => val.formattedDate === d.formattedDate);
                if (filterData) {
                    return d;
                }
            });

            // Map each user date to a row
            const userRows = createdUserDates?.map((date) => {
                let filteredRowData = item.shiftallot?.filter((val) => val?._doc?.empcode == item?._doc?.empcode);
                const matchingItem = filteredRowData?.find(item => item && item?._doc?.adjdate == date.formattedDate);
                const matchingItemAllot = filteredRowData?.find(item => item && formatDate(item?._doc?.date) == date.formattedDate);
                const matchingDoubleShiftItem = filteredRowData?.find(item => item && item?._doc?.todate === date.formattedDate);
                const matchingRemovedItem = filteredRowData?.find(item => item?._doc?.removedshiftdate === date.formattedDate);
                const matchingAssignShiftItem = filteredRowData?.find(item => item?._doc?.adjdate === date.formattedDate && item?._doc?.adjstatus === 'Approved' && item?._doc?.adjustmenttype === 'Assign Shift');

                const filterBoardingLog = item?._doc?.boardingLog && item?._doc?.boardingLog?.filter((item) => {
                    return item.logcreation === "user" || item.logcreation === "shift";
                });

                // Remove duplicate entries with the most recent entry
                const uniqueEntriesDep = {};
                item?._doc?.departmentlog?.forEach(entry => {
                    const entryDate = new Date(entry.startdate); // Parse the startdate into a date object
                    const key = entry.startdate;
                    if (!(key in uniqueEntriesDep)) {
                        uniqueEntriesDep[key] = entry;
                    }
                });

                const uniqueDepLog = Object.values(uniqueEntriesDep);
                const [columnDay, columnMonth, columnYear] = date.formattedDate?.split('/');
                const finalDate = `${columnYear}-${columnMonth}-${columnDay}`;

                // Find the relevant log entry for the given date     
                const relevantDepLogEntry = uniqueDepLog
                    .filter(log => log.startdate <= finalDate)
                    .sort((a, b) => new Date(b.startdate) - new Date(a.startdate))[0];

                let findUserDepartment = (relevantDepLogEntry && relevantDepLogEntry?.department);

                const depMonthSet = depMonthSets.filter(d => d.department === findUserDepartment);

                // Check if the dayName is Sunday or Monday
                const isWeekOff = getWeekOffDay(date, filterBoardingLog, findUserDepartment, depMonthSet) === "Week Off" ? true : false;
                const isWeekOffWithAdjustment = isWeekOff && matchingItem;
                const isWeekOffWithManual = isWeekOff && matchingItemAllot;

                const findPointsData = answer.find(d => item.empcode === d?.empcode &&
                    item.companyname === d?.name &&
                    d.date === finalDate);

                const prodTrue = departments.find(data => data.deptname === findUserDepartment)?.prod;
                const clientErrorData = aggregatedData.find(d => item.empcode === d?.employeeid &&
                    item.companyname === d?.employeename &&
                    d.date === date.formattedDate);

                const clientErrorCount = penaltyclienterror.filter(d => item.empcode === d?.employeeid &&
                    item.companyname === d?.employeename &&
                    d.date === moment(date.formattedDate, 'DD/MM/YYYY').format('YYYY-MM-DD'));

                let findexpval = Number(findPointsData?.exper) < 1 ? '00' : Number(findPointsData?.exper) <= 9 ? `0${Number(findPointsData?.exper)}` : findPointsData?.exper;
                let processcodeexpvalue = `${findPointsData?.processcode}${findexpval}`;
                //findsalary from salaryslab
                let findSalDetails = salSlabs.find((d) => d.company === findPointsData?.companyname && d.branch === findPointsData?.branch && d.salarycode === processcodeexpvalue);
                //shortageamount from shortage master
                let findShortage = manageshortagemasters.find((d) => d.department === findUserDepartment && Number(findPointsData?.exper) >= Number(d.from) && Number(findPointsData?.exper) <= Number(d.to));
                //revenue amount from revenue  master
                let findRevenueAllow = revenueAmount.find((d) => d.company === findPointsData?.companyname && d.branch === findPointsData?.branch && d.processcode === processcodeexpvalue);
                let findAcPointVal = acPointCal.find((d) => d.company === findPointsData?.companyname && d.branch === findPointsData?.branch && d.department === findUserDepartment);

                // GROSS VALUE
                let grossValue = findSalDetails
                    ? Number(findSalDetails.basic) + Number(findSalDetails.hra) + Number(findSalDetails.conveyance) + Number(findSalDetails.medicalallowance) + Number(findSalDetails.productionallowance) + Number(findSalDetails.otherallowance)
                    : 0;

                let egvalue = Number(grossValue) + (findShortage ? Number(findShortage.amount) : 0);
                let hfvalue = egvalue - (findRevenueAllow ? Number(findRevenueAllow.amount) : 0);
                let i60value = Number(hfvalue) / (findAcPointVal && Number(findAcPointVal.multiplevalue));
                let j85value = (i60value * (findAcPointVal && Number(findAcPointVal.dividevalue))) / 27;

                const findShift = getShiftForDate(date, matchingItem, matchingItemAllot, isWeekOffWithAdjustment, isWeekOffWithManual, filterBoardingLog, isWeekOff, matchingDoubleShiftItem, findUserDepartment, depMonthSet, matchingRemovedItem, matchingAssignShiftItem);
                const row = {
                    _id: `${item?._doc?._id.toString()}_${date.formattedDate}_${date.shiftMode}`,
                    companyname: item?._doc?.company,
                    branch: item?._doc?.branch,
                    unit: item?._doc?.unit,
                    team: item?._doc?.team,
                    empcode: item?._doc?.empcode,
                    name: item?._doc?.companyname,
                    department: findUserDepartment,
                    doj: dojDate,
                    shift: findShift,
                    rowformattedDate: date.formattedDate,
                    shiftmode: date.shiftMode,
                    reasondate: item?._doc?.reasondate,
                    clockin: checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, findShift, date.shiftMode,),
                    clockout: checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, findShift, date.shiftMode,),
                    clockinstatus: checkClockInStatus(
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, findShift, date.shiftMode,),
                        findShift, graceTime, allLeaveStatus, holidays,
                        checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,), item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname,
                        earlyclockin, lateclockin, afterlateclockin, leavetype, permission,
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, findShift, date.shiftMode,),
                        date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    clockoutstatus: checkClockOutStatus(
                        checkGetClockOutTime(attendance, item?._doc?._id.toString(), date.formattedDate, findShift, date.shiftMode,),
                        checkGetClockInTime(attendance, item?._doc?._id.toString(), date.formattedDate, findShift, date.shiftMode,),
                        findShift, clockOutHours, checkGetClockInDate(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        allLeaveStatus, holidays, item?._doc.branch, item?._doc?.empcode, item?._doc.company, date.formattedDate, item?._doc.unit, item?._doc.team, item?._doc.companyname, onclockout,
                        earlyclockout, beforeearlyclockout,
                        checkGetClockInAutoStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                        leavetype, permission, date.shiftMode, checkWeekOffPresentStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    ),
                    attendanceautostatus: checkAttendanceStatus(attendance, item?._doc?._id.toString(), date.formattedDate, date.shiftMode,),
                    point: findPointsData ? (findPointsData?.weekoff ? ((findPointsData?.weekoff === '' || findPointsData?.weekoff === undefined) ? 0 : findPointsData?.point) : findPointsData?.point) : 0,
                    temppoint: findPointsData ? (findPointsData?.weekoff ? ((findPointsData?.weekoff === '' || findPointsData?.weekoff === undefined) ? 0 : findPointsData?.temppoint) : findPointsData?.temppoint) : 0,
                    prod: prodTrue,
                    date: date.formattedDate,
                    exper: findPointsData ? (findPointsData?.weekoff ? ((findPointsData?.weekoff === '' || findPointsData?.weekoff === undefined) ? 0 : findPointsData?.exper) : findPointsData?.exper) : 0,
                    target: findPointsData ? (findPointsData?.weekoff ? ((findPointsData?.weekoff === 'Week Off' || findPointsData?.weekoff === 'Not Allotted' || findPointsData?.weekoff === 'Not Allot' || findPointsData?.weekoff === '' || findPointsData?.weekoff === undefined) ? 0 : findPointsData?.target) : findPointsData?.target) : 0,
                    avgpoint: findPointsData ? (findPointsData?.weekoff ? ((findPointsData?.weekoff === '' || findPointsData?.weekoff === undefined) ? 0 : findPointsData?.avgpoint) : findPointsData?.avgpoint) : 0,
                    tempavgpoint: findPointsData ? (findPointsData?.weekoff ? ((findPointsData?.weekoff === '' || findPointsData?.weekoff === undefined) ? 0 : findPointsData?.tempavgpoint) : findPointsData?.tempavgpoint) : 0,
                    daypoint: findPointsData ? (findPointsData?.weekoff ? ((findPointsData?.weekoff === 'Week Off' || findPointsData?.weekoff === 'Not Allotted' || findPointsData?.weekoff === 'Not Allot' || findPointsData?.weekoff === '' || findPointsData?.weekoff === undefined) ? 0 : Number(j85value)) : Number(j85value)) : 0,
                    clienterrorcount: clientErrorCount.length,
                    clientamount: clientErrorData ? clientErrorData.clientamount?.toFixed(2) : 0.00,
                    waiveramount: clientErrorData ? clientErrorData.amount?.toFixed(2) : 0.00,
                    accuracy: findPointsData ? (findPointsData?.weekoff ? ((findPointsData?.weekoff === '' || findPointsData?.weekoff === undefined) ? '0 %' :
                        findPointsData.accuracy) : findPointsData.accuracy) : 0,
                    totalfield: findPointsData ? (findPointsData?.weekoff ? ((findPointsData?.weekoff === '' || findPointsData?.weekoff === undefined) ? 0 : findPointsData?.totalfield) : findPointsData?.totalfield) : 0,
                    autoerrorcalculation: findPointsData ? (findPointsData?.weekoff ? ((findPointsData?.weekoff === '' || findPointsData?.weekoff === undefined) ? 0 : findPointsData?.autoerrorcalculation) : findPointsData?.autoerrorcalculation) : 0,
                };
                return row;
            });

            return userRows;
        });

        if (pagename === 'AttOverallReviewInd') {
            productionupload = finaluser.filter((item) => item.prod === true);
        }
        else {
            if (compare == 'Below Minimum Points') {
                productionupload = finaluser.filter((item) => Number(item.daypoint) > Number(item.point) && item.prod === true);
            } else if (compare == 'Below Target Points') {
                productionupload = finaluser.filter((item) => Number(item.target) > Number(item.point) && item.prod === true);
            } else if (compare == 'Less than') {
                productionupload = finaluser.filter((item) => Number(item.avgpoint) < Number(less) && item.prod === true);
            } else if (compare == 'Greater than') {
                productionupload = finaluser.filter((item) => Number(item.avgpoint) > Number(greater) && item.prod === true);
            } else if (compare == 'Between') {
                productionupload = finaluser.filter((item) => Number(item.avgpoint) >= Number(betweenfrom) && Number(item.avgpoint) <= Number(betweento) && item.prod === true);
            } else {
                productionupload = finaluser.filter((item) => item.prod === true);
            }
            if (compare == 'Below Minimum Points') {
                productionupload = finaluser.filter((item) => Number(item.daypoint) > Number(item.temppoint) && item.prod === true);
            } else if (compare == 'Below Target Points') {
                productionupload = finaluser.filter((item) => Number(item.target) > Number(item.temppoint) && item.prod === true);
            } else if (compare == 'Less than') {
                productionupload = finaluser.filter((item) => Number(item.tempavgpoint) < Number(less) && item.prod === true);
            } else if (compare == 'Greater than') {
                productionupload = finaluser.filter((item) => Number(item.tempavgpoint) > Number(greater) && item.prod === true);
            } else if (compare == 'Between') {
                productionupload = finaluser.filter((item) => Number(item.tempavgpoint) >= Number(betweenfrom) && Number(item.tempavgpoint) <= Number(betweento) && item.prod === true);
            } else {
                productionupload = finaluser.filter((item) => item.prod === true);
            }
        }
    } catch (err) {
        console.log(err, 'err')
        return next(new ErrorHandler('Records not found!', 404));
    }
    if (!productionupload) {
        return next(new ErrorHandler('Day Points Upload not found!', 404));
    }
    return res.status(200).json(productionupload);
});

exports.getAllEmployeesForAttendanceFilterForAccessbranchWiseList = catchAsyncErrors(async (req, res, next) => {
    let users;
    const { assignbranch } = req.body;
    try {

        const branchFilter = assignbranch.map(branchObj => ({
            company: branchObj.company,
            branch: branchObj.branch,
            unit: branchObj.unit
        }));

        const filterQuery = {
            $or: branchFilter,
            enquirystatus: {
                $nin: ["Enquiry Purpose"],
            },
        };

        // Run the query
        users = await User.find(filterQuery, {
            company: 1,
            branch: 1,
            unit: 1,
            team: 1,
            department: 1,
            doj: 1,
            empcode: 1,
            companyname: 1,
            floor: 1,
            username: 1,
            designation: 1,
            weekoff: 1,
            shiftallot: 1,
            shifttiming: 1,
            boardingLog: 1,
            attendancemode: 1,
            reasondate: 1,
            departmentlog: 1,
        });


    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    // Check if users were found
    if (!users) {
        return next(new ErrorHandler("Users not found", 400));
    }

    // Return found users
    return res.status(200).json({ users });
});

exports.getAllShiftToUserOverAllBulkDelete = catchAsyncErrors(
    async (req, res, next) => {
        let teams,
            result,

            noticeperiodapply,
            minimumpoints,
            loan,
            myverification,
            draft,
            user,
            count;

        let id = req.body.id;
        try {
            usershift = await ShiftGrouping.find();

            const usershifttype = usershift?.filter((data) =>
                id?.includes(data._id?.toString())
            );

            [
                user,
            ] = await Promise.all([
                User.find(),
            ]);


            const usershiftType = usershifttype
                .filter((answers) =>
                    user.some(
                        (sub) =>
                            answers.shift?.includes(sub.shifttiming)
                    )
                )
                ?.map((data) => data._id?.toString());

            const usershiftBordinglogType = usershifttype
                .filter((answers) =>
                    user.some(
                        (sub) =>
                            sub.boardingLog?.some((item) => answers.shift?.includes(item?.shifttiming))
                    )
                )
                ?.map((data) => data._id?.toString());

            const usershiftshiftallotType = usershifttype
                .filter((answers) =>
                    user.some(
                        (sub) =>
                            sub.shiftallot?.some((item) => answers.shift?.includes(item?.shifttiming))
                    )
                )
                ?.map((data) => data._id?.toString());


            const usershiftBordinglogTodoType = usershifttype
                .filter((answers) =>
                    user.some((sub) =>
                        sub.boardingLog?.some((item) =>
                            item?.todo?.some((todoItem) =>
                                answers.shift?.includes(todoItem?.shifttiming)
                            )
                        )
                    )
                )
                ?.map((data) => data._id?.toString());



            const duplicateId = [
                ...usershiftType,
                ...usershiftBordinglogType,
                ...usershiftshiftallotType,
                ...usershiftBordinglogTodoType,
            ];
            result = id?.filter((data) => !duplicateId?.includes(data));

            count = id?.filter((data) => !duplicateId?.includes(data))?.length;

        } catch (err) {
            return next(
                new ErrorHandler("Recors Not Found", 500)
            );
        }

        return res.status(200).json({
            count: count,
            result,
        });
    }
);

exports.dynamicQueryUserControllerSort = async (req, res, next) => {
    let totalProjects, result, totalProjectsAllData, totalPages, currentPage;

    const { page, pageSize, aggregationPipeline, assignbranch, allFilters, logicOperator, searchQuery } = req.body;

    try {
        let query = {};

        const conditions = [];

        // Advanced search filter
        if (allFilters && allFilters.length > 0) {
            allFilters.forEach(filter => {
                if (filter.column && filter.condition && (filter.value || ["Blank", "Not Blank"].includes(filter.condition))) {
                    conditions.push(createFilterCondition(filter.column, filter.condition, filter.value));
                }
            });
        }

        if (searchQuery && searchQuery !== undefined) {
            const searchTermsArray = searchQuery.split(" ");
            const regexTerms = searchTermsArray.map((term) => new RegExp(term, "i"));

            const orConditions = regexTerms.map((regex) => ({
                $or: [
                    { empcode: regex },
                    { categoryname: regex },
                    { department: regex },
                    { branch: regex },
                    { unit: regex },
                    { team: regex },
                    { designation: regex },
                    { wfhcount: regex },
                    { wfhstatus: regex },
                    { count: regex },
                    { smode: regex },
                    { mode: regex },
                ],
            }));

            query = {
                $and: [
                    query,
                    ...orConditions,
                ],
            };
        }

        // Apply logicOperator to combine conditions
        if (conditions.length > 0) {
            if (logicOperator === "AND") {
                query.$and = conditions;
            } else if (logicOperator === "OR") {
                query.$or = conditions;
            }
        }

        const branchFilters = assignbranch?.map(branchObj => ({
            company: branchObj.company,
            branch: branchObj.branch,
            unit: branchObj.unit,
        }));

        const combinedFilter = {
            $and: [
                query,
                { $or: branchFilters },
            ],
        };

        // Add $match stage to the aggregation pipeline
        const matchStage = { $match: combinedFilter };
        const updatedAggregationPipeline = [matchStage, ...aggregationPipeline];

        // Count total documents
        const countPipeline = [...updatedAggregationPipeline, { $count: "total" }];
        const countResult = await User.aggregate(countPipeline);
        totalProjects = countResult.length > 0 ? countResult[0].total : 0;

        // Fetch paginated results
        const paginationPipeline = [
            ...updatedAggregationPipeline,
            { $skip: (page - 1) * pageSize },
            { $limit: parseInt(pageSize) },
        ];
        result = await User.aggregate(paginationPipeline);

        // Fetch all data (without pagination)
        totalProjectsAllData = await User.aggregate(aggregationPipeline);

        totalPages = Math.ceil(totalProjects / pageSize);
        currentPage = page;

    } catch (err) {
        return next(new ErrorHandler("Records not found!", 404));
    }

    return res.status(200).json({
        totalProjects,
        result,
        totalProjectsAllData,
        currentPage,
        totalPages,
    });
};


function createFilterCondition(column, condition, value) {
    switch (condition) {
        case "Contains":
            return { [column]: new RegExp(value, 'i') };
        case "Does Not Contain":
            return { [column]: { $not: new RegExp(value, 'i') } };
        case "Equals":
            return { [column]: value };
        case "Does Not Equal":
            return { [column]: { $ne: value } };
        case "Begins With":
            return { [column]: new RegExp(`^${value}`, 'i') };
        case "Ends With":
            return { [column]: new RegExp(`${value}$`, 'i') };
        case "Blank":
            return { [column]: { $exists: false } };
        case "Not Blank":
            return { [column]: { $exists: true } };
        default:
            return {};
    }
}

